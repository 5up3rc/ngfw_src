diff -urN linux-2.6.7-orig/include/linux/in.h linux-2.6.7-netcap/include/linux/in.h
--- linux-2.6.7-orig/include/linux/in.h	2004-06-15 22:20:26.000000000 -0700
+++ linux-2.6.7-netcap/include/linux/in.h	2004-08-15 19:50:03.000000000 -0700
@@ -71,6 +71,12 @@
 #define IP_FREEBIND	15
 #define IP_IPSEC_POLICY	16
 #define IP_XFRM_POLICY	17
+#define IP_NONLOCAL	18
+#define IP_SADDR	20
+#define IP_DEVICE	21
+#define IP_RECVNFMARK	22
+#define IP_SENDNFMARK	23
+#define IP_FIRSTNFMARK	24
 
 /* BSD compatibility */
 #define IP_RECVRETOPTS	IP_RETOPTS
@@ -184,6 +190,10 @@
 };
 #define sin_zero	__pad		/* for BSD UNIX comp. -FvK	*/
 
+struct ip_sendnfmark_opts {
+    u_int32_t on;
+    u_int32_t mark;
+};
 
 /*
  * Definitions of the bits in an Internet address integer.
diff -urN linux-2.6.7-orig/include/linux/netfilter_ipv4/ipt_DIVERT.h linux-2.6.7-netcap/include/linux/netfilter_ipv4/ipt_DIVERT.h
--- linux-2.6.7-orig/include/linux/netfilter_ipv4/ipt_DIVERT.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.7-netcap/include/linux/netfilter_ipv4/ipt_DIVERT.h	2004-08-15 19:50:03.000000000 -0700
@@ -0,0 +1,9 @@
+/* $Id: netcap.kernel-2.6.7.082104.patch,v 1.1 2004/11/09 19:39:58 dmorris Exp $ */
+#ifndef _IPT_DIVERT_H_target
+#define _IPT_DIVERT_H_target
+
+struct ipt_divert_target_info {
+	unsigned short to_port;
+};
+
+#endif
diff -urN linux-2.6.7-orig/include/linux/netfilter_ipv4/ipt_physdev.h linux-2.6.7-netcap/include/linux/netfilter_ipv4/ipt_physdev.h
--- linux-2.6.7-orig/include/linux/netfilter_ipv4/ipt_physdev.h	2004-06-15 22:19:43.000000000 -0700
+++ linux-2.6.7-netcap/include/linux/netfilter_ipv4/ipt_physdev.h	2004-08-15 19:50:03.000000000 -0700
@@ -13,12 +13,12 @@
 #define IPT_PHYSDEV_OP_MASK		(0x20 - 1)
 
 struct ipt_physdev_info {
+	u_int8_t invert;
+	u_int8_t bitmask;
 	char physindev[IFNAMSIZ];
 	char in_mask[IFNAMSIZ];
 	char physoutdev[IFNAMSIZ];
 	char out_mask[IFNAMSIZ];
-	u_int8_t invert;
-	u_int8_t bitmask;
 };
 
 #endif /*_IPT_PHYSDEV_H*/
diff -urN linux-2.6.7-orig/include/linux/netfilter_ipv4.h linux-2.6.7-netcap/include/linux/netfilter_ipv4.h
--- linux-2.6.7-orig/include/linux/netfilter_ipv4.h	2004-06-15 22:19:52.000000000 -0700
+++ linux-2.6.7-netcap/include/linux/netfilter_ipv4.h	2004-08-15 19:50:03.000000000 -0700
@@ -54,6 +54,7 @@
 	NF_IP_PRI_CONNTRACK_DEFRAG = -400,
 	NF_IP_PRI_RAW = -300,
 	NF_IP_PRI_SELINUX_FIRST = -225,
+	NF_IP_PRI_PRE_CONNTRACK = -225,
 	NF_IP_PRI_CONNTRACK = -200,
 	NF_IP_PRI_BRIDGE_SABOTAGE_FORWARD = -175,
 	NF_IP_PRI_MANGLE = -150,
diff -urN linux-2.6.7-orig/include/linux/udp.h linux-2.6.7-netcap/include/linux/udp.h
--- linux-2.6.7-orig/include/linux/udp.h	2004-06-15 22:19:01.000000000 -0700
+++ linux-2.6.7-netcap/include/linux/udp.h	2004-08-15 19:50:03.000000000 -0700
@@ -28,8 +28,12 @@
 
 /* UDP socket options */
 #define UDP_CORK	1	/* Never send partially complete segments */
+#define UDP_RECVDPORT 2 /* the dest port in ancillary msg */
 #define UDP_ENCAP	100	/* Set the socket to accept encapsulated packets */
 
+/* UDP ancillary data types */
+#define UDP_SPORT 1
+
 /* UDP encapsulation types */
 #define UDP_ENCAP_ESPINUDP_NON_IKE	1 /* draft-ietf-ipsec-nat-t-ike-00/01 */
 #define UDP_ENCAP_ESPINUDP	2 /* draft-ietf-ipsec-udp-encaps-06 */
diff -urN linux-2.6.7-orig/include/net/ip.h linux-2.6.7-netcap/include/net/ip.h
--- linux-2.6.7-orig/include/net/ip.h	2004-06-15 22:19:42.000000000 -0700
+++ linux-2.6.7-netcap/include/net/ip.h	2004-08-15 19:50:03.000000000 -0700
@@ -44,9 +44,15 @@
 	struct ip_options	opt;		/* Compiled IP options		*/
 	unsigned char		flags;
 
+#ifdef CONFIG_NETCAP
+    unsigned char    pkt_ip_ttl;
+    unsigned char    pkt_ip_tos;
+    unsigned short   divert_port;
+#endif
 #define IPSKB_MASQUERADED	1
 #define IPSKB_TRANSLATED	2
 #define IPSKB_FORWARDED		4
+#define IPSKB_DIVERTED		8
 #define IPSKB_XFRM_TUNNEL_SIZE	8
 };
 
@@ -55,6 +61,11 @@
 	u32			addr;
 	int			oif;
 	struct ip_options	*opt;
+#ifdef CONFIG_NETCAP
+    u8 pkt_ip_ttl;
+    u8 pkt_ip_tos;
+    u16 pkt_udp_sport;
+#endif
 };
 
 #define IPCB(skb) ((struct inet_skb_parm*)((skb)->cb))
@@ -91,6 +102,7 @@
 extern int		ip_rcv(struct sk_buff *skb, struct net_device *dev,
 			       struct packet_type *pt);
 extern int		ip_local_deliver(struct sk_buff *skb);
+extern int       ip_local_deliver_finish(struct sk_buff *skb);
 extern int		ip_mr_input(struct sk_buff *skb);
 extern int		ip_output(struct sk_buff **pskb);
 extern int		ip_mc_output(struct sk_buff **pskb);
diff -urN linux-2.6.7-orig/include/net/route.h linux-2.6.7-netcap/include/net/route.h
--- linux-2.6.7-orig/include/net/route.h	2004-06-15 22:18:37.000000000 -0700
+++ linux-2.6.7-netcap/include/net/route.h	2004-08-15 19:50:03.000000000 -0700
@@ -39,12 +39,19 @@
 #endif
 
 #define RTO_ONLINK	0x01
+#define RTO_TPROXY   0x02	
 
 #define RTO_CONN	0
 /* RTO_CONN is not used (being alias for 0), but preserved not to break
  * some modules referring to it. */
 
-#define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sk->sk_localroute)
+#ifdef CONFIG_NETCAP
+#define RTO_SCONN(sk) ((sk)->sk_reuse > 1 ? RTO_TPROXY : 0)
+#else
+#define RTO_SCONN(sk) 0
+#endif
+
+#define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sk->sk_localroute | RTO_SCONN(sk))
 
 struct inet_peer;
 struct rtable
diff -urN linux-2.6.7-orig/include/net/sock.h linux-2.6.7-netcap/include/net/sock.h
--- linux-2.6.7-orig/include/net/sock.h	2004-06-15 22:19:43.000000000 -0700
+++ linux-2.6.7-netcap/include/net/sock.h	2004-08-15 19:50:03.000000000 -0700
@@ -212,6 +212,11 @@
 	unsigned char		sk_no_largesend;
 	int			sk_route_caps;
 	unsigned long	        sk_lingertime;
+#ifdef CONFIG_NETCAP
+	unsigned long	        sk_nfmarkopts;
+	unsigned long	        sk_nfmark;
+	unsigned long	        sk_sendnfmark;
+#endif
 	int			sk_hashent;
 	struct sock		*sk_pair;
 	/*
diff -urN linux-2.6.7-orig/include/net/tcp.h linux-2.6.7-netcap/include/net/tcp.h
--- linux-2.6.7-orig/include/net/tcp.h	2004-06-15 22:18:58.000000000 -0700
+++ linux-2.6.7-netcap/include/net/tcp.h	2004-08-15 19:50:03.000000000 -0700
@@ -780,6 +780,10 @@
 
 extern int			tcp_v4_rcv(struct sk_buff *skb);
 
+#ifdef CONFIG_NETCAP
+extern struct sk_buff *tcp_v4_nonlocal_deliver(struct sk_buff *skb);
+#endif
+    
 extern int			tcp_v4_remember_stamp(struct sock *sk);
 
 extern int		    	tcp_v4_tw_remember_stamp(struct tcp_tw_bucket *tw);
diff -urN linux-2.6.7-orig/net/Kconfig linux-2.6.7-netcap/net/Kconfig
--- linux-2.6.7-orig/net/Kconfig	2004-06-15 22:18:57.000000000 -0700
+++ linux-2.6.7-netcap/net/Kconfig	2004-08-15 19:50:03.000000000 -0700
@@ -54,6 +54,15 @@
 	  the real netlink socket.
 	  This is a backward compatibility option, choose Y for now.
 
+config NETCAP
+	bool "Transparent Proxy extensions (netcap)"
+	---help---
+      Transparent Proxy extensions to the networking stack
+      this includes non-local connection support (requires netfilter module also)
+      and some udp sendmsg ancillary data extensions
+
+	  Unless you really know what you are doing, you should say N here.
+
 config UNIX
 	tristate "Unix domain sockets"
 	---help---
diff -urN linux-2.6.7-orig/net/ipv4/ip_input.c linux-2.6.7-netcap/net/ipv4/ip_input.c
--- linux-2.6.7-orig/net/ipv4/ip_input.c	2004-06-15 22:18:57.000000000 -0700
+++ linux-2.6.7-netcap/net/ipv4/ip_input.c	2004-08-15 19:50:03.000000000 -0700
@@ -196,7 +196,7 @@
 	return 0;
 }
 
-static inline int ip_local_deliver_finish(struct sk_buff *skb)
+inline int ip_local_deliver_finish(struct sk_buff *skb)
 {
 	int ihl = skb->nh.iph->ihl*4;
 
@@ -435,3 +435,4 @@
 
 EXPORT_SYMBOL(ip_rcv);
 EXPORT_SYMBOL(ip_statistics);
+EXPORT_SYMBOL(ip_local_deliver_finish);
diff -urN linux-2.6.7-orig/net/ipv4/ip_output.c linux-2.6.7-netcap/net/ipv4/ip_output.c
--- linux-2.6.7-orig/net/ipv4/ip_output.c	2004-06-15 22:20:22.000000000 -0700
+++ linux-2.6.7-netcap/net/ipv4/ip_output.c	2004-08-15 19:43:29.000000000 -0700
@@ -162,6 +162,10 @@
 	ip_send_check(iph);
 
 	skb->priority = sk->sk_priority;
+#ifdef CONFIG_NETCAP
+	if (sk->sk_nfmarkopts & 0x00000001)
+		skb->nfmark = sk->sk_sendnfmark;
+#endif
 
 	/* Send it out. */
 	return NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, rt->u.dst.dev,
@@ -890,6 +894,17 @@
 			data += fragheaderlen;
 			skb->h.raw = data + exthdrlen;
 
+#ifdef CONFIG_NETCAP
+            if (ipc->pkt_ip_ttl)
+                IPCB(skb)->pkt_ip_ttl = ipc->pkt_ip_ttl;
+            else 
+                IPCB(skb)->pkt_ip_ttl = 0;
+            if (ipc->pkt_ip_tos)
+                IPCB(skb)->pkt_ip_tos = ipc->pkt_ip_tos;
+            else 
+                IPCB(skb)->pkt_ip_tos = 0;
+#endif
+            
 			copy = datalen - transhdrlen;
 			if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, 0, skb) < 0) {
 				err = -EFAULT;
@@ -1162,6 +1177,10 @@
 		ip_options_build(skb, opt, inet->cork.addr, rt, 0);
 	}
 	iph->tos = inet->tos;
+#ifdef CONFIG_NETCAP
+    if (IPCB(skb)->pkt_ip_tos && sk->sk_protocol == IPPROTO_UDP)
+        iph->tos = IPCB(skb)->pkt_ip_tos;
+#endif
 	iph->tot_len = htons(skb->len);
 	iph->frag_off = df;
 	if (!df) {
@@ -1170,6 +1189,10 @@
 		iph->id = htons(inet->id++);
 	}
 	iph->ttl = ttl;
+#ifdef CONFIG_NETCAP
+    if (IPCB(skb)->pkt_ip_tos && sk->sk_protocol == IPPROTO_UDP)
+        iph->tos = IPCB(skb)->pkt_ip_tos;
+#endif
 	iph->protocol = sk->sk_protocol;
 	iph->saddr = rt->rt_src;
 	iph->daddr = rt->rt_dst;
diff -urN linux-2.6.7-orig/net/ipv4/ip_sockglue.c linux-2.6.7-netcap/net/ipv4/ip_sockglue.c
--- linux-2.6.7-orig/net/ipv4/ip_sockglue.c	2004-06-15 22:19:03.000000000 -0700
+++ linux-2.6.7-netcap/net/ipv4/ip_sockglue.c	2004-08-21 17:13:47.000000000 -0700
@@ -50,6 +50,13 @@
 #define IP_CMSG_TOS		4
 #define IP_CMSG_RECVOPTS	8
 #define IP_CMSG_RETOPTS		16
+#ifdef CONFIG_NETCAP
+/*
+ * See udp.c for use of UDP_CMSG_RECVDPORT
+ */
+#define UDP_CMSG_RECVDPORT     32
+#define IP_CMSG_NFMARK		64
+#endif
 
 /*
  *	SOL_IP control messages.
@@ -72,6 +79,14 @@
 	put_cmsg(msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);
 }
 
+#ifdef CONFIG_NETCAP
+static void ip_cmsg_recv_nfmark(struct msghdr *msg, struct sk_buff *skb)
+{
+	unsigned int nfmark = skb->nfmark;
+	put_cmsg(msg, SOL_IP, IP_RECVNFMARK, sizeof(unsigned int), &nfmark);
+}
+#endif
+
 static void ip_cmsg_recv_ttl(struct msghdr *msg, struct sk_buff *skb)
 {
 	int ttl = skb->nh.iph->ttl;
@@ -138,6 +153,12 @@
 
 	if (flags & 1)
 		ip_cmsg_recv_retopts(msg, skb);
+#ifdef CONFIG_NETCAP
+	if ((flags>>=1) == 0)
+		return;
+	if (flags & 1)
+		ip_cmsg_recv_nfmark(msg, skb);
+#endif
 }
 
 int ip_cmsg_send(struct msghdr *msg, struct ipcm_cookie *ipc)
@@ -170,7 +191,45 @@
 			ipc->addr = info->ipi_spec_dst.s_addr;
 			break;
 		}
+#ifdef CONFIG_NETCAP
+        case IP_SADDR:
+        {
+            struct in_addr *in;
+            if (cmsg->cmsg_len != CMSG_LEN(sizeof(struct in_addr))) 
+                return -EINVAL;
+            in = (struct in_addr *)CMSG_DATA(cmsg);
+            ipc->addr = in->s_addr;
+            break;
+        }
+        case IP_TTL:
+        {
+            if (cmsg->cmsg_len != CMSG_LEN(sizeof(unsigned char))) 
+                return -EINVAL;
+            ipc->pkt_ip_ttl = *(u_char *)CMSG_DATA(cmsg);
+            break;
+        }
+        case IP_TOS:
+        {
+            if (cmsg->cmsg_len != CMSG_LEN(sizeof(unsigned char))) 
+                return -EINVAL;
+            ipc->pkt_ip_tos = *(u_char *)CMSG_DATA(cmsg);
+            break;
+        }
+        case IP_DEVICE:
+        {
+            if (cmsg->cmsg_len > IFNAMSIZ)
+                return -EINVAL;
+            else {
+                struct net_device *dev = dev_get_by_name(CMSG_DATA(cmsg));
+                if (!dev)
+                    return -ENODEV;
+                ipc->oif = dev->ifindex;
+            }
+            break;
+        }
+#endif
 		default:
+            printk("Unknown cmsg_type: %i\n",cmsg->cmsg_type);
 			return -EINVAL;
 		}
 	}
@@ -394,10 +453,13 @@
 
 	if (((1<<optname) & ((1<<IP_PKTINFO) | (1<<IP_RECVTTL) | 
 			    (1<<IP_RECVOPTS) | (1<<IP_RECVTOS) | 
+#ifdef CONFIG_NETCAP
+			    (1<<IP_RECVNFMARK) |
+#endif
 			    (1<<IP_RETOPTS) | (1<<IP_TOS) | 
 			    (1<<IP_TTL) | (1<<IP_HDRINCL) | 
 			    (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) | 
-			    (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND))) || 
+			    (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) | (1<<IP_NONLOCAL))) || 
 				optname == IP_MULTICAST_TTL || 
 				optname == IP_MULTICAST_LOOP) { 
 		if (optlen >= sizeof(int)) {
@@ -459,6 +521,34 @@
 			else
 				inet->cmsg_flags &= ~IP_CMSG_PKTINFO;
 			break;
+#ifdef CONFIG_NETCAP
+        case IP_RECVNFMARK:
+            if (val)
+                inet->cmsg_flags |=  IP_CMSG_NFMARK;
+            else
+                inet->cmsg_flags &= ~IP_CMSG_NFMARK;
+             break;
+        case IP_SENDNFMARK:
+        {
+            struct ip_sendnfmark_opts nfopt;
+
+            if (optlen != sizeof(struct ip_sendnfmark_opts))
+                goto e_inval;
+            if (copy_from_user(&nfopt, optval, sizeof(struct ip_sendnfmark_opts))) {
+                err = -EFAULT;
+                break;
+            }
+
+            if (nfopt.on) {
+                sk->sk_sendnfmark = nfopt.mark;
+                sk->sk_nfmarkopts |=  0x00000001;
+            }
+            else {
+                sk->sk_nfmarkopts &= ~0x00000001;
+            }
+            break;
+        }
+#endif
 		case IP_RECVTTL:
 			if (val)
 				inet->cmsg_flags |=  IP_CMSG_TTL;
@@ -523,6 +613,16 @@
 			if (!val)
 				skb_queue_purge(&sk->sk_error_queue);
 			break;
+       case IP_NONLOCAL:
+           if (optlen<1)
+               goto e_inval;
+           /* if (!capable(CAP_NET_ADMIN)) */
+           /*    goto e_inval;             */
+           if (val)
+               sk->sk_reuse = 2;
+           else if (sk->sk_reuse == 2)
+               sk->sk_reuse = 1;
+           break;
 		case IP_MULTICAST_TTL:
 			if (sk->sk_type == SOCK_STREAM)
 				goto e_inval;
@@ -922,6 +1022,30 @@
 					return -EFAULT;
 				return 0;
 			}
+#ifdef CONFIG_NETCAP
+		case IP_SENDNFMARK:
+        {
+            struct ip_sendnfmark_opts opts;
+
+            if (sk->sk_nfmarkopts & 0x00000001) 
+                opts.on = 1;
+	    else
+                opts.on = 0;
+            opts.mark =  sk->sk_sendnfmark;
+	    release_sock(sk);
+            
+			if (len < sizeof(struct ip_sendnfmark_opts)) {
+				return -EINVAL;
+			}
+			if(copy_to_user(optval, &opts, sizeof(struct ip_sendnfmark_opts))) {
+				return -EFAULT;
+			}
+            return 0;
+        }
+		case IP_FIRSTNFMARK:
+			val = sk->sk_nfmark;
+			break;
+#endif
 		case IP_PKTINFO:
 			val = (inet->cmsg_flags & IP_CMSG_PKTINFO) != 0;
 			break;
diff -urN linux-2.6.7-orig/net/ipv4/netfilter/Kconfig linux-2.6.7-netcap/net/ipv4/netfilter/Kconfig
--- linux-2.6.7-orig/net/ipv4/netfilter/Kconfig	2004-06-15 22:19:52.000000000 -0700
+++ linux-2.6.7-netcap/net/ipv4/netfilter/Kconfig	2004-08-15 19:50:03.000000000 -0700
@@ -5,6 +5,15 @@
 menu "IP: Netfilter Configuration"
 	depends on INET && NETFILTER
 
+config IP_NF_NONLOCAL
+	tristate "Nonlocal Connection Support"
+	depends on NETCAP
+	---help---
+      Nonlocal connection support
+
+	  If you want to compile it as a module, say M here and read
+	  <file:Documentation/modules.txt>.  If unsure, say `N'.
+
 config IP_NF_CONNTRACK
 	tristate "Connection tracking (required for masq/NAT)"
 	---help---
@@ -478,6 +487,17 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config IP_NF_TARGET_DIVERT
+	tristate "DIVERT target support"
+	depends on IP_NF_MANGLE
+	depends on NETCAP
+	help
+	  This options add a `DIVERT` target, which allows you to create rules       
+	  in the `mangle' table which statelessly divert packets to a local port
+
+	  If you want to compile it as a module, say M here and read
+	  <file:Documentation/modules.txt>.  If unsure, say `N'.
+
 config IP_NF_TARGET_LOG
 	tristate "LOG target support"
 	depends on IP_NF_IPTABLES
diff -urN linux-2.6.7-orig/net/ipv4/netfilter/Makefile linux-2.6.7-netcap/net/ipv4/netfilter/Makefile
--- linux-2.6.7-orig/net/ipv4/netfilter/Makefile	2004-06-15 22:19:01.000000000 -0700
+++ linux-2.6.7-netcap/net/ipv4/netfilter/Makefile	2004-08-15 19:50:03.000000000 -0700
@@ -19,6 +19,9 @@
 # connection tracking
 obj-$(CONFIG_IP_NF_CONNTRACK) += ip_conntrack.o
 
+# non-local support
+obj-$(CONFIG_IP_NF_NONLOCAL) += ip_nonlocal.o
+
 # connection tracking helpers
 obj-$(CONFIG_IP_NF_AMANDA) += ip_conntrack_amanda.o
 obj-$(CONFIG_IP_NF_TFTP) += ip_conntrack_tftp.o
@@ -64,6 +67,7 @@
 obj-$(CONFIG_IP_NF_MATCH_STATE) += ipt_state.o
 obj-$(CONFIG_IP_NF_MATCH_CONNTRACK) += ipt_conntrack.o
 obj-$(CONFIG_IP_NF_MATCH_TCPMSS) += ipt_tcpmss.o
+obj-$(CONFIG_IP_NF_TARGET_DIVERT) += ipt_DIVERT.o 
 
 obj-$(CONFIG_IP_NF_MATCH_PHYSDEV) += ipt_physdev.o
 
diff -urN linux-2.6.7-orig/net/ipv4/netfilter/ip_nonlocal.c linux-2.6.7-netcap/net/ipv4/netfilter/ip_nonlocal.c
--- linux-2.6.7-orig/net/ipv4/netfilter/ip_nonlocal.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.7-netcap/net/ipv4/netfilter/ip_nonlocal.c	2004-08-15 19:50:03.000000000 -0700
@@ -0,0 +1,71 @@
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/ip.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+#include <net/tcp.h>
+#include <net/checksum.h>
+
+MODULE_LICENSE("GPL");
+
+/* Netfilter hook itself. */
+static unsigned int ip_nonlocal_in(unsigned int hooknum,
+                                    struct sk_buff **pskb,
+                                    const struct net_device *in,
+                                    const struct net_device *out,
+                                    int (*okfn)(struct sk_buff *))
+{
+    struct sk_buff* skb = *pskb;
+    if (skb->nh.iph->protocol == IPPROTO_TCP) {           
+        if ((skb = tcp_v4_nonlocal_deliver(skb)) == NULL) 
+            return NF_STOLEN;                        
+    }                                                     
+
+    return NF_ACCEPT;
+}
+
+static struct nf_hook_ops ip_nonlocal_forward_ops = {
+	.hook		= ip_nonlocal_in,
+	.pf		= PF_INET,
+	.hooknum	= NF_IP_PRE_ROUTING,
+	.priority	= NF_IP_PRI_FIRST+1,
+};
+
+static int init_or_cleanup(int init)
+{
+	int ret = 0;
+
+	if (!init) 
+        goto cleanup;
+
+	ret = nf_register_hook(&ip_nonlocal_forward_ops);
+	if (ret < 0) {
+		printk("ip_nonlocal: can't register pre-routing hook.\n");
+		goto cleanup;
+	}
+
+	return ret;
+
+ cleanup:
+	nf_unregister_hook(&ip_nonlocal_forward_ops);
+	return ret;
+}
+
+static int __init init(void)
+{
+	return init_or_cleanup(1);
+}
+
+static void __exit fini(void)
+{
+	init_or_cleanup(0);
+}
+
+module_init(init);
+module_exit(fini);
+
+
diff -urN linux-2.6.7-orig/net/ipv4/netfilter/ipt_DIVERT.c linux-2.6.7-netcap/net/ipv4/netfilter/ipt_DIVERT.c
--- linux-2.6.7-orig/net/ipv4/netfilter/ipt_DIVERT.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.7-netcap/net/ipv4/netfilter/ipt_DIVERT.c	2004-08-15 19:50:03.000000000 -0700
@@ -0,0 +1,90 @@
+/*
+ * This is a module which is used for diverting packets.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_DIVERT.h>
+#include <net/ip.h>
+#include <net/udp.h>
+
+static unsigned int divert(struct sk_buff **pskb,
+                           const struct net_device *in,
+                           const struct net_device *out,
+                           unsigned int hooknum,
+                           const void *targinfo,
+                           void *userinfo)
+{
+    const struct ipt_divert_target_info *divinfo = targinfo;
+    struct sk_buff* skb = *pskb;
+
+    IPCB(skb)->flags      |= IPSKB_DIVERTED;
+    IPCB(skb)->divert_port = divinfo->to_port;
+
+    if (skb->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
+        skb = ip_defrag(skb);
+        if (!skb)
+            return NF_DROP;
+    }
+
+    skb = skb_get(skb); /* inc ref count */
+    if (!skb->dev)
+        skb->dev = skb->dst->dev;
+
+    ip_local_deliver_finish(skb);
+
+    return NF_DROP;   
+}
+
+static int check(const char *tablename,
+                 const struct ipt_entry *e,
+                 void *targinfo,
+                 unsigned int targinfosize,
+                 unsigned int hook_mask)
+{
+
+    if (strcmp(tablename, "mangle") != 0) {
+        printk(KERN_WARNING "divert_check: divert can only be called from the \"mangle\" table (not \"%s\").\n",tablename);
+        return 0;
+    }
+    if (hook_mask & ~(1 << NF_IP_POST_ROUTING) &&
+        hook_mask & ~(1 << NF_IP_FORWARD) &&
+        hook_mask & ~(1 << NF_IP_PRE_ROUTING)) {
+        printk(KERN_WARNING "divert_check: bad hooks %x.\n", hook_mask);
+        return 0;
+    }
+    if (targinfosize != IPT_ALIGN(sizeof(struct ipt_divert_target_info))) {
+        printk(KERN_WARNING "divert_check: bad target size.\n");
+        return 0;
+    }
+
+    return 1;
+}
+
+
+static struct ipt_target ipt_divert_reg = {
+	.name		= "DIVERT",
+	.target		= divert,
+	.checkentry	= check,
+	.me		= THIS_MODULE,
+};
+
+static int __init init(void)
+{
+    if (ipt_register_target(&ipt_divert_reg))
+    return -EINVAL;
+ return 0;
+}
+
+static void __exit fini(void)
+{
+    ipt_unregister_target(&ipt_divert_reg);
+}
+
+module_init(init);
+module_exit(fini);
+MODULE_LICENSE("GPL");
diff -urN linux-2.6.7-orig/net/ipv4/raw.c linux-2.6.7-netcap/net/ipv4/raw.c
--- linux-2.6.7-orig/net/ipv4/raw.c	2004-06-15 22:19:36.000000000 -0700
+++ linux-2.6.7-netcap/net/ipv4/raw.c	2004-08-15 19:50:03.000000000 -0700
@@ -392,6 +392,10 @@
 
 	saddr = ipc.addr;
 	ipc.addr = daddr;
+#ifdef CONFIG_NETCAP
+    ipc.pkt_ip_ttl = 0;
+    ipc.pkt_ip_tos = 0;
+#endif
 
 	if (!ipc.opt)
 		ipc.opt = inet->opt;
@@ -412,6 +416,9 @@
 	tos = RT_TOS(inet->tos) | sk->sk_localroute;
 	if (msg->msg_flags & MSG_DONTROUTE)
 		tos |= RTO_ONLINK;
+#ifdef CONFIG_NETCAP
+        tos |= saddr ? RTO_TPROXY : 0;
+#endif
 
 	if (MULTICAST(daddr)) {
 		if (!ipc.oif)
diff -urN linux-2.6.7-orig/net/ipv4/route.c linux-2.6.7-netcap/net/ipv4/route.c
--- linux-2.6.7-orig/net/ipv4/route.c	2004-06-15 22:20:26.000000000 -0700
+++ linux-2.6.7-netcap/net/ipv4/route.c	2004-08-15 19:50:03.000000000 -0700
@@ -1974,8 +1974,19 @@
 
 		/* It is equivalent to inet_addr_type(saddr) == RTN_LOCAL */
 		dev_out = ip_dev_find(oldflp->fl4_src);
+#ifdef CONFIG_NETCAP
+        /* If address is not local, test for nonlocal flag;
+         * if address is local --- clear the flag.
+         */
+        if (dev_out == NULL) {
+            if (!(oldflp->fl4_tos & RTO_TPROXY) || inet_addr_type(oldflp->fl4_src) != RTN_UNICAST)
+                goto out;
+            flags |= RTCF_TPROXY;
+        }
+#else
 		if (dev_out == NULL)
 			goto out;
+#endif
 
 		/* I removed check for oif == dev_out->oif here.
 		   It was wrong for two reasons:
@@ -1986,6 +1997,7 @@
 		 */
 
 		if (oldflp->oif == 0
+           && dev_out
 		    && (MULTICAST(oldflp->fl4_dst) || oldflp->fl4_dst == 0xFFFFFFFF)) {
 			/* Special hack: user can direct multicasts
 			   and limited broadcast via necessary interface
diff -urN linux-2.6.7-orig/net/ipv4/tcp_ipv4.c linux-2.6.7-netcap/net/ipv4/tcp_ipv4.c
--- linux-2.6.7-orig/net/ipv4/tcp_ipv4.c	2004-06-15 22:19:10.000000000 -0700
+++ linux-2.6.7-netcap/net/ipv4/tcp_ipv4.c	2004-08-15 19:50:03.000000000 -0700
@@ -1578,6 +1578,9 @@
 		goto exit;
 
 	newsk->sk_dst_cache = dst;
+#ifdef CONFIG_NETCAP
+	newsk->sk_nfmark = skb->nfmark;
+#endif
 	tcp_v4_setup_caps(newsk, dst);
 
 	newtp		      = tcp_sk(newsk);
@@ -1859,6 +1862,56 @@
 	goto discard_it;
 }
 
+#ifdef CONFIG_NETCAP
+/* Could be done with netfilter hook. Not clear how to hook this in right place. */
+
+struct sk_buff *tcp_v4_nonlocal_deliver(struct sk_buff *skb)
+{
+    struct sock *sk;
+    struct tcphdr *th;
+    int ihl;
+
+    if (skb->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
+        skb = ip_defrag(skb);
+        if (!skb)
+            return NULL;
+    }
+
+    ihl = skb->nh.iph->ihl*4;
+
+    if (!pskb_may_pull(skb, ihl+8))
+        goto out;
+
+    th = (struct tcphdr*)(skb->nh.raw + ihl);
+    
+    sk = __tcp_v4_lookup_established(skb->nh.iph->saddr, th->source,
+                                     skb->nh.iph->daddr, ntohs(th->dest),
+                                     skb->dev->ifindex); 
+
+    if (sk && sk->sk_reuse == 2) { /*exist and nonlocal bound*/
+        struct iphdr  *iph;
+        iph = skb->nh.iph;
+
+        if (skb->dst == NULL) {
+            if (ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, skb->dev)) {
+                printk("ip_route_input failed\n");
+                goto out; 
+            }
+        }
+
+        skb->pkt_type = PACKET_HOST;
+        sock_put(sk);
+        ip_local_deliver(skb);
+        return NULL;
+    }
+    else if (sk) /*exist and is not nonlocally bound */
+        sock_put(sk);
+
+ out:
+    return skb;
+}
+#endif
+
 /* With per-bucket locks this operation is not-atomic, so that
  * this version is not worse.
  */
diff -urN linux-2.6.7-orig/net/ipv4/udp.c linux-2.6.7-netcap/net/ipv4/udp.c
--- linux-2.6.7-orig/net/ipv4/udp.c	2004-06-15 22:18:59.000000000 -0700
+++ linux-2.6.7-netcap/net/ipv4/udp.c	2004-08-21 17:15:03.000000000 -0700
@@ -108,6 +108,29 @@
 #include <net/checksum.h>
 #include <net/xfrm.h>
 
+#ifdef CONFIG_NETCAP
+/*
+ * See ip_sockglue.c for potential conflicts with UDP_CMSG_RECVDPORT
+ */
+#define UDP_CMSG_RECVDPORT     32
+
+static void udp_cmsg_recv_dport(struct msghdr *msg, struct sk_buff *skb)
+{
+    put_cmsg(msg, SOL_UDP, UDP_RECVDPORT, sizeof(unsigned short), &skb->h.uh->dest);
+}
+
+void udp_cmsg_recv(struct msghdr *msg, struct sk_buff *skb)
+{
+	struct inet_opt *inet = inet_sk(skb->sk);
+	unsigned flags = inet->cmsg_flags;
+    
+    if (flags & UDP_CMSG_RECVDPORT)
+        udp_cmsg_recv_dport(msg, skb);
+
+    ip_cmsg_recv(msg, skb);
+}
+#endif
+
 /*
  *	Snmp MIB for the UDP layer
  */
@@ -216,6 +239,34 @@
 	write_unlock_bh(&udp_hash_lock);
 }
 
+#ifdef CONFIG_NETCAP
+static int udp_cmsg_send(struct msghdr *msg, struct ipcm_cookie *ipc)
+{
+    struct cmsghdr *cmsg;
+ 
+    for (cmsg = CMSG_FIRSTHDR(msg); cmsg;
+         cmsg = CMSG_NXTHDR(msg, cmsg)) {
+ 
+        if (cmsg->cmsg_level == SOL_UDP) {
+            switch (cmsg->cmsg_type) {
+ 
+            case UDP_SPORT:
+                if (cmsg->cmsg_len != CMSG_LEN(sizeof(u_short)))
+                    return -EINVAL;
+                ipc->pkt_udp_sport = *(u_short*)CMSG_DATA(cmsg);
+                break;
+                 
+            default:
+                printk("Unknown cmsg_type: %i\n",cmsg->cmsg_type);
+                return -EINVAL;
+            }
+        }
+    }
+ 
+    return ip_cmsg_send(msg,ipc);
+}
+#endif 
+
 /* UDP is nearly always wildcards out the wazoo, it makes no sense to try
  * harder than this. -DaveM
  */
@@ -488,7 +539,7 @@
 	int free = 0;
 	int connected = 0;
 	u32 daddr, faddr, saddr;
-	u16 dport;
+	u16 dport, sport;
 	u8  tos;
 	int err;
 	int corkreq = up->corkflag || msg->msg_flags&MSG_MORE;
@@ -550,9 +601,19 @@
   	}
 	ipc.addr = inet->saddr;
 
+#ifdef CONFIG_NETCAP
+    ipc.pkt_ip_ttl    = 0;
+    ipc.pkt_ip_tos    = 0;
+    ipc.pkt_udp_sport = 0;
+#endif
+
 	ipc.oif = sk->sk_bound_dev_if;
 	if (msg->msg_controllen) {
+#ifdef CONFIG_NETCAP
+       err = udp_cmsg_send(msg, &ipc);
+#else
 		err = ip_cmsg_send(msg, &ipc);
+#endif
 		if (err)
 			return err;
 		if (ipc.opt)
@@ -562,6 +623,11 @@
 	if (!ipc.opt)
 		ipc.opt = inet->opt;
 
+    sport = inet->sport;
+#ifdef CONFIG_NETCAP
+    if (ipc.pkt_udp_sport)
+        sport = ipc.pkt_udp_sport;
+#endif
 	saddr = ipc.addr;
 	ipc.addr = faddr = daddr;
 
@@ -572,6 +638,10 @@
 		connected = 0;
 	}
 	tos = RT_TOS(inet->tos);
+#ifdef CONFIG_NETCAP
+    if (ipc.pkt_udp_sport || ipc.addr)
+        tos |= RTO_TPROXY;
+#endif
 	if (sk->sk_localroute || (msg->msg_flags & MSG_DONTROUTE) || 
 	    (ipc.opt && ipc.opt->is_strictroute)) {
 		tos |= RTO_ONLINK;
@@ -597,7 +667,7 @@
 						.tos = tos } },
 				    .proto = IPPROTO_UDP,
 				    .uli_u = { .ports =
-					       { .sport = inet->sport,
+					       { .sport = sport,
 						 .dport = dport } } };
 		err = ip_route_output_flow(&rt, &fl, sk, !(msg->msg_flags&MSG_DONTWAIT));
 		if (err)
@@ -635,7 +705,7 @@
 	inet->cork.fl.fl4_dst = daddr;
 	inet->cork.fl.fl_ip_dport = dport;
 	inet->cork.fl.fl4_src = saddr;
-	inet->cork.fl.fl_ip_sport = inet->sport;
+	inet->cork.fl.fl_ip_sport = sport;
 	up->pending = AF_INET;
 
 do_append_data:
@@ -789,6 +859,7 @@
 
 try_again:
 	skb = skb_recv_datagram(sk, flags, noblock, &err);
+
 	if (!skb)
 		goto out;
   
@@ -827,7 +898,11 @@
 		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
   	}
 	if (inet->cmsg_flags)
+#ifdef CONFIG_NETCAP
+	udp_cmsg_recv(msg, skb);
+#else
 		ip_cmsg_recv(msg, skb);
+#endif
 	err = copied;
   
 out_free:
@@ -1191,10 +1266,17 @@
 	if (udp_checksum_init(skb, uh, ulen, saddr, daddr) < 0)
 		goto csum_error;
 
-	if(rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST))
+	if(rt && (rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST)))
 		return udp_v4_mcast_deliver(skb, uh, saddr, daddr);
 
+#ifdef CONFIG_NETCAP
+    if(IPCB(skb)->flags & IPSKB_DIVERTED) 
+        sk = udp_v4_lookup(saddr, uh->source, daddr, IPCB(skb)->divert_port, skb->dev->ifindex);
+	else
+	sk = udp_v4_lookup(saddr, uh->source, daddr, uh->dest, skb->dev->ifindex);
+#else
 	sk = udp_v4_lookup(saddr, uh->source, daddr, uh->dest, skb->dev->ifindex);
+#endif
 
 	if (sk != NULL) {
 		int ret = udp_queue_rcv_skb(sk, skb);
@@ -1295,6 +1377,14 @@
 			release_sock(sk);
 		}
 		break;
+#ifdef CONFIG_NETCAP
+    case UDP_RECVDPORT: 
+        if (val)
+            inet_sk(sk)->cmsg_flags |= UDP_CMSG_RECVDPORT;
+        else
+            inet_sk(sk)->cmsg_flags &= ~UDP_CMSG_RECVDPORT;
+        break;
+#endif
 		
 	case UDP_ENCAP:
 		up->encap_type = val;
@@ -1329,6 +1419,11 @@
 	case UDP_CORK:
 		val = up->corkflag;
 		break;
+#ifdef CONFIG_NETCAP
+    case UDP_RECVDPORT:
+        val = ((inet_sk(sk)->cmsg_flags & UDP_CMSG_RECVDPORT) != 0);
+        break;
+#endif
 
 	case UDP_ENCAP:
 		val = up->encap_type;
