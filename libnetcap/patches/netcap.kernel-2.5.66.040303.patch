diff -urN --ignore-all-space linux-2.5.66-orig/include/linux/in.h linux-2.5.66-tproxy/include/linux/in.h
--- linux-2.5.66-orig/include/linux/in.h	Wed Apr  2 11:47:47 2003
+++ linux-2.5.66-tproxy/include/linux/in.h	Thu Apr  3 14:04:27 2003
@@ -71,6 +71,8 @@
 #define IP_FREEBIND	15
 #define IP_IPSEC_POLICY	16
 #define IP_XFRM_POLICY	17
+#define IP_NONLOCAL	18
+#define IP_SADDR     20
 
 /* BSD compatibility */
 #define IP_RECVRETOPTS	IP_RETOPTS
diff -urN --ignore-all-space linux-2.5.66-orig/include/linux/netfilter_ipv4/ipt_DIVERT.h linux-2.5.66-tproxy/include/linux/netfilter_ipv4/ipt_DIVERT.h
--- linux-2.5.66-orig/include/linux/netfilter_ipv4/ipt_DIVERT.h	Wed Dec 31 16:00:00 1969
+++ linux-2.5.66-tproxy/include/linux/netfilter_ipv4/ipt_DIVERT.h	Thu Apr  3 14:04:27 2003
@@ -0,0 +1,9 @@
+/* $Id: netcap.kernel-2.5.66.040303.patch,v 1.1 2004/11/09 19:39:57 dmorris Exp $ */
+#ifndef _IPT_DIVERT_H_target
+#define _IPT_DIVERT_H_target
+
+struct ipt_divert_target_info {
+	unsigned short to_port;
+};
+
+#endif
diff -urN --ignore-all-space linux-2.5.66-orig/include/linux/udp.h linux-2.5.66-tproxy/include/linux/udp.h
--- linux-2.5.66-orig/include/linux/udp.h	Wed Apr  2 11:47:46 2003
+++ linux-2.5.66-tproxy/include/linux/udp.h	Thu Apr  3 14:04:27 2003
@@ -30,6 +30,10 @@
 
 /* UDP socket options */
 #define UDP_CORK	1	/* Never send partially complete segments */
+#define UDP_RECVDPORT 2
+
+/* UDP ancillary data types */
+#define UDP_SPORT 1
 
 struct udp_opt {
 	int		pending;	/* Any pending frames ? */
diff -urN --ignore-all-space linux-2.5.66-orig/include/net/ip.h linux-2.5.66-tproxy/include/net/ip.h
--- linux-2.5.66-orig/include/net/ip.h	Wed Apr  2 11:47:48 2003
+++ linux-2.5.66-tproxy/include/net/ip.h	Thu Apr  3 14:04:27 2003
@@ -43,10 +43,16 @@
 {
 	struct ip_options	opt;		/* Compiled IP options		*/
 	unsigned char		flags;
-
+#ifdef CONFIG_TPROXY
+    unsigned char    pkt_ip_ttl;
+    unsigned char    pkt_ip_tos;
+    unsigned short   divert_port;
+#endif
 #define IPSKB_MASQUERADED	1
 #define IPSKB_TRANSLATED	2
 #define IPSKB_FORWARDED		4
+#define IPSKB_DIVERTED		8
+
 };
 
 struct ipcm_cookie
@@ -54,6 +60,11 @@
 	u32			addr;
 	int			oif;
 	struct ip_options	*opt;
+#ifdef CONFIG_TPROXY
+    u8 pkt_ip_ttl;
+    u8 pkt_ip_tos;
+    u16 pkt_udp_sport;
+#endif
 };
 
 #define IPCB(skb) ((struct inet_skb_parm*)((skb)->cb))
@@ -90,6 +101,7 @@
 extern int		ip_rcv(struct sk_buff *skb, struct net_device *dev,
 			       struct packet_type *pt);
 extern int		ip_local_deliver(struct sk_buff *skb);
+extern int       ip_local_deliver_finish(struct sk_buff *skb);
 extern int		ip_mr_input(struct sk_buff *skb);
 extern int		ip_output(struct sk_buff *skb);
 extern int		ip_mc_output(struct sk_buff *skb);
diff -urN --ignore-all-space linux-2.5.66-orig/include/net/route.h linux-2.5.66-tproxy/include/net/route.h
--- linux-2.5.66-orig/include/net/route.h	Wed Apr  2 11:47:48 2003
+++ linux-2.5.66-tproxy/include/net/route.h	Thu Apr  3 14:04:27 2003
@@ -39,12 +39,19 @@
 #endif
 
 #define RTO_ONLINK	0x01
+#define RTO_TPROXY   0x02	
 
 #define RTO_CONN	0
 /* RTO_CONN is not used (being alias for 0), but preserved not to break
  * some modules referring to it. */
 
-#define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sk->localroute)
+#ifdef CONFIG_TPROXY
+#define RTO_SCONN(sk) ((sk)->reuse > 1 ? RTO_TPROXY : 0)
+#else
+#define RTO_SCONN(sk) 0
+#endif
+
+#define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sk->localroute | RTO_SCONN(sk))
 
 struct inet_peer;
 struct rtable
diff -urN --ignore-all-space linux-2.5.66-orig/include/net/tcp.h linux-2.5.66-tproxy/include/net/tcp.h
--- linux-2.5.66-orig/include/net/tcp.h	Wed Apr  2 11:47:48 2003
+++ linux-2.5.66-tproxy/include/net/tcp.h	Thu Apr  3 14:04:27 2003
@@ -649,6 +649,10 @@
 
 extern int			tcp_v4_rcv(struct sk_buff *skb);
 
+#ifdef CONFIG_TPROXY
+extern struct sk_buff *tcp_v4_nonlocal_deliver(struct sk_buff *skb);
+#endif
+    
 extern int			tcp_v4_remember_stamp(struct sock *sk);
 
 extern int		    	tcp_v4_tw_remember_stamp(struct tcp_tw_bucket *tw);
diff -urN --ignore-all-space linux-2.5.66-orig/net/Kconfig linux-2.5.66-tproxy/net/Kconfig
--- linux-2.5.66-orig/net/Kconfig	Wed Apr  2 11:48:32 2003
+++ linux-2.5.66-tproxy/net/Kconfig	Thu Apr  3 14:04:27 2003
@@ -134,6 +134,15 @@
 
 	  If unsure, say N.
 
+config TPROXY
+	bool "Transparent Proxy extensions"
+	---help---
+      Transparent Proxy extensions to the networking stack
+      this includes non-local connection support, and some udp sendmsg
+      ancillary data extensions
+
+	  Unless you really know what you are doing, you should say N here.
+
 config UNIX
 	tristate "Unix domain sockets"
 	---help---
diff -urN --ignore-all-space linux-2.5.66-orig/net/bridge/br_forward.c linux-2.5.66-tproxy/net/bridge/br_forward.c
--- linux-2.5.66-orig/net/bridge/br_forward.c	Wed Apr  2 11:48:31 2003
+++ linux-2.5.66-tproxy/net/bridge/br_forward.c	Thu Apr  3 14:04:27 2003
@@ -19,6 +19,8 @@
 #include <linux/skbuff.h>
 #include <linux/if_bridge.h>
 #include <linux/netfilter_bridge.h>
+#include <net/ip.h>
+#include <net/tcp.h>
 #include "br_private.h"
 
 static inline int should_deliver(struct net_bridge_port *p, struct sk_buff *skb)
@@ -86,6 +88,15 @@
 /* called under bridge lock */
 void br_forward(struct net_bridge_port *to, struct sk_buff *skb)
 {
+
+#ifdef CONFIG_TPROXY
+    /* Could be done with a netfilter hook. Not clear how exactly. */
+    if (skb->nh.iph && skb->nh.iph->protocol == IPPROTO_TCP) {
+        if ((skb = tcp_v4_nonlocal_deliver(skb)) == NULL)
+            return;
+    }
+#endif
+
 	if (should_deliver(to, skb)) {
 		__br_forward(to, skb);
 		return;
diff -urN --ignore-all-space linux-2.5.66-orig/net/ipv4/ip_forward.c linux-2.5.66-tproxy/net/ipv4/ip_forward.c
--- linux-2.5.66-orig/net/ipv4/ip_forward.c	Wed Apr  2 11:48:30 2003
+++ linux-2.5.66-tproxy/net/ipv4/ip_forward.c	Thu Apr  3 14:04:27 2003
@@ -69,6 +69,15 @@
 	if (skb->pkt_type != PACKET_HOST)
 		goto drop;
 
+#ifdef CONFIG_TPROXY
+    /* Could be done with a netfilter hook. Not clear how exactly. */
+    if (skb->nh.iph->protocol == IPPROTO_TCP) {
+        if ((skb = tcp_v4_nonlocal_deliver(skb)) == NULL)
+            return NET_RX_SUCCESS;
+        opt = &(IPCB(skb)->opt);
+    }
+#endif
+
 	skb->ip_summed = CHECKSUM_NONE;
 	
 	/*
diff -urN --ignore-all-space linux-2.5.66-orig/net/ipv4/ip_input.c linux-2.5.66-tproxy/net/ipv4/ip_input.c
--- linux-2.5.66-orig/net/ipv4/ip_input.c	Wed Apr  2 11:48:30 2003
+++ linux-2.5.66-tproxy/net/ipv4/ip_input.c	Thu Apr  3 14:04:27 2003
@@ -195,7 +195,7 @@
 	return 0;
 }
 
-static inline int ip_local_deliver_finish(struct sk_buff *skb)
+inline int ip_local_deliver_finish(struct sk_buff *skb)
 {
 	int ihl = skb->nh.iph->ihl*4;
 
diff -urN --ignore-all-space linux-2.5.66-orig/net/ipv4/ip_output.c linux-2.5.66-tproxy/net/ipv4/ip_output.c
--- linux-2.5.66-orig/net/ipv4/ip_output.c	Wed Apr  2 11:48:30 2003
+++ linux-2.5.66-tproxy/net/ipv4/ip_output.c	Thu Apr  3 14:04:27 2003
@@ -868,6 +868,17 @@
 			data += fragheaderlen;
 			skb->h.raw = data + exthdrlen;
 
+#ifdef CONFIG_TPROXY
+            if (ipc->pkt_ip_ttl)
+                IPCB(skb)->pkt_ip_ttl = ipc->pkt_ip_ttl;
+            else 
+                IPCB(skb)->pkt_ip_ttl = 0;
+            if (ipc->pkt_ip_tos)
+                IPCB(skb)->pkt_ip_tos = ipc->pkt_ip_tos;
+            else 
+                IPCB(skb)->pkt_ip_tos = 0;
+#endif
+            
 			copy = datalen - transhdrlen;
 			if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, 0, skb) < 0) {
 				err = -EFAULT;
@@ -1140,6 +1151,10 @@
 		ip_options_build(skb, opt, inet->cork.addr, rt, 0);
 	}
 	iph->tos = inet->tos;
+#ifdef CONFIG_TPROXY
+    if (IPCB(skb)->pkt_ip_tos && sk->protocol == IPPROTO_UDP)
+        iph->tos = IPCB(skb)->pkt_ip_tos;
+#endif
 	iph->tot_len = htons(skb->len);
 	iph->frag_off = df;
 	if (!df) {
@@ -1148,6 +1163,10 @@
 		iph->id = htons(inet->id++);
 	}
 	iph->ttl = ttl;
+#ifdef CONFIG_TPROXY
+    if (IPCB(skb)->pkt_ip_ttl && sk->protocol == IPPROTO_UDP)
+        iph->ttl = IPCB(skb)->pkt_ip_ttl;
+#endif
 	iph->protocol = sk->protocol;
 	iph->saddr = rt->rt_src;
 	iph->daddr = rt->rt_dst;
diff -urN --ignore-all-space linux-2.5.66-orig/net/ipv4/ip_sockglue.c linux-2.5.66-tproxy/net/ipv4/ip_sockglue.c
--- linux-2.5.66-orig/net/ipv4/ip_sockglue.c	Wed Apr  2 11:48:30 2003
+++ linux-2.5.66-tproxy/net/ipv4/ip_sockglue.c	Thu Apr  3 14:04:27 2003
@@ -169,7 +169,33 @@
 			ipc->addr = info->ipi_spec_dst.s_addr;
 			break;
 		}
+#ifdef CONFIG_TPROXY
+        case IP_SADDR:
+        {
+            struct in_addr *in;
+            if (cmsg->cmsg_len != CMSG_LEN(sizeof(struct in_addr))) 
+                return -EINVAL;
+            in = (struct in_addr *)CMSG_DATA(cmsg);
+            ipc->addr = in->s_addr;
+            break;
+        }
+        case IP_TTL:
+        {
+            if (cmsg->cmsg_len != CMSG_LEN(sizeof(unsigned char))) 
+                return -EINVAL;
+            ipc->pkt_ip_ttl = *(u_char *)CMSG_DATA(cmsg);
+            break;
+        }
+        case IP_TOS:
+        {
+            if (cmsg->cmsg_len != CMSG_LEN(sizeof(unsigned char))) 
+                return -EINVAL;
+            ipc->pkt_ip_tos = *(u_char *)CMSG_DATA(cmsg);
+            break;
+        }
+#endif
 		default:
+            printk("Unknown cmsg_type: %i\n",cmsg->cmsg_type);
 			return -EINVAL;
 		}
 	}
@@ -397,7 +423,7 @@
 			    (1<<IP_RETOPTS) | (1<<IP_TOS) | 
 			    (1<<IP_TTL) | (1<<IP_HDRINCL) | 
 			    (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) | 
-			    (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND))) || 
+			    (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) | (1<<IP_NONLOCAL))) || 
 				optname == IP_MULTICAST_TTL || 
 				optname == IP_MULTICAST_LOOP) { 
 		if (optlen >= sizeof(int)) {
@@ -524,6 +550,16 @@
 			if (!val)
 				skb_queue_purge(&sk->error_queue);
 			break;
+       case IP_NONLOCAL:
+           if (optlen<1)
+               goto e_inval;
+           if (!capable(CAP_NET_ADMIN))
+               goto e_inval;
+           if (val)
+               sk->reuse = 2;
+           else if (sk->reuse == 2)
+               sk->reuse = 1;
+           break;
 		case IP_MULTICAST_TTL:
 			if (sk->type == SOCK_STREAM)
 				goto e_inval;
diff -urN --ignore-all-space linux-2.5.66-orig/net/ipv4/netfilter/Kconfig linux-2.5.66-tproxy/net/ipv4/netfilter/Kconfig
--- linux-2.5.66-orig/net/ipv4/netfilter/Kconfig	Wed Apr  2 11:48:30 2003
+++ linux-2.5.66-tproxy/net/ipv4/netfilter/Kconfig	Thu Apr  3 14:04:27 2003
@@ -443,6 +443,17 @@
 	  If you want to compile it as a module, say M here and read
 	  <file:Documentation/modules.txt>.  If unsure, say `N'.
 
+config IP_NF_TARGET_DIVERT
+	tristate "DIVERT target support"
+	depends on IP_NF_MANGLE
+	depends on TPROXY
+	help
+	  This options add a `DIVERT` target, which allows you to create rules       
+	  in the `mangle' table which statelessly divert packets to a local port
+
+	  If you want to compile it as a module, say M here and read
+	  <file:Documentation/modules.txt>.  If unsure, say `N'.
+
 config IP_NF_TARGET_LOG
 	tristate "LOG target support"
 	depends on IP_NF_IPTABLES
diff -urN --ignore-all-space linux-2.5.66-orig/net/ipv4/netfilter/Makefile linux-2.5.66-tproxy/net/ipv4/netfilter/Makefile
--- linux-2.5.66-orig/net/ipv4/netfilter/Makefile	Wed Apr  2 11:48:30 2003
+++ linux-2.5.66-tproxy/net/ipv4/netfilter/Makefile	Thu Apr  3 14:04:27 2003
@@ -76,6 +76,7 @@
 obj-$(CONFIG_IP_NF_TARGET_LOG) += ipt_LOG.o
 obj-$(CONFIG_IP_NF_TARGET_ULOG) += ipt_ULOG.o
 obj-$(CONFIG_IP_NF_TARGET_TCPMSS) += ipt_TCPMSS.o
+obj-$(CONFIG_IP_NF_TARGET_DIVERT) += ipt_DIVERT.o 
 
 # generic ARP tables
 obj-$(CONFIG_IP_NF_ARPTABLES) += arp_tables.o
diff -urN --ignore-all-space linux-2.5.66-orig/net/ipv4/netfilter/ipt_DIVERT.c linux-2.5.66-tproxy/net/ipv4/netfilter/ipt_DIVERT.c
--- linux-2.5.66-orig/net/ipv4/netfilter/ipt_DIVERT.c	Wed Dec 31 16:00:00 1969
+++ linux-2.5.66-tproxy/net/ipv4/netfilter/ipt_DIVERT.c	Thu Apr  3 14:04:27 2003
@@ -0,0 +1,83 @@
+/*
+ * This is a module which is used for diverting packets.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_DIVERT.h>
+#include <net/ip.h>
+
+static unsigned int divert(struct sk_buff **pskb,
+                           unsigned int hooknum,
+                           const struct net_device *in,
+                           const struct net_device *out,
+                           const void *targinfo,
+                           void *userinfo)
+{
+    const struct ipt_divert_target_info *divinfo = targinfo;
+    struct sk_buff* skb = *pskb;
+
+    IPCB(skb)->flags      |= IPSKB_DIVERTED;
+    IPCB(skb)->divert_port = divinfo->to_port;
+
+    if (skb->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
+        skb = ip_defrag(skb);
+        if (!skb)
+            return NF_DROP;
+    }
+
+    if (!skb->dev)
+        skb->dev = skb->dst->dev;
+
+    ip_local_deliver_finish(skb);
+
+    return NF_STOLEN;   
+}
+
+static int check(const char *tablename,
+                 const struct ipt_entry *e,
+                 void *targinfo,
+                 unsigned int targinfosize,
+                 unsigned int hook_mask)
+{
+
+    if (strcmp(tablename, "mangle") != 0) {
+        printk(KERN_WARNING "divert_check: divert can only be called from the \"mangle\" table (not \"%s\").\n",tablename);
+        return 0;
+    }
+    if (hook_mask & ~(1 << NF_IP_POST_ROUTING) &&
+        hook_mask & ~(1 << NF_IP_FORWARD)) {
+        printk(KERN_WARNING "divert_check: bad hooks %x.\n", hook_mask);
+        return 0;
+    }
+    if (targinfosize != IPT_ALIGN(sizeof(struct ipt_divert_target_info))) {
+        printk(KERN_WARNING "divert_check: bad target size.\n");
+        return 0;
+    }
+
+    return 1;
+}
+
+
+static struct ipt_target ipt_divert_reg
+= { { NULL, NULL }, "DIVERT", divert, check, NULL, THIS_MODULE };
+
+static int __init init(void)
+{
+    if (ipt_register_target(&ipt_divert_reg))
+    return -EINVAL;
+ return 0;
+}
+
+static void __exit fini(void)
+{
+    ipt_unregister_target(&ipt_divert_reg);
+}
+
+module_init(init);
+module_exit(fini);
+MODULE_LICENSE("GPL");
diff -urN --ignore-all-space linux-2.5.66-orig/net/ipv4/raw.c linux-2.5.66-tproxy/net/ipv4/raw.c
--- linux-2.5.66-orig/net/ipv4/raw.c	Wed Apr  2 11:48:30 2003
+++ linux-2.5.66-tproxy/net/ipv4/raw.c	Thu Apr  3 14:04:27 2003
@@ -409,6 +409,10 @@
 
 	saddr = ipc.addr;
 	ipc.addr = daddr;
+#ifdef CONFIG_TPROXY
+    ipc.pkt_ip_ttl = 0;
+    ipc.pkt_ip_tos = 0;
+#endif
 
 	if (!ipc.opt)
 		ipc.opt = inet->opt;
diff -urN --ignore-all-space linux-2.5.66-orig/net/ipv4/route.c linux-2.5.66-tproxy/net/ipv4/route.c
--- linux-2.5.66-orig/net/ipv4/route.c	Wed Apr  2 11:48:30 2003
+++ linux-2.5.66-tproxy/net/ipv4/route.c	Thu Apr  3 14:04:27 2003
@@ -1809,6 +1809,16 @@
 
 /*
  * Major route resolver routine.
+ *
+ * NOTE: about CONFIG_TPROXY. Here it concides to
+ * CONFIG_IP_TRANSPARENT_PROXY used in linux-2.2. However,
+ * [ Also, I constructed new song: "Yesterday, all my troubles..."
+ * Whaat?! Well, words are the same, music may be the same too. Why not?
+ * But its sense is absolutely different!
+ * ]
+ * jokes apart, it is _not_ used to steal connections, only
+ * connections opened by us are nonlocal, hence we have
+ * no problems with TCP port shifting etc.
  */
 
 int ip_route_output_slow(struct rtable **rp, const struct flowi *oldflp)
@@ -1850,8 +1860,19 @@
 
 		/* It is equivalent to inet_addr_type(saddr) == RTN_LOCAL */
 		dev_out = ip_dev_find(oldflp->fl4_src);
+#ifdef CONFIG_TPROXY
+        /* If address is not local, test for nonlocal flag;
+         * if address is local --- clear the flag.
+         */
+        if (dev_out == NULL) {
+            if (!(oldflp->fl4_tos & RTO_TPROXY) || inet_addr_type(oldflp->fl4_src) != RTN_UNICAST)
+                goto out;
+            flags |= RTCF_TPROXY;
+        }
+#else
 		if (dev_out == NULL)
 			goto out;
+#endif
 
 		/* I removed check for oif == dev_out->oif here.
 		   It was wrong for two reasons:
@@ -1862,6 +1883,7 @@
 		 */
 
 		if (oldflp->oif == 0
+           && dev_out
 		    && (MULTICAST(oldflp->fl4_dst) || oldflp->fl4_dst == 0xFFFFFFFF)) {
 			/* Special hack: user can direct multicasts
 			   and limited broadcast via necessary interface
diff -urN --ignore-all-space linux-2.5.66-orig/net/ipv4/tcp_ipv4.c linux-2.5.66-tproxy/net/ipv4/tcp_ipv4.c
--- linux-2.5.66-orig/net/ipv4/tcp_ipv4.c	Wed Apr  2 11:48:30 2003
+++ linux-2.5.66-tproxy/net/ipv4/tcp_ipv4.c	Thu Apr  3 14:04:27 2003
@@ -1872,6 +1872,44 @@
 	goto discard_it;
 }
 
+#ifdef CONFIG_TPROXY
+/* Could be done with netfilter hook. Not clear how to hook this in right place. */
+
+struct sk_buff *tcp_v4_nonlocal_deliver(struct sk_buff *skb)
+{
+    struct sock *sk;
+    struct tcphdr *th;
+    int ihl;
+
+    if (skb->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
+        skb = ip_defrag(skb);
+        if (!skb)
+            return NULL;
+    }
+
+    ihl = skb->nh.iph->ihl*4;
+
+    if (!pskb_may_pull(skb, ihl+8))
+        goto out;
+
+    th = (struct tcphdr*)(skb->nh.raw + ihl);
+
+    sk = __tcp_v4_lookup_established(skb->nh.iph->saddr, th->source,
+                                     skb->nh.iph->daddr, ntohs(th->dest),
+                                     0);
+
+    if (sk) {
+        skb->pkt_type = PACKET_HOST;
+        sock_put(sk);
+        ip_local_deliver(skb);
+        return NULL;
+    }
+
+ out:
+    return skb;
+}
+#endif
+
 /* With per-bucket locks this operation is not-atomic, so that
  * this version is not worse.
  */
diff -urN --ignore-all-space linux-2.5.66-orig/net/ipv4/udp.c linux-2.5.66-tproxy/net/ipv4/udp.c
--- linux-2.5.66-orig/net/ipv4/udp.c	Wed Apr  2 11:48:30 2003
+++ linux-2.5.66-tproxy/net/ipv4/udp.c	Thu Apr  3 14:05:51 2003
@@ -106,6 +106,26 @@
 #include <net/checksum.h>
 #include <net/xfrm.h>
 
+#ifdef CONFIG_TPROXY
+#define UDP_CMSG_RECVDPORT     32
+
+static void udp_cmsg_recv_dport(struct msghdr *msg, struct sk_buff *skb)
+{
+    put_cmsg(msg, SOL_UDP, UDP_RECVDPORT, sizeof(unsigned short), &skb->h.uh->dest);
+}
+
+void udp_cmsg_recv(struct msghdr *msg, struct sk_buff *skb)
+{
+	struct inet_opt *inet = inet_sk(skb->sk);
+	unsigned flags = inet->cmsg_flags;
+    
+    if (flags & UDP_CMSG_RECVDPORT)
+        udp_cmsg_recv_dport(msg, skb);
+
+    ip_cmsg_recv(msg, skb);
+}
+#endif
+
 /*
  *	Snmp MIB for the UDP layer
  */
@@ -222,6 +242,34 @@
 	write_unlock_bh(&udp_hash_lock);
 }
 
+#ifdef CONFIG_TPROXY
+static int udp_cmsg_send(struct msghdr *msg, struct ipcm_cookie *ipc)
+{
+    struct cmsghdr *cmsg;
+ 
+    for (cmsg = CMSG_FIRSTHDR(msg); cmsg;
+         cmsg = CMSG_NXTHDR(msg, cmsg)) {
+ 
+        if (cmsg->cmsg_level == SOL_UDP) {
+            switch (cmsg->cmsg_type) {
+ 
+            case UDP_SPORT:
+                if (cmsg->cmsg_len != CMSG_LEN(sizeof(u_short)))
+                    return -EINVAL;
+                ipc->pkt_udp_sport = *(u_short*)CMSG_DATA(cmsg);
+                break;
+                 
+            default:
+                printk("Unknown cmsg_type: %i\n",cmsg->cmsg_type);
+                return -EINVAL;
+            }
+        }
+    }
+ 
+    return ip_cmsg_send(msg,ipc);
+}
+#endif 
+
 /* UDP is nearly always wildcards out the wazoo, it makes no sense to try
  * harder than this. -DaveM
  */
@@ -484,7 +532,7 @@
 	int free = 0;
 	int connected = 0;
 	u32 daddr, faddr, saddr;
-	u16 dport;
+	u16 dport, sport;
 	u8  tos;
 	int err;
 	int corkreq = up->corkflag || msg->msg_flags&MSG_MORE;
@@ -552,9 +600,19 @@
   	}
 	ipc.addr = inet->saddr;
 
+#ifdef CONFIG_TPROXY
+    ipc.pkt_ip_ttl    = 0;
+    ipc.pkt_ip_tos    = 0;
+    ipc.pkt_udp_sport = 0;
+#endif
+
 	ipc.oif = sk->bound_dev_if;
 	if (msg->msg_controllen) {
+#ifdef CONFIG_TPROXY
+        err = udp_cmsg_send(msg, &ipc);
+#else
 		err = ip_cmsg_send(msg, &ipc);
+#endif
 		if (err)
 			return err;
 		if (ipc.opt)
@@ -564,6 +622,11 @@
 	if (!ipc.opt)
 		ipc.opt = inet->opt;
 
+    sport = inet->sport;
+#ifdef CONFIG_TPROXY
+    if (ipc.pkt_udp_sport)
+        sport = ipc.pkt_udp_sport;
+#endif
 	saddr = ipc.addr;
 	ipc.addr = faddr = daddr;
 
@@ -574,6 +637,10 @@
 		connected = 0;
 	}
 	tos = RT_TOS(inet->tos);
+#ifdef CONFIG_TPROXY
+    if (ipc.pkt_udp_sport || ipc.addr)
+        tos |= RTO_TPROXY;
+#endif
 	if (sk->localroute || (msg->msg_flags&MSG_DONTROUTE) || 
 	    (ipc.opt && ipc.opt->is_strictroute)) {
 		tos |= RTO_ONLINK;
@@ -599,7 +666,7 @@
 						.tos = tos } },
 				    .proto = IPPROTO_UDP,
 				    .uli_u = { .ports =
-					       { .sport = inet->sport,
+					       { .sport = sport,
 						 .dport = dport } } };
 		err = ip_route_output_flow(&rt, &fl, sk, !(msg->msg_flags&MSG_DONTWAIT));
 		if (err)
@@ -637,7 +704,7 @@
 	up->daddr = daddr;
 	up->dport = dport;
 	up->saddr = saddr;
-	up->sport = inet->sport;
+    up->sport = sport;
 	up->pending = 1;
 
 do_append_data:
@@ -827,7 +894,11 @@
 		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
   	}
 	if (inet->cmsg_flags)
+#ifdef CONFIG_TPROXY
+	udp_cmsg_recv(msg, skb);
+#else
 		ip_cmsg_recv(msg, skb);
+#endif
 	err = copied;
   
 out_free:
@@ -1069,7 +1140,14 @@
 	if(rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST))
 		return udp_v4_mcast_deliver(skb, uh, saddr, daddr);
 
+#ifdef CONFIG_TPROXY
+    if(IPCB(skb)->flags & IPSKB_DIVERTED) 
+        sk = udp_v4_lookup(saddr, uh->source, daddr, IPCB(skb)->divert_port, skb->dev->ifindex);
+	else
 	sk = udp_v4_lookup(saddr, uh->source, daddr, uh->dest, skb->dev->ifindex);
+#else
+	sk = udp_v4_lookup(saddr, uh->source, daddr, uh->dest, skb->dev->ifindex);
+#endif
 
 	if (sk != NULL) {
 		udp_queue_rcv_skb(sk, skb);
@@ -1164,6 +1242,14 @@
 			release_sock(sk);
 		}
 		break;
+#ifdef CONFIG_TPROXY
+    case UDP_RECVDPORT: 
+        if (val)
+            inet_sk(sk)->cmsg_flags |= UDP_CMSG_RECVDPORT;
+        else
+            inet_sk(sk)->cmsg_flags &= ~UDP_CMSG_RECVDPORT;
+        break;
+#endif
 		
 	default:
 		err = -ENOPROTOOPT;
@@ -1194,6 +1280,11 @@
 	case UDP_CORK:
 		val = up->corkflag;
 		break;
+#ifdef CONFIG_TPROXY
+    case UDP_RECVDPORT:
+        val = ((inet_sk(sk)->cmsg_flags & UDP_CMSG_RECVDPORT) != 0);
+        break;
+#endif
 
 	default:
 		return -ENOPROTOOPT;
diff -urN --ignore-all-space linux-2.5.66-orig/net/netsyms.c linux-2.5.66-tproxy/net/netsyms.c
--- linux-2.5.66-orig/net/netsyms.c	Wed Apr  2 11:48:32 2003
+++ linux-2.5.66-tproxy/net/netsyms.c	Thu Apr  3 14:04:27 2003
@@ -277,6 +277,7 @@
 EXPORT_SYMBOL(inetdev_by_index);
 EXPORT_SYMBOL(in_dev_finish_destroy);
 EXPORT_SYMBOL(ip_defrag);
+EXPORT_SYMBOL(ip_local_deliver_finish);
 
 /* Route manipulation */
 EXPORT_SYMBOL(ip_rt_ioctl);
