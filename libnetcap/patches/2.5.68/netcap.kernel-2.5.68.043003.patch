diff -urN --ignore-all-space linux-2.5.68-orig/include/linux/in.h linux-2.5.68-netcap/include/linux/in.h
--- linux-2.5.68-orig/include/linux/in.h	Sat Apr 19 19:51:21 2003
+++ linux-2.5.68-netcap/include/linux/in.h	Wed Apr 30 02:54:32 2003
@@ -71,6 +71,8 @@
 #define IP_FREEBIND	15
 #define IP_IPSEC_POLICY	16
 #define IP_XFRM_POLICY	17
+#define IP_NONLOCAL	18
+#define IP_SADDR     20
 
 /* BSD compatibility */
 #define IP_RECVRETOPTS	IP_RETOPTS
diff -urN --ignore-all-space linux-2.5.68-orig/include/linux/netfilter_ipv4/ipt_DIVERT.h linux-2.5.68-netcap/include/linux/netfilter_ipv4/ipt_DIVERT.h
--- linux-2.5.68-orig/include/linux/netfilter_ipv4/ipt_DIVERT.h	Wed Dec 31 16:00:00 1969
+++ linux-2.5.68-netcap/include/linux/netfilter_ipv4/ipt_DIVERT.h	Wed Apr 30 02:54:32 2003
@@ -0,0 +1,9 @@
+/* $Id: netcap.kernel-2.5.68.043003.patch,v 1.1 2004/11/09 19:39:58 dmorris Exp $ */
+#ifndef _IPT_DIVERT_H_target
+#define _IPT_DIVERT_H_target
+
+struct ipt_divert_target_info {
+	unsigned short to_port;
+};
+
+#endif
diff -urN --ignore-all-space linux-2.5.68-orig/include/linux/netfilter_ipv4.h linux-2.5.68-netcap/include/linux/netfilter_ipv4.h
--- linux-2.5.68-orig/include/linux/netfilter_ipv4.h	Sat Apr 19 19:50:43 2003
+++ linux-2.5.68-netcap/include/linux/netfilter_ipv4.h	Wed Apr 30 02:54:32 2003
@@ -51,6 +51,7 @@
 
 enum nf_ip_hook_priorities {
 	NF_IP_PRI_FIRST = INT_MIN,
+	NF_IP_PRI_PRE_CONNTRACK = -225,
 	NF_IP_PRI_CONNTRACK = -200,
 	NF_IP_PRI_BRIDGE_SABOTAGE_FORWARD = -175,
 	NF_IP_PRI_MANGLE = -150,
diff -urN --ignore-all-space linux-2.5.68-orig/include/linux/udp.h linux-2.5.68-netcap/include/linux/udp.h
--- linux-2.5.68-orig/include/linux/udp.h	Sat Apr 19 19:48:55 2003
+++ linux-2.5.68-netcap/include/linux/udp.h	Wed Apr 30 02:54:32 2003
@@ -31,7 +31,11 @@
 
 /* UDP socket options */
 #define UDP_CORK	1	/* Never send partially complete segments */
+#define UDP_RECVDPORT 2 /* the dest port in ancillary msg */
 #define UDP_ENCAP	100	/* Set the socket to accept encapsulated packets */
+
+/* UDP ancillary data types */
+#define UDP_SPORT 1
 
 /* UDP encapsulation types */
 #define UDP_ENCAP_ESPINUDP	2 /* draft-ietf-ipsec-udp-encaps-06 */
diff -urN --ignore-all-space linux-2.5.68-orig/include/net/ip.h linux-2.5.68-netcap/include/net/ip.h
--- linux-2.5.68-orig/include/net/ip.h	Sat Apr 19 19:50:08 2003
+++ linux-2.5.68-netcap/include/net/ip.h	Wed Apr 30 02:54:32 2003
@@ -43,10 +43,16 @@
 {
 	struct ip_options	opt;		/* Compiled IP options		*/
 	unsigned char		flags;
-
+#ifdef CONFIG_NETCAP
+    unsigned char    pkt_ip_ttl;
+    unsigned char    pkt_ip_tos;
+    unsigned short   divert_port;
+#endif
 #define IPSKB_MASQUERADED	1
 #define IPSKB_TRANSLATED	2
 #define IPSKB_FORWARDED		4
+#define IPSKB_DIVERTED		8
+
 };
 
 struct ipcm_cookie
@@ -54,6 +60,11 @@
 	u32			addr;
 	int			oif;
 	struct ip_options	*opt;
+#ifdef CONFIG_NETCAP
+    u8 pkt_ip_ttl;
+    u8 pkt_ip_tos;
+    u16 pkt_udp_sport;
+#endif
 };
 
 #define IPCB(skb) ((struct inet_skb_parm*)((skb)->cb))
@@ -91,6 +102,7 @@
 extern int		ip_rcv(struct sk_buff *skb, struct net_device *dev,
 			       struct packet_type *pt);
 extern int		ip_local_deliver(struct sk_buff *skb);
+extern int       ip_local_deliver_finish(struct sk_buff *skb);
 extern int		ip_mr_input(struct sk_buff *skb);
 extern int		ip_output(struct sk_buff *skb);
 extern int		ip_mc_output(struct sk_buff *skb);
diff -urN --ignore-all-space linux-2.5.68-orig/include/net/route.h linux-2.5.68-netcap/include/net/route.h
--- linux-2.5.68-orig/include/net/route.h	Sat Apr 19 19:48:46 2003
+++ linux-2.5.68-netcap/include/net/route.h	Wed Apr 30 02:54:32 2003
@@ -39,12 +39,19 @@
 #endif
 
 #define RTO_ONLINK	0x01
+#define RTO_TPROXY   0x02	
 
 #define RTO_CONN	0
 /* RTO_CONN is not used (being alias for 0), but preserved not to break
  * some modules referring to it. */
 
-#define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sk->localroute)
+#ifdef CONFIG_NETCAP
+#define RTO_SCONN(sk) ((sk)->reuse > 1 ? RTO_TPROXY : 0)
+#else
+#define RTO_SCONN(sk) 0
+#endif
+
+#define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sk->localroute | RTO_SCONN(sk))
 
 struct inet_peer;
 struct rtable
diff -urN --ignore-all-space linux-2.5.68-orig/include/net/tcp.h linux-2.5.68-netcap/include/net/tcp.h
--- linux-2.5.68-orig/include/net/tcp.h	Sat Apr 19 19:48:51 2003
+++ linux-2.5.68-netcap/include/net/tcp.h	Wed Apr 30 02:54:32 2003
@@ -652,6 +652,10 @@
 
 extern int			tcp_v4_rcv(struct sk_buff *skb);
 
+#ifdef CONFIG_NETCAP
+extern struct sk_buff *tcp_v4_nonlocal_deliver(struct sk_buff *skb);
+#endif
+    
 extern int			tcp_v4_remember_stamp(struct sock *sk);
 
 extern int		    	tcp_v4_tw_remember_stamp(struct tcp_tw_bucket *tw);
diff -urN --ignore-all-space linux-2.5.68-orig/net/Kconfig linux-2.5.68-netcap/net/Kconfig
--- linux-2.5.68-orig/net/Kconfig	Sat Apr 19 19:48:50 2003
+++ linux-2.5.68-netcap/net/Kconfig	Wed Apr 30 02:54:32 2003
@@ -118,6 +118,15 @@
 	  You can say Y here if you want to get additional messages useful in
 	  debugging the netfilter code.
 
+config NETCAP
+	bool "Transparent Proxy extensions (netcap)"
+	---help---
+      Transparent Proxy extensions to the networking stack
+      this includes non-local connection support, and some udp sendmsg
+      ancillary data extensions
+
+	  Unless you really know what you are doing, you should say N here.
+
 config UNIX
 	tristate "Unix domain sockets"
 	---help---
diff -urN --ignore-all-space linux-2.5.68-orig/net/ipv4/af_inet.c linux-2.5.68-netcap/net/ipv4/af_inet.c
--- linux-2.5.68-orig/net/ipv4/af_inet.c	Sat Apr 19 19:48:51 2003
+++ linux-2.5.68-netcap/net/ipv4/af_inet.c	Wed Apr 30 06:20:15 2003
@@ -504,8 +504,8 @@
 
 	snum = ntohs(addr->sin_port);
 	err = -EACCES;
-	if (snum && snum < PROT_SOCK && !capable(CAP_NET_BIND_SERVICE))
-		goto out;
+	/* if (snum && snum < PROT_SOCK && !capable(CAP_NET_BIND_SERVICE)) */
+	/*	goto out; */
 
 	/*      We keep a pair of addresses. rcv_saddr is the one
 	 *      used by hash lookups, and saddr is used for transmit.
diff -urN --ignore-all-space linux-2.5.68-orig/net/ipv4/ip_input.c linux-2.5.68-netcap/net/ipv4/ip_input.c
--- linux-2.5.68-orig/net/ipv4/ip_input.c	Sat Apr 19 19:48:50 2003
+++ linux-2.5.68-netcap/net/ipv4/ip_input.c	Wed Apr 30 02:54:32 2003
@@ -195,7 +195,7 @@
 	return 0;
 }
 
-static inline int ip_local_deliver_finish(struct sk_buff *skb)
+inline int ip_local_deliver_finish(struct sk_buff *skb)
 {
 	int ihl = skb->nh.iph->ihl*4;
 
diff -urN --ignore-all-space linux-2.5.68-orig/net/ipv4/ip_output.c linux-2.5.68-netcap/net/ipv4/ip_output.c
--- linux-2.5.68-orig/net/ipv4/ip_output.c	Sat Apr 19 19:51:13 2003
+++ linux-2.5.68-netcap/net/ipv4/ip_output.c	Wed Apr 30 02:54:32 2003
@@ -868,6 +868,17 @@
 			data += fragheaderlen;
 			skb->h.raw = data + exthdrlen;
 
+#ifdef CONFIG_NETCAP
+            if (ipc->pkt_ip_ttl)
+                IPCB(skb)->pkt_ip_ttl = ipc->pkt_ip_ttl;
+            else 
+                IPCB(skb)->pkt_ip_ttl = 0;
+            if (ipc->pkt_ip_tos)
+                IPCB(skb)->pkt_ip_tos = ipc->pkt_ip_tos;
+            else 
+                IPCB(skb)->pkt_ip_tos = 0;
+#endif
+            
 			copy = datalen - transhdrlen;
 			if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, 0, skb) < 0) {
 				err = -EFAULT;
@@ -1140,6 +1151,10 @@
 		ip_options_build(skb, opt, inet->cork.addr, rt, 0);
 	}
 	iph->tos = inet->tos;
+#ifdef CONFIG_NETCAP
+    if (IPCB(skb)->pkt_ip_tos && sk->protocol == IPPROTO_UDP)
+        iph->tos = IPCB(skb)->pkt_ip_tos;
+#endif
 	iph->tot_len = htons(skb->len);
 	iph->frag_off = df;
 	if (!df) {
@@ -1148,6 +1163,10 @@
 		iph->id = htons(inet->id++);
 	}
 	iph->ttl = ttl;
+#ifdef CONFIG_NETCAP
+    if (IPCB(skb)->pkt_ip_ttl && sk->protocol == IPPROTO_UDP)
+        iph->ttl = IPCB(skb)->pkt_ip_ttl;
+#endif
 	iph->protocol = sk->protocol;
 	iph->saddr = rt->rt_src;
 	iph->daddr = rt->rt_dst;
diff -urN --ignore-all-space linux-2.5.68-orig/net/ipv4/ip_sockglue.c linux-2.5.68-netcap/net/ipv4/ip_sockglue.c
--- linux-2.5.68-orig/net/ipv4/ip_sockglue.c	Sat Apr 19 19:48:57 2003
+++ linux-2.5.68-netcap/net/ipv4/ip_sockglue.c	Wed Apr 30 06:20:57 2003
@@ -169,7 +169,33 @@
 			ipc->addr = info->ipi_spec_dst.s_addr;
 			break;
 		}
+#ifdef CONFIG_NETCAP
+        case IP_SADDR:
+        {
+            struct in_addr *in;
+            if (cmsg->cmsg_len != CMSG_LEN(sizeof(struct in_addr))) 
+                return -EINVAL;
+            in = (struct in_addr *)CMSG_DATA(cmsg);
+            ipc->addr = in->s_addr;
+            break;
+        }
+        case IP_TTL:
+        {
+            if (cmsg->cmsg_len != CMSG_LEN(sizeof(unsigned char))) 
+                return -EINVAL;
+            ipc->pkt_ip_ttl = *(u_char *)CMSG_DATA(cmsg);
+            break;
+        }
+        case IP_TOS:
+        {
+            if (cmsg->cmsg_len != CMSG_LEN(sizeof(unsigned char))) 
+                return -EINVAL;
+            ipc->pkt_ip_tos = *(u_char *)CMSG_DATA(cmsg);
+            break;
+        }
+#endif
 		default:
+            printk("Unknown cmsg_type: %i\n",cmsg->cmsg_type);
 			return -EINVAL;
 		}
 	}
@@ -397,7 +423,7 @@
 			    (1<<IP_RETOPTS) | (1<<IP_TOS) | 
 			    (1<<IP_TTL) | (1<<IP_HDRINCL) | 
 			    (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) | 
-			    (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND))) || 
+			    (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) | (1<<IP_NONLOCAL))) || 
 				optname == IP_MULTICAST_TTL || 
 				optname == IP_MULTICAST_LOOP) { 
 		if (optlen >= sizeof(int)) {
@@ -524,6 +550,16 @@
 			if (!val)
 				skb_queue_purge(&sk->error_queue);
 			break;
+       case IP_NONLOCAL:
+           if (optlen<1)
+               goto e_inval;
+           /* if (!capable(CAP_NET_ADMIN)) */
+           /*    goto e_inval;             */
+           if (val)
+               sk->reuse = 2;
+           else if (sk->reuse == 2)
+               sk->reuse = 1;
+           break;
 		case IP_MULTICAST_TTL:
 			if (sk->type == SOCK_STREAM)
 				goto e_inval;
diff -urN --ignore-all-space linux-2.5.68-orig/net/ipv4/netfilter/Kconfig linux-2.5.68-netcap/net/ipv4/netfilter/Kconfig
--- linux-2.5.68-orig/net/ipv4/netfilter/Kconfig	Sat Apr 19 19:50:40 2003
+++ linux-2.5.68-netcap/net/ipv4/netfilter/Kconfig	Wed Apr 30 02:54:32 2003
@@ -5,6 +5,15 @@
 menu "IP: Netfilter Configuration"
 	depends on INET && NETFILTER
 
+config IP_NF_NONLOCAL
+	tristate "Nonlocal Connection Support"
+	depends on NETCAP
+	---help---
+      Nonlocal connection support
+
+	  If you want to compile it as a module, say M here and read
+	  <file:Documentation/modules.txt>.  If unsure, say `N'.
+
 config IP_NF_CONNTRACK
 	tristate "Connection tracking (required for masq/NAT)"
 	---help---
@@ -477,6 +486,17 @@
 	  the routing method (see `Use netfilter MARK value as routing
 	  key') and can also be used by other subsystems to change their
 	  behavior.
+
+	  If you want to compile it as a module, say M here and read
+	  <file:Documentation/modules.txt>.  If unsure, say `N'.
+
+config IP_NF_TARGET_DIVERT
+	tristate "DIVERT target support"
+	depends on IP_NF_MANGLE
+	depends on NETCAP
+	help
+	  This options add a `DIVERT` target, which allows you to create rules       
+	  in the `mangle' table which statelessly divert packets to a local port
 
 	  If you want to compile it as a module, say M here and read
 	  <file:Documentation/modules.txt>.  If unsure, say `N'.
diff -urN --ignore-all-space linux-2.5.68-orig/net/ipv4/netfilter/Makefile linux-2.5.68-netcap/net/ipv4/netfilter/Makefile
--- linux-2.5.68-orig/net/ipv4/netfilter/Makefile	Sat Apr 19 19:48:55 2003
+++ linux-2.5.68-netcap/net/ipv4/netfilter/Makefile	Wed Apr 30 02:54:32 2003
@@ -19,6 +19,9 @@
 # connection tracking
 obj-$(CONFIG_IP_NF_CONNTRACK) += ip_conntrack.o
 
+# non-local support
+obj-$(CONFIG_IP_NF_NONLOCAL) += ip_nonlocal.o
+
 # connection tracking helpers
 obj-$(CONFIG_IP_NF_AMANDA) += ip_conntrack_amanda.o
 obj-$(CONFIG_IP_NF_TFTP) += ip_conntrack_tftp.o
@@ -76,6 +79,7 @@
 obj-$(CONFIG_IP_NF_TARGET_LOG) += ipt_LOG.o
 obj-$(CONFIG_IP_NF_TARGET_ULOG) += ipt_ULOG.o
 obj-$(CONFIG_IP_NF_TARGET_TCPMSS) += ipt_TCPMSS.o
+obj-$(CONFIG_IP_NF_TARGET_DIVERT) += ipt_DIVERT.o 
 
 # generic ARP tables
 obj-$(CONFIG_IP_NF_ARPTABLES) += arp_tables.o
diff -urN --ignore-all-space linux-2.5.68-orig/net/ipv4/netfilter/ip_nonlocal.c linux-2.5.68-netcap/net/ipv4/netfilter/ip_nonlocal.c
--- linux-2.5.68-orig/net/ipv4/netfilter/ip_nonlocal.c	Wed Dec 31 16:00:00 1969
+++ linux-2.5.68-netcap/net/ipv4/netfilter/ip_nonlocal.c	Wed Apr 30 02:54:32 2003
@@ -0,0 +1,72 @@
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/ip.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+#include <linux/brlock.h>
+#include <net/tcp.h>
+#include <net/checksum.h>
+
+MODULE_LICENSE("GPL");
+
+/* Netfilter hook itself. */
+static unsigned int ip_nonlocal_in(unsigned int hooknum,
+                                    struct sk_buff **pskb,
+                                    const struct net_device *in,
+                                    const struct net_device *out,
+                                    int (*okfn)(struct sk_buff *))
+{
+    struct sk_buff* skb = *pskb;
+    if (skb->nh.iph->protocol == IPPROTO_TCP) {           
+        if ((skb = tcp_v4_nonlocal_deliver(skb)) == NULL) 
+            return NF_STOLEN;                        
+    }                                                     
+
+    return NF_ACCEPT;
+}
+
+static struct nf_hook_ops ip_nonlocal_forward_ops = {
+	.hook		= ip_nonlocal_in,
+	.pf		= PF_INET,
+	.hooknum	= NF_IP_PRE_ROUTING,
+	.priority	= NF_IP_PRI_FIRST+1,
+};
+
+static int init_or_cleanup(int init)
+{
+	int ret = 0;
+
+	if (!init) 
+        goto cleanup;
+
+	ret = nf_register_hook(&ip_nonlocal_forward_ops);
+	if (ret < 0) {
+		printk("ip_nonlocal: can't register pre-routing hook.\n");
+		goto cleanup;
+	}
+
+	return ret;
+
+ cleanup:
+	nf_unregister_hook(&ip_nonlocal_forward_ops);
+	return ret;
+}
+
+static int __init init(void)
+{
+	return init_or_cleanup(1);
+}
+
+static void __exit fini(void)
+{
+	init_or_cleanup(0);
+}
+
+module_init(init);
+module_exit(fini);
+
+
diff -urN --ignore-all-space linux-2.5.68-orig/net/ipv4/netfilter/ipt_DIVERT.c linux-2.5.68-netcap/net/ipv4/netfilter/ipt_DIVERT.c
--- linux-2.5.68-orig/net/ipv4/netfilter/ipt_DIVERT.c	Wed Dec 31 16:00:00 1969
+++ linux-2.5.68-netcap/net/ipv4/netfilter/ipt_DIVERT.c	Wed Apr 30 02:54:32 2003
@@ -0,0 +1,83 @@
+/*
+ * This is a module which is used for diverting packets.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_DIVERT.h>
+#include <net/ip.h>
+
+static unsigned int divert(struct sk_buff **pskb,
+                           unsigned int hooknum,
+                           const struct net_device *in,
+                           const struct net_device *out,
+                           const void *targinfo,
+                           void *userinfo)
+{
+    const struct ipt_divert_target_info *divinfo = targinfo;
+    struct sk_buff* skb = *pskb;
+
+    IPCB(skb)->flags      |= IPSKB_DIVERTED;
+    IPCB(skb)->divert_port = divinfo->to_port;
+
+    if (skb->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
+        skb = ip_defrag(skb);
+        if (!skb)
+            return NF_DROP;
+    }
+
+    if (!skb->dev)
+        skb->dev = skb->dst->dev;
+
+    ip_local_deliver_finish(skb);
+
+    return NF_STOLEN;   
+}
+
+static int check(const char *tablename,
+                 const struct ipt_entry *e,
+                 void *targinfo,
+                 unsigned int targinfosize,
+                 unsigned int hook_mask)
+{
+
+    if (strcmp(tablename, "mangle") != 0) {
+        printk(KERN_WARNING "divert_check: divert can only be called from the \"mangle\" table (not \"%s\").\n",tablename);
+        return 0;
+    }
+    if (hook_mask & ~(1 << NF_IP_POST_ROUTING) &&
+        hook_mask & ~(1 << NF_IP_FORWARD)) {
+        printk(KERN_WARNING "divert_check: bad hooks %x.\n", hook_mask);
+        return 0;
+    }
+    if (targinfosize != IPT_ALIGN(sizeof(struct ipt_divert_target_info))) {
+        printk(KERN_WARNING "divert_check: bad target size.\n");
+        return 0;
+    }
+
+    return 1;
+}
+
+
+static struct ipt_target ipt_divert_reg
+= { { NULL, NULL }, "DIVERT", divert, check, NULL, THIS_MODULE };
+
+static int __init init(void)
+{
+    if (ipt_register_target(&ipt_divert_reg))
+    return -EINVAL;
+ return 0;
+}
+
+static void __exit fini(void)
+{
+    ipt_unregister_target(&ipt_divert_reg);
+}
+
+module_init(init);
+module_exit(fini);
+MODULE_LICENSE("GPL");
diff -urN --ignore-all-space linux-2.5.68-orig/net/ipv4/raw.c linux-2.5.68-netcap/net/ipv4/raw.c
--- linux-2.5.68-orig/net/ipv4/raw.c	Sat Apr 19 19:49:56 2003
+++ linux-2.5.68-netcap/net/ipv4/raw.c	Wed Apr 30 02:54:32 2003
@@ -409,6 +409,10 @@
 
 	saddr = ipc.addr;
 	ipc.addr = daddr;
+#ifdef CONFIG_NETCAP
+    ipc.pkt_ip_ttl = 0;
+    ipc.pkt_ip_tos = 0;
+#endif
 
 	if (!ipc.opt)
 		ipc.opt = inet->opt;
diff -urN --ignore-all-space linux-2.5.68-orig/net/ipv4/route.c linux-2.5.68-netcap/net/ipv4/route.c
--- linux-2.5.68-orig/net/ipv4/route.c	Sat Apr 19 19:51:14 2003
+++ linux-2.5.68-netcap/net/ipv4/route.c	Wed Apr 30 02:54:32 2003
@@ -1851,8 +1851,19 @@
 
 		/* It is equivalent to inet_addr_type(saddr) == RTN_LOCAL */
 		dev_out = ip_dev_find(oldflp->fl4_src);
+#ifdef CONFIG_NETCAP
+        /* If address is not local, test for nonlocal flag;
+         * if address is local --- clear the flag.
+         */
+        if (dev_out == NULL) {
+            if (!(oldflp->fl4_tos & RTO_TPROXY) || inet_addr_type(oldflp->fl4_src) != RTN_UNICAST)
+                goto out;
+            flags |= RTCF_TPROXY;
+        }
+#else
 		if (dev_out == NULL)
 			goto out;
+#endif
 
 		/* I removed check for oif == dev_out->oif here.
 		   It was wrong for two reasons:
@@ -1863,6 +1874,7 @@
 		 */
 
 		if (oldflp->oif == 0
+           && dev_out
 		    && (MULTICAST(oldflp->fl4_dst) || oldflp->fl4_dst == 0xFFFFFFFF)) {
 			/* Special hack: user can direct multicasts
 			   and limited broadcast via necessary interface
diff -urN --ignore-all-space linux-2.5.68-orig/net/ipv4/tcp_ipv4.c linux-2.5.68-netcap/net/ipv4/tcp_ipv4.c
--- linux-2.5.68-orig/net/ipv4/tcp_ipv4.c	Sat Apr 19 19:48:58 2003
+++ linux-2.5.68-netcap/net/ipv4/tcp_ipv4.c	Wed Apr 30 02:54:32 2003
@@ -1872,6 +1872,54 @@
 	goto discard_it;
 }
 
+#ifdef CONFIG_NETCAP
+/* Could be done with netfilter hook. Not clear how to hook this in right place. */
+
+struct sk_buff *tcp_v4_nonlocal_deliver(struct sk_buff *skb)
+{
+    struct sock *sk;
+    struct tcphdr *th;
+    int ihl;
+
+    if (skb->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
+        skb = ip_defrag(skb);
+        if (!skb)
+            return NULL;
+    }
+
+    ihl = skb->nh.iph->ihl*4;
+
+    if (!pskb_may_pull(skb, ihl+8))
+        goto out;
+
+    th = (struct tcphdr*)(skb->nh.raw + ihl);
+    
+    sk = __tcp_v4_lookup_established(skb->nh.iph->saddr, th->source,
+                                     skb->nh.iph->daddr, ntohs(th->dest),
+                                     skb->dev->ifindex); 
+
+    if (sk) {
+        struct iphdr  *iph;
+        iph = skb->nh.iph;
+
+        if (skb->dst == NULL) {
+            if (ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, skb->dev)) {
+                printk("ip_route_input failed\n");
+                goto out; 
+            }
+        }
+
+        skb->pkt_type = PACKET_HOST;
+        sock_put(sk);
+        ip_local_deliver(skb);
+        return NULL;
+    }
+
+ out:
+    return skb;
+}
+#endif
+
 /* With per-bucket locks this operation is not-atomic, so that
  * this version is not worse.
  */
diff -urN --ignore-all-space linux-2.5.68-orig/net/ipv4/udp.c linux-2.5.68-netcap/net/ipv4/udp.c
--- linux-2.5.68-orig/net/ipv4/udp.c	Sat Apr 19 19:48:53 2003
+++ linux-2.5.68-netcap/net/ipv4/udp.c	Wed Apr 30 02:54:32 2003
@@ -107,6 +107,26 @@
 #include <net/checksum.h>
 #include <net/xfrm.h>
 
+#ifdef CONFIG_NETCAP
+#define UDP_CMSG_RECVDPORT     32
+
+static void udp_cmsg_recv_dport(struct msghdr *msg, struct sk_buff *skb)
+{
+    put_cmsg(msg, SOL_UDP, UDP_RECVDPORT, sizeof(unsigned short), &skb->h.uh->dest);
+}
+
+void udp_cmsg_recv(struct msghdr *msg, struct sk_buff *skb)
+{
+	struct inet_opt *inet = inet_sk(skb->sk);
+	unsigned flags = inet->cmsg_flags;
+    
+    if (flags & UDP_CMSG_RECVDPORT)
+        udp_cmsg_recv_dport(msg, skb);
+
+    ip_cmsg_recv(msg, skb);
+}
+#endif
+
 /*
  *	Snmp MIB for the UDP layer
  */
@@ -223,6 +243,34 @@
 	write_unlock_bh(&udp_hash_lock);
 }
 
+#ifdef CONFIG_NETCAP
+static int udp_cmsg_send(struct msghdr *msg, struct ipcm_cookie *ipc)
+{
+    struct cmsghdr *cmsg;
+ 
+    for (cmsg = CMSG_FIRSTHDR(msg); cmsg;
+         cmsg = CMSG_NXTHDR(msg, cmsg)) {
+ 
+        if (cmsg->cmsg_level == SOL_UDP) {
+            switch (cmsg->cmsg_type) {
+ 
+            case UDP_SPORT:
+                if (cmsg->cmsg_len != CMSG_LEN(sizeof(u_short)))
+                    return -EINVAL;
+                ipc->pkt_udp_sport = *(u_short*)CMSG_DATA(cmsg);
+                break;
+                 
+            default:
+                printk("Unknown cmsg_type: %i\n",cmsg->cmsg_type);
+                return -EINVAL;
+            }
+        }
+    }
+ 
+    return ip_cmsg_send(msg,ipc);
+}
+#endif 
+
 /* UDP is nearly always wildcards out the wazoo, it makes no sense to try
  * harder than this. -DaveM
  */
@@ -487,7 +535,7 @@
 	int free = 0;
 	int connected = 0;
 	u32 daddr, faddr, saddr;
-	u16 dport;
+	u16 dport, sport;
 	u8  tos;
 	int err;
 	int corkreq = up->corkflag || msg->msg_flags&MSG_MORE;
@@ -555,9 +603,19 @@
   	}
 	ipc.addr = inet->saddr;
 
+#ifdef CONFIG_NETCAP
+    ipc.pkt_ip_ttl    = 0;
+    ipc.pkt_ip_tos    = 0;
+    ipc.pkt_udp_sport = 0;
+#endif
+
 	ipc.oif = sk->bound_dev_if;
 	if (msg->msg_controllen) {
+#ifdef CONFIG_NETCAP
+        err = udp_cmsg_send(msg, &ipc);
+#else
 		err = ip_cmsg_send(msg, &ipc);
+#endif
 		if (err)
 			return err;
 		if (ipc.opt)
@@ -567,6 +625,11 @@
 	if (!ipc.opt)
 		ipc.opt = inet->opt;
 
+    sport = inet->sport;
+#ifdef CONFIG_NETCAP
+    if (ipc.pkt_udp_sport)
+        sport = ipc.pkt_udp_sport;
+#endif
 	saddr = ipc.addr;
 	ipc.addr = faddr = daddr;
 
@@ -577,6 +640,10 @@
 		connected = 0;
 	}
 	tos = RT_TOS(inet->tos);
+#ifdef CONFIG_NETCAP
+    if (ipc.pkt_udp_sport || ipc.addr)
+        tos |= RTO_TPROXY;
+#endif
 	if (sk->localroute || (msg->msg_flags&MSG_DONTROUTE) || 
 	    (ipc.opt && ipc.opt->is_strictroute)) {
 		tos |= RTO_ONLINK;
@@ -602,7 +669,7 @@
 						.tos = tos } },
 				    .proto = IPPROTO_UDP,
 				    .uli_u = { .ports =
-					       { .sport = inet->sport,
+					       { .sport = sport,
 						 .dport = dport } } };
 		err = ip_route_output_flow(&rt, &fl, sk, !(msg->msg_flags&MSG_DONTWAIT));
 		if (err)
@@ -640,7 +707,7 @@
 	up->daddr = daddr;
 	up->dport = dport;
 	up->saddr = saddr;
-	up->sport = inet->sport;
+    up->sport = sport;
 	up->pending = 1;
 
 do_append_data:
@@ -830,7 +897,11 @@
 		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
   	}
 	if (inet->cmsg_flags)
+#ifdef CONFIG_NETCAP
+	udp_cmsg_recv(msg, skb);
+#else
 		ip_cmsg_recv(msg, skb);
+#endif
 	err = copied;
   
 out_free:
@@ -1184,7 +1255,14 @@
 	if(rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST))
 		return udp_v4_mcast_deliver(skb, uh, saddr, daddr);
 
+#ifdef CONFIG_NETCAP
+    if(IPCB(skb)->flags & IPSKB_DIVERTED) 
+        sk = udp_v4_lookup(saddr, uh->source, daddr, IPCB(skb)->divert_port, skb->dev->ifindex);
+	else
 	sk = udp_v4_lookup(saddr, uh->source, daddr, uh->dest, skb->dev->ifindex);
+#else
+	sk = udp_v4_lookup(saddr, uh->source, daddr, uh->dest, skb->dev->ifindex);
+#endif
 
 	if (sk != NULL) {
 		int ret = udp_queue_rcv_skb(sk, skb);
@@ -1285,6 +1363,14 @@
 			release_sock(sk);
 		}
 		break;
+#ifdef CONFIG_NETCAP
+    case UDP_RECVDPORT: 
+        if (val)
+            inet_sk(sk)->cmsg_flags |= UDP_CMSG_RECVDPORT;
+        else
+            inet_sk(sk)->cmsg_flags &= ~UDP_CMSG_RECVDPORT;
+        break;
+#endif
 		
 	case UDP_ENCAP:
 		up->encap_type = val;
@@ -1319,6 +1405,11 @@
 	case UDP_CORK:
 		val = up->corkflag;
 		break;
+#ifdef CONFIG_NETCAP
+    case UDP_RECVDPORT:
+        val = ((inet_sk(sk)->cmsg_flags & UDP_CMSG_RECVDPORT) != 0);
+        break;
+#endif
 
 	case UDP_ENCAP:
 		val = up->encap_type;
diff -urN --ignore-all-space linux-2.5.68-orig/net/netsyms.c linux-2.5.68-netcap/net/netsyms.c
--- linux-2.5.68-orig/net/netsyms.c	Sat Apr 19 19:49:12 2003
+++ linux-2.5.68-netcap/net/netsyms.c	Wed Apr 30 02:54:32 2003
@@ -275,6 +275,7 @@
 EXPORT_SYMBOL(inetdev_by_index);
 EXPORT_SYMBOL(in_dev_finish_destroy);
 EXPORT_SYMBOL(ip_defrag);
+EXPORT_SYMBOL(ip_local_deliver_finish);
 
 /* Route manipulation */
 EXPORT_SYMBOL(ip_rt_ioctl);
