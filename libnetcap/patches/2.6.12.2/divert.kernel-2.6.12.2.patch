diff -urN --ignore-all-space linux-2.6.12.2-orig/include/linux/netfilter_ipv4/ipt_DIVERT.h linux-2.6.12.2-divert/include/linux/netfilter_ipv4/ipt_DIVERT.h
--- linux-2.6.12.2-orig/include/linux/netfilter_ipv4/ipt_DIVERT.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.12.2-divert/include/linux/netfilter_ipv4/ipt_DIVERT.h	2005-07-05 17:02:14.566802385 -0700
@@ -0,0 +1,9 @@
+/* $Id: ipt_DIVERT.h,v 1.1 2005/03/23 03:47:01 dmorris Exp $ */
+#ifndef _IPT_DIVERT_H_target
+#define _IPT_DIVERT_H_target
+
+struct ipt_divert_target_info {
+	unsigned short to_port;
+};
+
+#endif
diff -urN --ignore-all-space linux-2.6.12.2-orig/include/net/ip.h linux-2.6.12.2-divert/include/net/ip.h
--- linux-2.6.12.2-orig/include/net/ip.h	2005-06-29 16:00:53.000000000 -0700
+++ linux-2.6.12.2-divert/include/net/ip.h	2005-07-05 17:12:00.754164788 -0700
@@ -41,10 +41,14 @@
 	struct ip_options	opt;		/* Compiled IP options		*/
 	unsigned char		flags;
 
+#ifdef CONFIG_IP_NF_TARGET_DIVERT
+    	unsigned short   divert_port;
+#endif
 #define IPSKB_MASQUERADED	1
 #define IPSKB_TRANSLATED	2
 #define IPSKB_FORWARDED		4
 #define IPSKB_XFRM_TUNNEL_SIZE	8
+#define IPSKB_DIVERTED		16
 };
 
 struct ipcm_cookie
@@ -88,6 +92,7 @@
 extern int		ip_rcv(struct sk_buff *skb, struct net_device *dev,
 			       struct packet_type *pt);
 extern int		ip_local_deliver(struct sk_buff *skb);
+extern int      ip_local_deliver_finish(struct sk_buff *skb);
 extern int		ip_mr_input(struct sk_buff *skb);
 extern int		ip_output(struct sk_buff *skb);
 extern int		ip_mc_output(struct sk_buff *skb);
diff -urN --ignore-all-space linux-2.6.12.2-orig/net/ipv4/ip_input.c linux-2.6.12.2-divert/net/ipv4/ip_input.c
--- linux-2.6.12.2-orig/net/ipv4/ip_input.c	2005-06-29 16:00:53.000000000 -0700
+++ linux-2.6.12.2-divert/net/ipv4/ip_input.c	2005-07-05 17:02:14.567802309 -0700
@@ -196,7 +196,7 @@
 	return 0;
 }
 
-static inline int ip_local_deliver_finish(struct sk_buff *skb)
+inline int ip_local_deliver_finish(struct sk_buff *skb)
 {
 	int ihl = skb->nh.iph->ihl*4;
 
@@ -429,3 +429,4 @@
 
 EXPORT_SYMBOL(ip_rcv);
 EXPORT_SYMBOL(ip_statistics);
+EXPORT_SYMBOL(ip_local_deliver_finish);
diff -urN --ignore-all-space linux-2.6.12.2-orig/net/ipv4/netfilter/Kconfig linux-2.6.12.2-divert/net/ipv4/netfilter/Kconfig
--- linux-2.6.12.2-orig/net/ipv4/netfilter/Kconfig	2005-06-29 16:00:53.000000000 -0700
+++ linux-2.6.12.2-divert/net/ipv4/netfilter/Kconfig	2005-07-05 17:03:29.076134464 -0700
@@ -556,6 +556,16 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config IP_NF_TARGET_DIVERT
+	tristate "DIVERT target support"
+	depends on IP_NF_MANGLE
+	help
+	  This options add a `DIVERT` target, which allows you to create rules       
+	  in the `mangle' table which statelessly divert packets to a local port
+
+	  If you want to compile it as a module, say M here and read
+	  <file:Documentation/modules.txt>.  If unsure, say `N'.
+
 config IP_NF_TARGET_TOS
 	tristate "TOS target support"
 	depends on IP_NF_MANGLE
diff -urN --ignore-all-space linux-2.6.12.2-orig/net/ipv4/netfilter/Makefile linux-2.6.12.2-divert/net/ipv4/netfilter/Makefile
--- linux-2.6.12.2-orig/net/ipv4/netfilter/Makefile	2005-06-29 16:00:53.000000000 -0700
+++ linux-2.6.12.2-divert/net/ipv4/netfilter/Makefile	2005-07-05 17:02:14.568802233 -0700
@@ -78,6 +78,7 @@
 obj-$(CONFIG_IP_NF_TARGET_TCPMSS) += ipt_TCPMSS.o
 obj-$(CONFIG_IP_NF_TARGET_NOTRACK) += ipt_NOTRACK.o
 obj-$(CONFIG_IP_NF_TARGET_CLUSTERIP) += ipt_CLUSTERIP.o
+obj-$(CONFIG_IP_NF_TARGET_DIVERT) += ipt_DIVERT.o 
 
 # generic ARP tables
 obj-$(CONFIG_IP_NF_ARPTABLES) += arp_tables.o
diff -urN --ignore-all-space linux-2.6.12.2-orig/net/ipv4/netfilter/ipt_DIVERT.c linux-2.6.12.2-divert/net/ipv4/netfilter/ipt_DIVERT.c
--- linux-2.6.12.2-orig/net/ipv4/netfilter/ipt_DIVERT.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.12.2-divert/net/ipv4/netfilter/ipt_DIVERT.c	2005-07-05 17:02:14.569802157 -0700
@@ -0,0 +1,90 @@
+/*
+ * This is a module which is used for diverting packets.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_DIVERT.h>
+#include <net/ip.h>
+#include <net/udp.h>
+
+static unsigned int divert(struct sk_buff **pskb,
+                           const struct net_device *in,
+                           const struct net_device *out,
+                           unsigned int hooknum,
+                           const void *targinfo,
+                           void *userinfo)
+{
+    const struct ipt_divert_target_info *divinfo = targinfo;
+    struct sk_buff* skb = *pskb;
+
+    IPCB(skb)->flags      |= IPSKB_DIVERTED;
+    IPCB(skb)->divert_port = divinfo->to_port;
+
+    if (skb->nh.iph->frag_off & htons(IP_MF|IP_OFFSET)) {
+        skb = ip_defrag(skb,IP_DEFRAG_LOCAL_DELIVER);
+        if (!skb)
+            return NF_DROP;
+    }
+
+    skb = skb_get(skb); /* inc ref count */
+    if (!skb->dev)
+        skb->dev = skb->dst->dev;
+
+    ip_local_deliver_finish(skb);
+
+    return NF_DROP;   
+}
+
+static int check(const char *tablename,
+                 const struct ipt_entry *e,
+                 void *targinfo,
+                 unsigned int targinfosize,
+                 unsigned int hook_mask)
+{
+
+    if (strcmp(tablename, "mangle") != 0) {
+        printk(KERN_WARNING "divert_check: divert can only be called from the \"mangle\" table (not \"%s\").\n",tablename);
+        return 0;
+    }
+    if (hook_mask & ~(1 << NF_IP_POST_ROUTING) &&
+        hook_mask & ~(1 << NF_IP_FORWARD) &&
+        hook_mask & ~(1 << NF_IP_PRE_ROUTING)) {
+        printk(KERN_WARNING "divert_check: bad hooks %x.\n", hook_mask);
+        return 0;
+    }
+    if (targinfosize != IPT_ALIGN(sizeof(struct ipt_divert_target_info))) {
+        printk(KERN_WARNING "divert_check: bad target size.\n");
+        return 0;
+    }
+
+    return 1;
+}
+
+
+static struct ipt_target ipt_divert_reg = {
+	.name		= "DIVERT",
+	.target		= divert,
+	.checkentry	= check,
+	.me		= THIS_MODULE,
+};
+
+static int __init init(void)
+{
+    if (ipt_register_target(&ipt_divert_reg))
+    return -EINVAL;
+ return 0;
+}
+
+static void __exit fini(void)
+{
+    ipt_unregister_target(&ipt_divert_reg);
+}
+
+module_init(init);
+module_exit(fini);
+MODULE_LICENSE("GPL");
diff -urN --ignore-all-space linux-2.6.12.2-orig/net/ipv4/udp.c linux-2.6.12.2-divert/net/ipv4/udp.c
--- linux-2.6.12.2-orig/net/ipv4/udp.c	2005-06-29 16:00:53.000000000 -0700
+++ linux-2.6.12.2-divert/net/ipv4/udp.c	2005-07-05 17:02:14.570802081 -0700
@@ -1146,10 +1146,17 @@
 	if (udp_checksum_init(skb, uh, ulen, saddr, daddr) < 0)
 		goto csum_error;
 
-	if(rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST))
+	if(rt && (rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST)))
 		return udp_v4_mcast_deliver(skb, uh, saddr, daddr);
 
+#ifdef CONFIG_IP_NF_TARGET_DIVERT
+       if(IPCB(skb)->flags & IPSKB_DIVERTED) 
+           sk = udp_v4_lookup(saddr, uh->source, daddr, IPCB(skb)->divert_port, skb->dev->ifindex);
+       else
+	    sk = udp_v4_lookup(saddr, uh->source, daddr, uh->dest, skb->dev->ifindex);
+#else
 	sk = udp_v4_lookup(saddr, uh->source, daddr, uh->dest, skb->dev->ifindex);
+#endif
 
 	if (sk != NULL) {
 		int ret = udp_queue_rcv_skb(sk, skb);
