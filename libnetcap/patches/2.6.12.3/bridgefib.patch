diff -urN linux-2.6.12.3/include/linux/if_bridge.h linux-2.6.12.3-fib/include/linux/if_bridge.h
--- linux-2.6.12.3/include/linux/if_bridge.h	2005-07-15 21:18:57.000000000 +0000
+++ linux-2.6.12.3-fib/include/linux/if_bridge.h	2005-09-11 14:10:05.000000000 +0000
@@ -44,6 +44,7 @@
 #define BRCTL_SET_PORT_PRIORITY 16
 #define BRCTL_SET_PATH_COST 17
 #define BRCTL_GET_FDB_ENTRIES 18
+#define BRCTL_GET_DEVNAME 19
 
 #define BR_STATE_DISABLED 0
 #define BR_STATE_LISTENING 1
diff -urN linux-2.6.12.3/include/linux/sockios.h linux-2.6.12.3-fib/include/linux/sockios.h
--- linux-2.6.12.3/include/linux/sockios.h	2005-07-15 21:18:57.000000000 +0000
+++ linux-2.6.12.3-fib/include/linux/sockios.h	2005-09-11 14:10:05.000000000 +0000
@@ -28,6 +28,7 @@
 #define SIOCADDRT	0x890B		/* add routing table entry	*/
 #define SIOCDELRT	0x890C		/* delete routing table entry	*/
 #define SIOCRTMSG	0x890D		/* call to routing system	*/
+#define SIOCFINDEV	0x890E		/* call to find output dev	*/
 
 /* Socket configuration controls. */
 #define SIOCGIFNAME	0x8910		/* get iface name		*/
diff -urN linux-2.6.12.3/net/bridge/br_ioctl.c linux-2.6.12.3-fib/net/bridge/br_ioctl.c
--- linux-2.6.12.3/net/bridge/br_ioctl.c	2005-07-15 21:18:57.000000000 +0000
+++ linux-2.6.12.3-fib/net/bridge/br_ioctl.c	2005-09-11 14:10:05.000000000 +0000
@@ -247,6 +247,32 @@
 		return 0;
 	}
 
+	case BRCTL_GET_DEVNAME:
+	{
+		struct net_device *dev;
+		struct net_bridge *br;
+		unsigned char dest[ETH_HLEN];
+		unsigned char brname[IFNAMSIZ];
+		struct net_bridge_fdb_entry *dst;
+		int retval = 0;
+
+		copy_from_user(dest, (void __user *)args[2], ETH_HLEN);
+		copy_from_user(brname, (void __user *)args[1], IFNAMSIZ);
+		dev = __dev_get_by_name(brname);
+		br = netdev_priv(dev);
+
+		rcu_read_lock();
+		if ((dst = __br_fdb_get(br, dest)) != NULL) {
+			copy_to_user((void __user *)args[1], dst->dst->dev->name, IFNAMSIZ);
+                       retval = dst->dst->dev->ifindex;
+		} else {
+			retval = -EINVAL;
+		}
+		rcu_read_unlock();
+
+		return retval;
+	}
+
 	case BRCTL_SET_BRIDGE_STP_STATE:
 		if (!capable(CAP_NET_ADMIN))
 			return -EPERM;
diff -urN linux-2.6.12.3/net/ipv4/af_inet.c linux-2.6.12.3-fib/net/ipv4/af_inet.c
--- linux-2.6.12.3/net/ipv4/af_inet.c	2005-07-15 21:18:57.000000000 +0000
+++ linux-2.6.12.3-fib/net/ipv4/af_inet.c	2005-09-11 14:10:05.000000000 +0000
@@ -741,6 +741,7 @@
 		case SIOCGSTAMP:
 			err = sock_get_timestamp(sk, (struct timeval __user *)arg);
 			break;
+		case SIOCFINDEV:
 		case SIOCADDRT:
 		case SIOCDELRT:
 		case SIOCRTMSG:
diff -urN linux-2.6.12.3/net/ipv4/fib_frontend.c linux-2.6.12.3-fib/net/ipv4/fib_frontend.c
--- linux-2.6.12.3/net/ipv4/fib_frontend.c	2005-07-15 21:18:57.000000000 +0000
+++ linux-2.6.12.3-fib/net/ipv4/fib_frontend.c	2005-09-11 14:11:01.000000000 +0000
@@ -231,10 +231,49 @@
 
 #ifndef CONFIG_IP_NOSIOCRT
 
+static int findev(unsigned int remote, char *p, u32 *nh_gw)
+{
+	struct flowi fl = { .nl_u = { .ip4_u =
+				      { .daddr = remote,
+					.saddr = 0,
+					.tos = 0,
+//					.scope = ((tos & RTO_ONLINK) ?
+					.scope = ((0 & RTO_ONLINK) ?
+						  RT_SCOPE_LINK :
+						  RT_SCOPE_UNIVERSE),
+#ifdef CONFIG_IP_ROUTE_FWMARK
+					.fwmark = 0
+#endif
+				      } },
+			    .iif = loopback_dev.ifindex,
+			    .oif = 0 };
+	struct fib_result res;
+	struct net_device *dev_out = NULL;
+
+	res.fi		= NULL;
+#ifdef CONFIG_IP_MULTIPLE_TABLES
+	res.r		= NULL;
+#endif
+	if (fib_lookup(&fl, &res)) {
+			return 0;
+	}
+	*nh_gw = FIB_RES_GW(res);
+	if (res.type == RTN_LOCAL) {
+		dev_out = &loopback_dev;
+	} else {
+		dev_out = FIB_RES_DEV(res);
+	}
+	dev_hold(dev_out);
+	fib_res_put(&res);
+	strcpy(p, dev_out->name);
+       fl.oif = dev_out->ifindex;
+	dev_put(dev_out);
+	return fl.oif;
+}
+
 /*
  *	Handle IP routing ioctl calls. These are used to manipulate the routing tables
  */
- 
 int ip_rt_ioctl(unsigned int cmd, void __user *arg)
 {
 	int err;
@@ -244,8 +282,23 @@
 		struct nlmsghdr nlh;
 		struct rtmsg	rtm;
 	} req;
+	struct {
+		u32 addr;
+		u32 nh;
+		char name[IFNAMSIZ];
+	} nh_req;
 
 	switch (cmd) {
+	case SIOCFINDEV:
+		if (copy_from_user(&nh_req, arg, sizeof(nh_req))) {
+			return -EFAULT;
+		} else {
+			int oif = findev(nh_req.addr, nh_req.name, &nh_req.nh);
+			if (oif == 0)
+				return -ENETUNREACH;
+			copy_to_user(arg, &nh_req, sizeof(nh_req));
+			return(oif);
+		}
 	case SIOCADDRT:		/* Add a route */
 	case SIOCDELRT:		/* Delete a route */
 		if (!capable(CAP_NET_ADMIN))
