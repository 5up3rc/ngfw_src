# -*-ruby-*-

# Certified Filthy2007
ENV["JAVA_HOME"] = "/usr/lib/jvm/java-1.5.0-sun"

$DevelBuild = true
ARGV.each do |arg|
# the rakefile itself shouldn't deal with package creation/release
#
#   if "pkgs" == arg then
#     $DevelBuild = false
  if arg =~ /install/
    $DevelBuild = false
  end
#   elsif arg =~ /release_?(.+)?/
#     # XXX release the hoonds!
#     # FIXME: is this where the default target distribution should be set ?
#     releaseName = $1 || "testing"
#     $DevelBuild = false

#     task arg.to_sym => :pkgs do
#       Kernel.system('./buildtools/release.sh', releaseName)
#     end
#   end
end

## Building downloads
# FIXME: this can't quite be made a task without some hardcore
# tinkering it seems
Kernel.system( "make -C downloads" )

## This is how you define where the stamp file will go
module Rake
  StampFile = 'taskstamps.txt'
end

require 'buildtools/stamp-task.rb'
require 'buildtools/rake-util.rb'
require 'buildtools/c-compiler.rb'
require 'buildtools/jars.rb'
require 'buildtools/jasper.rb'
require 'buildtools/transform.rb'

task :default => :devel
task :all => :devel

task :clean do
  Kernel.system( "make -C downloads distclean" )
  FileUtils.rm_rf($BuildEnv.devel) if File.exist?($BuildEnv.devel)
  FileUtils.rm_rf($BuildEnv.staging) if File.exist?($BuildEnv.staging)
  FileUtils.rm_rf("foo.dot") if File.exist?("foo.dot")
  FileUtils.rm_rf(FileList['debian/*'].select { |f| File.directory?(f) })
  ## Clear the stamp hashes
  Rake::StampHash.instance.clear
end

task :build => [Package['mvvm'], Package['untangle-client'], Package['tran']]

$InstallTarget = InstallTarget.new(Package['install'], [Package['mvvm'], Package['untangle-client'], Package['tran']], 'install')

task :devel => [Package['install'], $InstallTarget]

# See rake-util.rb, we check the arguments for "pkgs"
task :install => Package['install'] do
  # FIXME: hrm, we're taking init scripts from the staging area under
  # debian/packagename/... and put it back under debian/ ????
  FileList['./debian/**/etc/init.d/*'].each do |f|
    FileUtils.cp(f, "./debian/#{File.basename(f)}.init")
  end
end

# See comment at the top
# task :pkgs => [:install,$InstallTarget] do
#   Kernel.system('./buildtools/incVersion.sh')
#   Kernel.system(*%w(debuild --no-tgz-check -us -uc))
# #  Kernel.system(*%w(sudo ./buildtools/rebuildmvvm.sh))
# end

task Package['mvvm'] => [:structure]

task :structure do
  [$BuildEnv.devel, $BuildEnv.devel, $BuildEnv.grabbag].each do |t|
    ensureDirectory(t)
  end
end

## Require all of the sub packages.
## Done manually because order matters.
## XXX Could create a new helper method that sets a prefix directory before
## calling require and then unsets it afterwards.
require 'util/package.rb'
require 'libmvutil/package.rb'
require 'libnetcap/package.rb'
require 'libvector/package.rb'
require 'jmvutil/package.rb'
require 'jnetcap/package.rb'
require 'jvector/package.rb'
require 'nfutil/package.rb'
require 'mvvm/package.rb'
require 'gui/package.rb'
require 'tran/package.rb'

libalpine_so = "#{$BuildEnv.staging}/libalpine.so"

archives = ['libmvutil', 'libnetcap', 'libvector', 'jmvutil', 'jnetcap', 'jvector']

## Make the so dependent on each archive
archives.each do |n|
  file libalpine_so => Package[n]['archive']
end

file libalpine_so do
  compilerEnv = CCompilerEnv.new( { "flags" => "-pthread #{CCompilerEnv.defaultDebugFlags}" } )
  archivesFiles = archives.map { |n| Package[n]['archive'].filename }

  CBuilder.new(compilerEnv).makeSharedLibrary(archivesFiles, libalpine_so, [],
                                              ['xml2', 'sysfs', 'netfilter_queue'], ['ipq'])
end

$InstallTarget.registerDependency(libalpine_so)

$InstallTarget.installFiles(libalpine_so, "#{Package['mvvm'].distDirectory}/usr/lib/mvvm")

# DO IT!
#graphViz('foo.dot')
