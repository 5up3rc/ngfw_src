/*
 * $HeadURL$
 * Copyright (c) 2003-2007 Untangle, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, version 2,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
 * NONINFRINGEMENT.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 */
package com.untangle.uvm.networking;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.untangle.uvm.LocalUvmContextFactory;
import com.untangle.uvm.networking.internal.DhcpLeaseInternal;
import com.untangle.uvm.networking.internal.DnsStaticHostInternal;
import com.untangle.uvm.networking.internal.NetworkSpaceInternal;
import com.untangle.uvm.networking.internal.NetworkSpacesInternalSettings;
import com.untangle.uvm.networking.internal.ServicesInternalSettings;
import com.untangle.uvm.node.HostName;
import com.untangle.uvm.node.HostNameList;
import com.untangle.uvm.node.IPNullAddr;
import com.untangle.uvm.node.IPaddr;
import com.untangle.uvm.node.NodeException;
import com.untangle.uvm.node.firewall.MACAddress;
import com.untangle.uvm.node.script.ScriptRunner;
import org.apache.log4j.Logger;

class DhcpManager
{
    private static final String COMMENT = "#";
    private static final String HEADER  = COMMENT + " AUTOGENERATED BY METAVIZE DO NOT MODIFY MANUALLY\n";

    private static final String FLAG_DHCP_RANGE       = "dhcp-range";
    private static final String FLAG_DHCP_HOST        = "dhcp-host";
    private static final String FLAG_DHCP_OPTION      = "dhcp-option";
    private static final String FLAG_DNS_LOCAL_DOMAIN = "domain";
    private static final String FLAG_DNS_LOCALIZE     = "localise-queries";

    private static final String FLAG_DHCP_GATEWAY     = "3";
    private static final String FLAG_DHCP_NETMASK     = "1";
    private static final String FLAG_DHCP_NAMESERVERS = "6";
    private static final String FLAG_DNS_LISTEN       = "listen-address";
    private static final String FLAG_DNS_LISTEN_PORT  = "port";

    private static final String FLAG_DNS_BIND_INTERFACES = "bind-interfaces";
    private static final String FLAG_DNS_INTERFACE       = "interface";

    private static final int DHCP_LEASE_ENTRY_LENGTH  = 5;
    private static final String DHCP_LEASE_DELIM      = " ";

    private static final String DHCP_LEASES_FILE      = "/var/lib/misc/dnsmasq.leases";
    private static final int DHCP_LEASE_ENTRY_EOL     = 0;
    private static final int DHCP_LEASE_ENTRY_MAC     = 1;
    private static final int DHCP_LEASE_ENTRY_IP      = 2;
    private static final int DHCP_LEASE_ENTRY_HOST    = 3;

    private static final String DNS_MASQ_FILE         = "/etc/dnsmasq.conf";
    private static final String DNS_MASQ_CMD          = System.getProperty( "bunnicula.home" ) + "/networking/dnsmasq";
    private static final String HOST_FILE             = "/etc/hosts";
    private static final String[] HOST_FILE_START     = new String[] {
        HEADER,
        "127.0.0.1  localhost"
    };

    private static final String[] HOST_FILE_END       = new String[] {
        "# The following lines are desirable for IPv6 capable hosts",
        "# (added automatically by netbase upgrade)",
        "",
        "::1     ip6-localhost ip6-loopback",
        "fe00::0 ip6-localnet",
        "ff00::0 ip6-mcastprefix",
        "ff02::1 ip6-allnodes",
        "ff02::2 ip6-allrouters",
        "ff02::3 ip6-allhosts"
    };

    private final Logger logger = Logger.getLogger( DhcpManager.class );

    DhcpManager()
    {
    }

    void configure( ServicesInternalSettings settings ) throws NetworkException
    {
    }

    void startDnsMasq() throws NetworkException
    {
    }

    void deconfigure()
    {
    }

    void loadLeases( DhcpServerSettings settings )
    {
    }

    void parseLease( String str, List<DhcpLeaseRule> leaseList, Date now, Map<MACAddress,Integer> macMap )
    {
    }

    private void overlayStaticLeases( List<DhcpLeaseRule> staticList, List<DhcpLeaseRule> leaseList,
                                      Map<MACAddress,Integer> macMap )
    {
    }

    /* This removes all of the non-static leases */
    void fleeceLeases( DhcpServerSettings settings )
    {
    }

    void updateDhcpRange( ServicesSettings servicesSettings, IPaddr address, IPaddr netmask )
    {
        if ( address == null || netmask == null || address.isEmpty() || netmask.isEmpty()) {
            logger.info( "empty address or netmask, continuing." );
            return;
        }

        /* This may get disabled (eg in the case where the wizard detects it should go into bridge mode) */
        servicesSettings.setDhcpEnabled( true );
        servicesSettings.setDnsEnabled( true );

        /* Convert to an array of bytes, to calculate the start/end address */
        byte addressArray[] = address.getAddr().getAddress();
        byte netmaskArray[] = netmask.getAddr().getAddress();

        if (( netmaskArray[3] & 0x3F ) != 0 ) {
            logger.info( "Netmask is too restricting, ignoring settings change" );
            return;
        }

        byte startArray[] = new byte[4];
        byte endArray[] = new byte[4];
        System.arraycopy( addressArray, 0, startArray, 0, NetworkUtilPriv.IP_ADDR_SIZE_BYTES );
        System.arraycopy( addressArray, 0, endArray, 0, NetworkUtilPriv.IP_ADDR_SIZE_BYTES );

        /* The ideal case */
        if ( netmaskArray[3] == 0 ) {
            if (( addressArray[3] < 100 ) || ( addressArray[3] > 200 )) {
                startArray[3] = 100;
                endArray[3]   = (byte)200;
            } else {
                startArray[3] = 16;
                endArray[3]   = 99;
            }
        } else {
            int min = byteToInt( netmaskArray[3] & addressArray[3] );
            int max = byteToInt( min | ( ~netmaskArray[3] ));

            int startValue = byteToInt( addressArray[3] );

            /* Address is in the first half */
            if ( startValue < (( min + max ) / 2 ))  startValue = (( min + max ) / 2 ) + 4;
            else                                     startValue = min + 4;

            int endValue = startValue + (( max - min ) / 2 ) - 16;
            System.out.println( "startValue: " + startValue + " endValue " + endValue );
            startArray[3] = (byte)startValue;
            endArray[3]   = (byte)endValue;
        }

        try {
            IPaddr start = new IPaddr((Inet4Address)InetAddress.getByAddress( startArray ));
            IPaddr end   = new IPaddr((Inet4Address)InetAddress.getByAddress( endArray ));
            servicesSettings.setDhcpStartAndEndAddress( start, end );
        } catch ( Exception e ) {
            logger.warn( "Exception creating IP addr, ignoring settings change", e );
        }
    }

    private int byteToInt ( byte val )
    {
        int num = val;
        if ( num < 0 ) num = num & 0x7F + 0x80;
        return num;
    }

    private int byteToInt ( int val )
    {
        int num = val;

        if ( num < 0 ) num = num & 0x7F + 0x80;
        return num;
    }

    private void writeConfiguration( ServicesInternalSettings settings )
    {
    }

    /**
     * Save the file /etc/hosts
     */
    private void writeHosts( ServicesInternalSettings settings, NetworkSpacesInternalSettings nsis )
    {
    }

    /* XXX This should go into a global util class */
    private void writeFile( StringBuilder sb, String fileName )
    {
    }

    private void appendNameServers( StringBuilder sb, ServicesInternalSettings settings )
    {
    }

    /* This guarantees the comment appears with a newline at the end */
    private void comment( StringBuilder sb, String comment )
    {
        sb.append( COMMENT + " " + comment + "\n" );
    }

    private void writeDisabledConfiguration()
    {
        StringBuilder sb = new StringBuilder();

        sb.append( HEADER );
        comment( sb, "DNS is disabled, binding DNS to local host" );
        sb.append( FLAG_DNS_LISTEN + "=" + "127.0.0.1\n\n" );

        writeFile( sb, DNS_MASQ_FILE );
    }
}
