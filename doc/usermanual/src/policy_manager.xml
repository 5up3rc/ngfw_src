<?xml version="1.0" encoding="UTF-8"?>
<chapter id="policy_manager">
  <title>Policy Manager</title>

  <para>
    The Policy Manager is a powerful and advanced feature of the &eg;.  It lets Administrators configure several Software Appliances of the same type (e.g. Virus Scanner), and route different types of traffic to different instances of each appliance.   Traffic is routed based on the network interface and/or endpoints of traffic.  For more information on the network interfaces available to your &eg;, please refer to <xref linkend="fixme_interfaces"/>.
  </para>
  <para>
    The Policy Manager is launched from the main Administrative Interface by selecting <guilabel>Show Policy Manager</guilabel> as seen in <xref linkend="policy_manager_launch_policy_mngr"/>.
  </para>
  <figure id="policy_manager_launch_policy_mngr">
    <title>Launching the Policy Manager</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="figure/policymngr/launch_policy_mngr.png" />
      </imageobject>
    </mediaobject>
  </figure>    
  <para>
    The Policy Manager works by creating rules, or <quote>policies</quote>.  A policy binds traffic matching certain criteria to a Virtual Rack.  For an overview of Policies and Virtual Racks, please refer to <xref linkend="policy_manager_overview"/>.  For modification of the default policies, please refer to <xref linkend="policy_manager_def_policies"/>.  To create your own Virtual Racks and assign them to Policies, please refer to <xref linkend="policy_manager_available_racks"/> and <xref linkend="policy_manager_custom_policies"/>.
  </para>


  <sect1 id="policy_manager_overview">
    <title>Policies and Virtual Racks</title>

    <para>
      We will begin our introduction to Policies and Virtual Racks with a simplified discussion of the &eg; <emphasis>without</emphasis> policies.  This will let us explain how traffic is routed between network interfaces and Software Appliances.  We will then expand the discussion to the use of Policies and Virtual Racks.
    </para>


    <!-- ============================================================ -->
    <bridgehead id="policy_manager_overview_int_end_rtg"  xreflabel="Interfaces, Endpoints and Routing">Interfaces, Endpoints and Routing</bridgehead>
    <para>
      Traffic arrives at one network interface of &eg; and leaves on another (for more information on the network interfaces available to your &eg;, please refer to <xref linkend="fixme_interfaces"/>).  Between when the traffic enters and exits the &eg;, several Software Appliances may scan and/or modify the traffic.  To illustrate how the &eg; handles traffic, we will use the example in <xref linkend="policy_manager_overview_example_pagereq"/>.
    </para>
    <example id="policy_manager_overview_example_pagereq">
      <title>Simple Web Page Request</title>
      <para>
        Emma is sitting at here desktop on the protected network (the <constant>internal</constant> interface).  Emma decides she wants to learn more about <quote>networking</quote> so she visits Google in her web browser.  Since Emma's computer is behind an &eg; running <glossterm linkend="gloss_nat">NAT</glossterm>, the IP address of her computer is <constant>10.0.0.129</constant>.  From the perspective of the &eg;, Emma's pointing her browser at Google is a <glossterm linkend="gloss_tcp">TCP</glossterm> request from the <glossterm linkend="gloss_ip_addr">IP address</glossterm> <constant>10.0.0.129</constant> (Emma's machine) to the IP address <constant>66.102.7.99</constant> on <glossterm linkend="gloss_port">port</glossterm> <constant>80</constant> (<constant>66.102.7.99</constant> is one of the many IP addresses of Google).
      </para>
    </example>
    <para>
      From the time Emma makes the page request until that request arrives at Google, the following sequence takes place.
    </para>
    <procedure>
      <step>
        <para>
          A request is sent from Emma's machine (<constant>10.0.0.129</constant>) to the &eg; (which acts as the <glossterm linkend="gloss_gateway">network gateway</glossterm>) and received on the &eg;'s <constant>internal</constant> interface.  The &eg; now considers this request's <emphasis>client interface</emphasis> to be the <constant>internal</constant> interface.
        </para>
      </step>
      <step>
        <para>
          The &eg; inspects the request, and find it contains the client IP address to be <constant>10.0.0.129</constant>.  It finds the server IP:port to be <constant>66.102.7.99:80</constant>.
        </para>
      </step>
      <step>
        <para>
          One or more Software Appliances may inspect this traffic.  In this case, the Web Content Control (see <xref linkend="httpblocker_tran"/>) inspects the request.  No malicious or flagged content is found.
        </para>
      </step>      
      <step>
        <para>
          The &eg; consults its rules to determine how to route traffic to that server IP:port,  <constant>66.102.7.99:80</constant>.  These rules determine the <emphasis>server interface</emphasis> of the request.  In this case, the &eg; determines that the server interface is the <constant>external</constant> interface.
        </para>
      </step>
      <step>
        <para>
          The request is sent from the &eg; to <constant>66.102.7.99:80</constant>, exiting the &eg; on the <constant>external</constant> interface.
        </para>
      </step>
    </procedure>
    <para>
      This simple example highlights several important concepts required in the understanding of Policies and Virtual Racks.  The &eg; used four pieces of information in the processing of the request.  It used the IP address of the requestor (client) and the IP:port of the requestee (server).  We call these <emphasis>endpoints</emphasis>, and there were two of them with Emma's request (Emma's machine and Google's Web Server).  There were also two network interfaces involved, one where the request was received at the &eg; (the <constant>internal</constant> interface), and one where the request left (the <constant>external</constant> interface).
    </para>

    <!-- ============================================================ -->
    <bridgehead>Routing and Virtual Racks</bridgehead>
    <para>
      The example of Emma's Google request in <xref linkend="policy_manager_overview_example_pagereq"/> omitted one important detail.  Between steps 2 and 3, the &eg; had to determine <emphasis>which</emphasis> Virtual Rack should inspect the traffic.
    </para>
    <para>
      As discussed in <xref linkend="introduction"/>, Software Appliances are not installed into an &eg; but <emphasis>into a (virtual) rack</emphasis>.  A given &eg; may have many such <quote>virtual</quote> racks.  Virtual Racks contain zero or more Software Appliances.
    </para>
    <para>
      At this point in our discussion, we must address the question <quote>...why would I want more than one Virtual Rack?</quote>.  The simple answer is <quote>...you do not, unless you hit a situation where you cannot configure a given Software Appliance yet meet your needs</quote>.  Examples when using multiple Virtual Racks solve practical business problems are presented in <xref linkend="policy_manager_overview_mvr_examples"/>.
      
      <itemizedlist id="policy_manager_overview_mvr_examples">
        <title>Applications for Multiple Virtual Racks</title>
        <listitem>
          <para>
            Setting up a <!-- <glossterm linkend="gloss_dmz"> -->DMZ<!-- </glossterm> --> to host an internet-facing web server.  The policies associated with the web traffic to your own web server (filtering, scanning) are different than those for employees browsing the web.
          </para>
        </listitem>

        <listitem>
          <para>
            Setting-up a special file transfer relationship between your organization and business partner.  File transfers between these two groups may be permitted to transfer certain file types (executable code), yet these are blocked for the general Internet.
          </para>
        </listitem>

        <listitem>
          <para>
            Setting up a <!-- <glossterm linkend="gloss_vpn"> -->VPN<!-- </glossterm> --> (see <xref linkend="openvpn_tran"/> for more information on the VPN capabilities of the &eg;).  Since many users VPN into the network from home (and their home networks may not be as secure), you may wish to restrict access to critical internal systems for VPN users.
          </para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      The previous list highlights cases where a single Software Appliance cannot be configured for all situations (for example, <link linkend="httpblocker_tran">Web Content Control</link> should scan for traffic from desktops yet not to a company's own web server).  Virtual Racks let you install just those appliances which are needed for the type of traffic encountered.
    </para>

    <!-- ============================================================ -->
    <bridgehead>Brining it All Together</bridgehead>    

    <para>
      Now that we have discussed the mechanics of how the &eg; routes traffic and the uses for multiple Virtual Racks, we must conclude with how the &eg; chooses to route a given piece of traffic to a given Virtual Rack.
    </para>
    <para>
      The &eg; routes traffic to a Virtual Rack by consulting its list of <emphasis>Policies</emphasis>.  Policies can be thought of as a rule, binding a <quote>type</quote> of traffic to a Virtual Rack. A given policy can be expressed as
      <blockquote>
        <para>
          If the traffic looks like '<constant>X</constant>', route it to Virtual Rack '<constant>Y</constant>'
        </para>
      </blockquote>

      where '<constant>Y</constant>' is the name of the Virtual Rack, and '<constant>X</constant>' defines the type traffic.  The simplest way to differentiate traffic is by its client and server interfaces.  Recall from <xref linkend="policy_manager_overview_int_end_rtg"/> that all traffic through the &eg; can be classified by four characteristics: its two interfaces (client/server) and two endpoints (client/server).  Administrators configure Policies to partition traffic into types based on specifying (at a minimum) the two interfaces of the traffic.  For example, the first item in <xref linkend="policy_manager_overview_mvr_examples"/> would require two policies.  The first policy would define its traffic as <quote>from <constant>external</constant> interface to <constant>DMZ</constant> nterface</quote> and the second as <quote>from <constant>DMZ</constant> interface to <constant>external</constant> interface</quote>.  Both policies would select the Virtual Rack <quote>DMZ Traffic</quote>.
    </para>
    <para>
      More advanced Policies can partition traffic based not only on the interfaces, but also on one or both endpoints.  This allows Administrators to target Software Appliances between locations as explicit as specfic machines.
    </para>


    <!-- ============================================================ -->
    <bridgehead>Special Racks and Policies</bridgehead>

    <para>
      The &eg; ships with a single Virtual Rack called <constant>Default Rack</constant>.  This cannot be removed, and serves organizations with simple protection needs.  When configuring Policies, Administrators can also select <constant>no rack</constant> as the target for a given type of traffic.  The <constant>no rack</constant> option can be thought of as a Virtual Rack without any installed Software Appliances, and can be used to ensure certain types of traffic are not filtered.
    </para>
    <para>
      The &eg; also ships with six default Policies which cannot be deleted.  By default, these policies select all traffic between the <constant>external</constant>, <constant>internal</constant>,and <constant>DMZ</constant> interfaces to be routed to the <constant>Default Rack</constant>.
    </para>

    <!--
      WRS - I know we should also discuss that when configuring a Policy, you actualy select "Rack (direction)".  However, I think that is just too much.  Instead, I'm going to "cheat" and discuss that in the "Default Policies" and "Custom Policies" sections.
    -->
  </sect1>

  <sect1 id="policy_manager_adminui">
    <title>Administrative Interface</title>
    <para>
      The Administrative Interface is divided into three sections.  The first section, covered in <xref linkend="policy_manager_def_policies"/>, discusses how to modify the default policies as shipped with your &eg;.  <xref linkend="policy_manager_available_racks"/> discusses how to create new Virtual Racks, and <xref linkend="policy_manager_custom_policies"/> explains how to create rules routing traffic to your custom Virtual Racks.
    </para>
    <!-- ========================================================= -->
    <sect2 id="policy_manager_def_policies">
      <title>Default Policies</title>
      <para>
        The Default Policies tab, as seen in <xref linkend="policy_manager_def_policies_figure"/>, controls which Virtual Racks should process the basic 6 types of traffic.
      </para>
      <figure id="policy_manager_def_policies_figure">
        <title>Default Policies Tab</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="figure/policymngr/policymngr_default.png" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>
        Administrators cannot add or remove Policies from the Default Policies set.  Instead, the Default Policies tab is used to route traffic between two interfaces to a given Virtual Rack (for more information on creating new Virtual Racks, please see <xref linkend="policy_manager_available_racks"/>).When selecting the <guilabel>rack</guilabel>, you select not just the Virtual Rack's name but also the <emphasis>direction</emphasis>.  There are two choices for each Virtual Rack in the list <guilabel>rack</guilabel>, corresponding to <constant>inbound</constant> and <constant>outbound</constant> traffic.
        <tip>
          <para>
            If you wish certain types of traffic to receive no scanning, you do not have to create an empty Virtual Rack.  Instead, select <constant>no rack</constant> as the value for <guilabel>rack</guilabel> in your custom policy.
          </para>
        </tip>
      </para>
      <para>
        The direction specifier is required because some Software Appliances have different settings depending if the traffic is <constant>inbound</constant> or <constant>outbound</constant>.  For example, an organization may wish to scan <constant>inbound</constant> <glossterm linkend="gloss_smtp">SMTP</glossterm> (email) traffic for SPAM but not <constant>outbound</constant>.  When assigning a Virtual Rack to a Policy, the Policy needs to know if the traffic should be labeled <constant>inbound</constant> or <constant>outbound</constant> when it is handed to a Software Appliance.  The default settings should provide guidance for the Administrator.  For example, the Policy handling traffic from the <constant>external</constant> interface to the <constant>internal</constant> interface is handled by the <constant>default rack</constant> as inbound traffic.
        <tip>
          <para>
            When configuring policies and direction, think from the perspective of the Virtual Rack <emphasis>and the interface being protected</emphasis>.  You will usualy find that of any two network interfaces, one is more <quote>sensitive</quote> and should be though of as the one being protected from the other.
          </para>
          <para>Most people find it easier to picture <quote>inside</quote> resources being protected.  For a given Policy, traffic flowing to the more sensitive network is generally <constant>inbound</constant> and should select the <constant>inbound</constant> version of a Virtual Rack.
          </para>
        </tip>
      </para>
      <para>
        For the majority of deployments, the Policies as seen in <xref linkend="policy_manager_def_policies_figure"/> will serve an organization's needs.  If you need to differentiate traffic not just on network interface but <emphasis>also</emphasis> on one or both endpoints, you should create a Custom Policy.  Custom Policies are discussed on <xref linkend="policy_manager_custom_policies"/>.
      </para>
    </sect2>
  
    <!-- ========================================================= -->
    <sect2 id="policy_manager_custom_policies">
      <title>Custom Policies</title>
      <para>
        As mentioned in <xref linkend="policy_manager_def_policies"/>, most deployments do not need to create Custom Policies.  Custom Policies are only used when the two network interfaces are not enough to isolate a class of network traffic.  The interface for creating Custom Policies is shown in <xref linkend="policy_manager_custom_policies_figure"/>.
      </para>
      <figure id="policy_manager_custom_policies_figure">
        <title>Custom Policies Tab</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="figure/policymngr/policymngr_custom.png" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>
        To create a new Custom Policy, one must first have created a Virtual Rack other than <constant>default rack</constant> (see <xref linkend="policy_manager_available_racks"/> for more information on creating new Virtual Racks).  The process of creating a new Custom Policy begins by pushing the add (plus) button as seen in <xref linkend="policy_manager_custom_policies_figure"/>.  This creates a new row in the Custom Policies table.  Administrators must then specify the endpoints, interfaces, and Virtual Rack for the new Custom Policy.  The complete list of fields for a given Custom Policy is as follows.
        <variablelist>
          <varlistentry>
            <term><guilabel>number (#)</guilabel></term>
            <listitem>
              <para>
                The number column indicates the relative priority of this policy vs. others.  Higher number policies are evaluated first.  Note that the Default Policies can be though of as being at the end of the Custom Policies list, with lower priority than <emphasis>all</emphasis> custom policies.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>client interface</guilabel></term>
            <listitem>
              <para>
                This is the network interface where the traffic first entered the &eg;.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>server interface</guilabel></term>
            <listitem>
              <para>
                This is the network interface where the traffic exits the &eg;.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>source interface</guilabel></term>
            <listitem>
              <para>
                This is the source interface on-which &eg; received traffic.  For more information on the network interfaces of your &eg;, please refer to <xref linkend="fixme_interfaces"/>.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>rack</guilabel></term>
            <listitem>
              <para>
                The <guilabel>rack</guilabel> selects which Virtual Rack will handle traffic selected by this policy.  When selecting the <guilabel>rack</guilabel>, you select not just the Virtual Rack's name but also the <emphasis>direction</emphasis>.  There are two choices for each Virtual Rack in the list <guilabel>rack</guilabel>, corresponding to <constant>inbound</constant> and <constant>outbound</constant> traffic.
              </para>
              <para>
                The direction specifier is required because some Software Appliances have different settings depending if the traffic is <constant>inbound</constant> or <constant>outbound</constant>.  For example, an organization may wish to scan <constant>inbound</constant> <glossterm linkend="gloss_smtp">SMTP</glossterm> (email) traffic for SPAM but not <constant>outbound</constant>.  When assigning a Virtual Rack to a Policy, the Policy needs to know if the traffic should be labeled <constant>inbound</constant> or <constant>outbound</constant> when it is handed to a Software Appliance.  The default settings should provide guidance for the Administrator.  For example, the Policy handling traffic from the <constant>external</constant> interface to the <constant>internal</constant> interface is handled by the <constant>default rack</constant> as inbound traffic.
                <tip>
                  <para>
                    When configuring policies and direction, think from the perspective of the Virtual Rack <emphasis>and the interface being protected</emphasis>.  You will usualy find that of any two network interfaces, one is more <quote>sensitive</quote> and should be though of as the one being protected from the other.
                  </para>
                  <para>Most people find it easier to picture <quote>inside</quote> resources being protected.  For a given Policy, traffic flowing to the more sensitive network is generally <constant>inbound</constant> and should select the <constant>inbound</constant> version of a Virtual Rack.
                  </para>
                </tip>
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>protocol</guilabel></term>
            <listitem>
              <para>
                This field selects the network protocol to select.  Valid values are <glossterm linkend="gloss_tcp"><constant>TCP</constant></glossterm>, <glossterm linkend="gloss_udp"><constant>UDP</constant></glossterm>, <glossterm linkend="gloss_ping"><constant>PING</constant></glossterm> or combinations there of.
              </para>
            </listitem>
          </varlistentry>          
          <varlistentry>
            <term><guilabel>client address</guilabel></term>
            <listitem>
              <para>
                This field defines the source IP address of the traffic.  Valid values are in <link linkend="appendix_syntax_ipmatcher">IP Matcher</link> format.  Note that IP Matcher supports the value <quote><constant>any</constant></quote>.  Assigning this field to <constant>any</constant> means that the <guilabel>client address</guilabel> is effectlvly removed as a traffic selection criteria.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>server address</guilabel></term>
            <listitem>
              <para>
                This field defines the destination IP address of the traffic.  Valid values are in <link linkend="appendix_syntax_ipmatcher">IP Matcher</link> format.  Note that IP Matcher supports the value <quote><constant>any</constant></quote>.  Assigning this field to <constant>any</constant> means that the <guilabel>server address</guilabel> is effectlvly removed as a traffic selection criteria.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><guilabel>server port</guilabel></term>
            <listitem>
              <para>
                The destination port of the traffic.  Valid values are in <link linkend="appendix_syntax_portmatcher">Port Matcher</link> format.  Note that Port Matcher supports the value <quote><constant>any</constant></quote>.  Assigning this field to <constant>any</constant> means that the <guilabel>server port</guilabel> is effectlvly removed as a traffic selection criteria.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
      <tip>
        <para>
          If you wish certain types of traffic to receive no scanning, you do not have to create an empty Virtual Rack.  Instead, select <constant>no rack</constant> as the value for <guilabel>rack</guilabel> in your custom policy.
        </para>
      </tip>
    </sect2>
  
    <!-- ========================================================= -->
    <sect2 id="policy_manager_available_racks">
      <title>Available Racks</title>
      <para>
        The Available Racks tab, as seen in <xref linkend="policy_manager_available_racks_figure"/>, is used by Administrators to view and modify the set of Virtual Racks.
      </para>
      <figure id="policy_manager_available_racks_figure">
        <title>Available Racks Tab</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="figure/policymngr/policymngr_available.png" />
          </imageobject>
        </mediaobject>
      </figure>
      <para>
        To add a new Virtual Rack, push the add (plus) button to the left as seen in <xref linkend="policy_manager_available_racks_figure"/>.  This adds a new row to the Available Racks table.  The only required field is <guilabel>rack name</guilabel>, and should be descriptive of the purpose of the rack.
        <note>
          <para>
            Creating a Virtual Rack and assigning it to Policies is not useful unless you assign some Software Appliances to your new rack.  To add Software Appliances to your new Virtual Rack, select your rack from the list of Virtual Racks as seen in <xref linkend="policy_manager_launch_policy_mngr"/>.  From there, appliances can be added as described in <xref linkend="introduction_ui_appliance"/>.
          </para>
        </note>
      </para>
    </sect2>
  </sect1>


  <!-- ############################################################# -->
  <sect1 id="policy_manager_qa">
    <title>Frequently Asked Questions</title>
    <qandaset>

      <!-- ******************************************* -->
      <qandaentry>
        <question>
          <para>Why can't I add/remove entries from the <guilabel>Default Policies</guilabel> tab?</para>
        </question>
        <answer>
          <para>
            The default policies ensure that all possible traffic is handled by a Virtual Rack.  Deleting one of these entries without a corresponding entry in the <guilabel>Custom Policies</guilabel> tab would cause the &eg; not to know how to handle types of traffic.
          </para>
        </answer>
      </qandaentry>    
    
      <!-- ******************************************* -->
      <qandaentry>
        <question>
          <para>I only want to scan inbound email traffic, not outbound.  Do I need to create a new Virtual Rack and Policies?</para>
        </question>
        <answer>
          <para>
            No.  Many Software Appliances (including all of those which scan email) let you directly configure behaviors for <constant>inbound</constant> vs. <constant>outbound</constant> traffic.
          </para>
        </answer>
      </qandaentry>

      <!-- ******************************************* -->
      <qandaentry>
        <question>
          <para>We are using the &eg; with its VPN Software Appliance.  Do I need to configure extra Virtual Racks for the VPN users?</para>
        </question>
        <answer>
          <para>
            You do not have to create extra Virtual Racks/Policies in order to use VPN.  You only need to do so if you want to scan traffic <emphasis>differently</emphasis> for VPN users.  If you consider VPN users are equivilant to machines on your network, just route the Policies dealing with the VPN interface to the <constant>default rack</constant>.
          </para>
        </answer>
      </qandaentry>      
    </qandaset>
  </sect1>    

</chapter>
