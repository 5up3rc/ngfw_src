/*
 * Copyright (c) 2003, 2005 Metavize Inc.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Metavize Inc. ("Confidential Information").  You shall
 * not disclose such Confidential Information.
 *
 *  $Id$
 */

package com.metavize.mvvm.networking;

import java.io.File;
import java.io.FileWriter;
import java.io.FileNotFoundException;
import java.io.BufferedWriter;

import java.util.List;

import org.apache.log4j.Logger;

import com.metavize.jnetcap.Netcap;
import com.metavize.jnetcap.JNetcapException;
import com.metavize.jnetcap.PortRange;

import com.metavize.mvvm.IntfConstants;
import com.metavize.mvvm.argon.IntfConverter;
import com.metavize.mvvm.tran.IPaddr;

import com.metavize.mvvm.networking.internal.InterfaceInternal;
import com.metavize.mvvm.networking.internal.NetworkSpaceInternal;

public class RuleManager
{
    private static final String HEADER = "##AUTOGENERATED BY METAVIZE DO NOT MODIFY MANUALLY\n\n";

    private static final String UDP_DIVERT_PORT_FLAG         = "UDP_DIVERT_PORT";
    private static final String TCP_REDIRECT_PORT_FLAG       = "TCP_REDIRECT_PORTS";
    private static final String ANTISUBSCRIBE_LOCAL_IN_FLAG  = "ANTISUBSCRIBE_LOCAL_INSIDE";
    private static final String ANTISUBSCRIBE_LOCAL_OUT_FLAG = "ANTISUBSCRIBE_LOCAL_OUTSIDE";
    private static final String DHCP_BLOCK_FORWARD_FLAG      = "DHCP_BLOCK_FORWARDING";
    private static final String PUBLIC_ADDR_FLAG             = "HTTPS_PUBLIC_ADDR";
    private static final String PUBLIC_PORT_FLAG             = "HTTPS_PUBLIC_PORT";
    private static final String PUBLIC_REDIRECT_EN           = "HTTPS_PUBLIC_REDIRECT_EN";

    /* Set to a list of interfaces that are in the services space that need to be able to
     * access the services */
    private static final String SERVICES_INTERFACE_LIST      = "MVVM_SERVICES_INTF_LIST";

    /* Set to the index of the interfaces where ping should be enabled. */
    private static final String PING_ANTISUBSCRIBE_FLAG      = "MVVM_PING_EN";
    private static final String PING_ANTISUBSCRIBE_LIST      = "MVVM_PING_LIST";

    private static RuleManager INSTANCE = null;

    private final String BUNNICULA_BASE = System.getProperty( "bunnicula.home" );
    private final String BUNNICULA_CONF = System.getProperty( "bunnicula.conf.dir" );
    private final String MVVM_TMP_FILE  = BUNNICULA_CONF + "/tmp_params";

    private final String RULE_GENERATOR_SCRIPT = BUNNICULA_BASE + "/networking/rule-generator";
    private final String RULE_DESTROYER_SCRIPT = BUNNICULA_BASE + "/networking/rule-destroyer";

    private final Logger logger = Logger.getLogger( RuleManager.class );

    private boolean subscribeLocalInside  = false;
    private boolean subscribeLocalOutside = false;
    private boolean dhcpEnableForwarding  = true;

    private boolean isPublicRedirectEnabled = false;

    private IPaddr publicAddress = null;
    private int publicPort = -1;

    private boolean isShutdown = false;

    /* Set to true in order to use the value specified in the interface list */
    private boolean pingInterfaceEnable = false;

    /* List of the interfaces where ping is enabled */
    private String pingInterfaceList = "";

    /* List of interfaces that are in the services spaces */
    private String servicesInterfaceList = "";

    /* Call the script to generate all of the iptables rules */
    synchronized void generateIptablesRules() throws NetworkException
    {
        if ( isShutdown ) {
            logger.warn( "MVVM is already shutting down, no longer able to generate rules" );
            return;
        }

        int ret = 0;
        try {
            writeConfig();

            /* Call the rule generator */
            Process p = Runtime.getRuntime().exec( "sh " + RULE_GENERATOR_SCRIPT );
            
            ret = p.waitFor();
        } catch ( Exception e ) {
            logger.error( "Error while generating iptables rules", e );
            throw new NetworkException( "Unable to generate iptables rules", e );
        }
        
        if ( ret != 0 ) throw new NetworkException( "Error while generating iptables rules: " + ret );
    }

    synchronized void destroyIptablesRules() throws NetworkException
    {
        int ret = 0;
        try {
            /* Call the rule generator */
            /* XXXXXXX Make the scripts executable */
            Process p = Runtime.getRuntime().exec( "sh " + RULE_DESTROYER_SCRIPT );
            
            ret = p.waitFor();
        } catch ( Exception e ) {
            logger.error( "Error while removing iptables rules", e );
            throw new NetworkException( "Unable to remove iptables rules", e );
        }
        
        if ( ret != 0 ) throw new NetworkException( "Error while removing iptables rules: " + ret );
    }

    void subscribeLocalInside( boolean subscribeLocalInside )
    {
        this.subscribeLocalInside = subscribeLocalInside;
    }

    void subscribeLocalOutside( boolean subscribeLocalOutside )
    {
        this.subscribeLocalOutside = subscribeLocalOutside;
    }
    
    void dhcpEnableForwarding( boolean dhcpEnableForwarding )
    {
        this.dhcpEnableForwarding = dhcpEnableForwarding;
    }

    void setPublicAddress( IPaddr publicAddress, int port, boolean isPublicRedirectEnabled  )
    {
        this.publicAddress = publicAddress;
        this.publicPort    = port;
        this.isPublicRedirectEnabled = isPublicRedirectEnabled;
    }

    /* Just used to setup the antisubscribes */
    void setInterfaceList( List<InterfaceInternal> interfaceList, NetworkSpaceInternal serviceSpace )
    {
        String pingAntisubscribeList = "";
        
        String servicesInterfaceList = "";
        
        IntfConverter ic = IntfConverter.getInstance();

        for ( InterfaceInternal intf : interfaceList ) {
            if ( serviceSpace != null && serviceSpace.equals( intf.getNetworkSpace())) {
                byte argonIntf = intf.getArgonIntf();
                switch( argonIntf ) {
                case IntfConstants.EXTERNAL_INTF:
                    /* Always ignore the external interface */
                    break;
                    
                case IntfConstants.DMZ_INTF:
                    /* DMZ interface is not added if it is in the public space */
                    if ( 0 == serviceSpace.getIndex()) break;

                    /* fallthrough */
                default:
                    try {
                        /* All other interfaces are always added unconditionally */
                        servicesInterfaceList += " " + intf.getIntfName();
                    } catch ( Exception e ) {
                        logger.warn( "Error converting argon[" + argonIntf + "] interface, ignoring" );
                    }
                }
            }
            
            try {
                if ( intf.isPingable()) {
                    byte netcapIntf = ic.toNetcap( intf.getArgonIntf());
                    pingAntisubscribeList = pingAntisubscribeList + " " + netcapIntf;
                }
            } catch ( Exception e ) {
                logger.error( "Invalid argon interface: ", e );
            }
        }
        
        this.pingInterfaceEnable = true;
        this.pingInterfaceList   = pingAntisubscribeList.trim();
        this.servicesInterfaceList = servicesInterfaceList.trim();
        
    }

    synchronized void isShutdown()
    {
        this.isShutdown = true;
    }

    private void writeConfig() throws NetworkException
    {
        try {
            StringBuilder sb = new StringBuilder();
            
            Netcap netcap = Netcap.getInstance();
            
            sb.append( HEADER );
            
            PortRange tcp = netcap.tcpRedirectPortRange();
            int divertPort = netcap.udpDivertPort();
            
            sb.append( TCP_REDIRECT_PORT_FLAG       + "=" + tcp.low() + ":" + tcp.high() + "\n" );
            sb.append( UDP_DIVERT_PORT_FLAG         + "=" + divertPort + "\n" );
            sb.append( ANTISUBSCRIBE_LOCAL_IN_FLAG  + "=" + !subscribeLocalInside + "\n" );
            sb.append( ANTISUBSCRIBE_LOCAL_OUT_FLAG + "=" + !subscribeLocalOutside + "\n" );
            if ( publicAddress != null && publicPort > 0 ) {
                sb.append( PUBLIC_ADDR_FLAG         + "=" + publicAddress + "\n" );
                sb.append( PUBLIC_PORT_FLAG         + "=" + publicPort + "\n" );
                if ( isPublicRedirectEnabled ) {
                    sb.append( PUBLIC_REDIRECT_EN + "=true\n" );
                }
            }

            sb.append( DHCP_BLOCK_FORWARD_FLAG      + "=" + !dhcpEnableForwarding  + "\n\n" );

            if ( pingInterfaceEnable ) {
                sb.append( PING_ANTISUBSCRIBE_FLAG    + "=true\n"  );
                sb.append( PING_ANTISUBSCRIBE_LIST    + "=\"" + this.pingInterfaceList + "\"\n" );
            }

            if (( null != this.servicesInterfaceList ) && ( this.servicesInterfaceList.length() > 0 )) {
                sb.append( SERVICES_INTERFACE_LIST + "=\"" + this.servicesInterfaceList + "\"\n" );
            }
            
            writeFile( sb, MVVM_TMP_FILE );
        } catch ( JNetcapException e ) {
            logger.error( "Unable to write rule manager configuration", e );
        }
    }

    private void writeFile( StringBuilder sb, String fileName ) throws NetworkException
    {
        BufferedWriter out = null;
        
        /* Open up the interfaces file */
        try {
            String data = sb.toString();
            
            out = new BufferedWriter(new FileWriter( fileName ));
            out.write( data, 0, data.length());
        } catch ( Exception ex ) {
            /* XXX May need to catch this exception, restore defaults
             * then try again */
            logger.error( "Error writing file " + fileName + ":", ex );
            throw new NetworkException( "Error writing file " + fileName, ex );
        } finally {
            try {
                if ( out != null ) out.close();
            } catch ( Exception e ) {
                logger.error( "Unable to close file", e );
            }
        }
    }

    static synchronized RuleManager getInstance()
    {
        if ( INSTANCE == null ) {
            INSTANCE = new RuleManager();
        }
        
        return INSTANCE;
    }


}
