/*
 * Copyright (c) 2003, 2004, 2005, 2006 Metavize Inc.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Metavize Inc. ("Confidential Information").  You shall
 * not disclose such Confidential Information.
 *
 *  $Id$
 */

package com.metavize.mvvm.engine;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.net.Inet4Address;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;

import com.metavize.jnetcap.InterfaceData;
import com.metavize.jnetcap.Netcap;
import com.metavize.mvvm.InterfaceAlias;
import com.metavize.mvvm.ArgonManager;
import com.metavize.mvvm.InterfaceAlias;
import com.metavize.mvvm.IntfConstants;
import com.metavize.mvvm.IntfEnum;
import com.metavize.mvvm.MvvmContextFactory;
import com.metavize.mvvm.InterfaceAlias;
import com.metavize.mvvm.MvvmException;
import com.metavize.mvvm.NetworkingConfiguration;
import com.metavize.mvvm.networking.NetworkingConfigurationImpl;
import com.metavize.mvvm.NetworkingManager;
import com.metavize.mvvm.argon.ArgonManagerImpl;
import com.metavize.mvvm.argon.IntfConverter;
import com.metavize.mvvm.tran.IPaddr;
import com.metavize.mvvm.tran.firewall.intf.IntfMatcherFactory;
import com.metavize.mvvm.tran.ValidateException;
import com.metavize.mvvm.tran.firewall.IntfMatcher;
import org.apache.log4j.Logger;

import com.metavize.mvvm.networking.NetworkSettingsListener;
import com.metavize.mvvm.networking.IntfEnumListener;


class NetworkingManagerImpl implements NetworkingManager
{
    // These are the predefined ones.  There can be others.
    private static final String HEADER         = "##AUTOGENERATED BY METAVIZE DO NOT MODIFY MANUALLY\n\n";
    private static final String BUNNICULA_BASE = System.getProperty( "bunnicula.home" );
    private static final String BUNNICULA_CONF = System.getProperty( "bunnicula.conf.dir" );

    private static final String BUNNICULA_RESET_SCRIPT = BUNNICULA_BASE + "/mvvm_restart.sh";
    private static final String SSH_ENABLE_SCRIPT      = BUNNICULA_BASE + "/ssh_enable.sh";
    private static final String SSH_DISABLE_SCRIPT     = BUNNICULA_BASE + "/ssh_disable.sh";
    private static final String DHCP_RENEW_SCRIPT      = BUNNICULA_BASE + "/networking/dhcp-renew";

    private static final String IP_CFG_FILE    = "/etc/network/interfaces";
    private static final String NS_CFG_FILE    = "/etc/resolv.conf";
    private static final String FLAGS_CFG_FILE = "/networking.sh";
    private static final String SSHD_PID_FILE  = "/var/run/sshd.pid";

    private static final String NS_PARAM       = "nameserver";

    private static final String FLAG_TCP_WIN   = "TCP_WINDOW_SCALING_EN";
    private static final String FLAG_HTTP_IN   = "MVVM_ALLOW_IN_HTTP";
    private static final String FLAG_HTTPS_OUT = "MVVM_ALLOW_OUT_HTTPS";
    private static final String FLAG_HTTPS_RES = "MVVM_ALLOW_OUT_RES";
    private static final String FLAG_OUT_NET   = "MVVM_ALLOW_OUT_NET";
    private static final String FLAG_OUT_MASK  = "MVVM_ALLOW_OUT_MASK";
    private static final String FLAG_EXCEPTION = "MVVM_IS_EXCEPTION_REPORTING_EN";
    private static final String FLAG_POST_FUNC = "MVVM_POST_CONF";
    private static final String POST_FUNC_NAME =  "postConfigurationScript";
    /* Functionm declaration for the post configuration function */
    private static final String DECL_POST_CONF = "function " + POST_FUNC_NAME + "() {";

    private static final String PROPERTY_FILE       = BUNNICULA_CONF + "/mvvm.networking.properties";
    private static final String PROPERTY_HTTPS_PORT = "mvvm.https.port";
    private static final String PROPERTY_COMMENT    = "Properties for the networking configuration";

    private static final Logger logger = Logger.getLogger( NetworkingManagerImpl.class );

    private static NetworkingManagerImpl INSTANCE = new NetworkingManagerImpl();

    /* A cache of the current configuration */
    NetworkingConfiguration configuration = null;

    private IntfEnum intfEnum;

    /**
     * Retrieve the current network configuration
     */
    public synchronized NetworkingConfiguration get()
    {
        /* Retrieve all of the networking parameters */
        refresh();

        /* Return a copy of the current configuration */
        /* XXX Need to make a copy */
        return configuration;
    }

    /**
     * Set a network configuration.
     * @param configuration - Configuration to save
     */
    public synchronized void set( NetworkingConfiguration netConfig ) throws ValidateException
    {
        /* Validate the networking configuration before saving it. */
        netConfig.validate();

        /* If the configuration is null */
        if (( this.configuration != null ) && ( this.configuration.equals( netConfig ))) {
            return; // if NetworkingConfiguration has not changed, do nothing
        }

        configuration = netConfig;

        save();

        try {
            MvvmContextFactory.context().argonManager().loadNetworkingConfiguration( netConfig );
        } catch ( Exception ex ) {
            logger.error( "Unable to load networking configuration", ex );
        }
    }

    private NetworkingManagerImpl()
    {
    }

    private void refresh()
    {
        /* Create a new network configuration with all defaults */
        this.configuration = new NetworkingConfigurationImpl();

        /* Retrieve the DHCP configuration */
        getInterface();
        buildIntfEnum();
        getNameservers();
        getFlags();
        getHttpsPort();
        getSsh();
    }

    private void getInterface()
    {
        getDhcp();

        ArgonManager argon = ArgonManagerImpl.getInstance();

        configuration.host( new IPaddr((Inet4Address)argon.getOutsideAddress()));
        configuration.netmask( new IPaddr((Inet4Address)argon.getOutsideNetmask()));
        configuration.gateway( new IPaddr((Inet4Address)Netcap.getGateway()));

        List<InterfaceAlias> list = new LinkedList<InterfaceAlias>();
        /* XXX Should be exposed in the manager, but the the InterfaceData from jnetcap has
         * to be exposed */
        for ( InterfaceData data : ((ArgonManagerImpl)argon).getOutsideAliasList()) {
            list.add( new InterfaceAlias( data.getAddress(), data.getNetmask(), data.getBroadcast()));
        }
        configuration.setAliasList( list );
    }

    private void getDhcp()
    {
        BufferedReader in = null;

        /* Open up the interfaces file */
        try {
            in = new BufferedReader( new FileReader( IP_CFG_FILE ));
            String str;
            while ((str = in.readLine()) != null) {
                str = str.trim();
                if ( str.startsWith( "iface br0" )) {
                    if ( str.contains( "dhcp" )) {
                        configuration.isDhcpEnabled( true );
                    }
                }
            }
        } catch ( Exception ex ) {
            logger.error( "Error reading file: ", ex );
        }

        close( in );
    }

    private void getNameservers()
    {
        BufferedReader in = null;

        /* Open up the interfaces file */
        try {
            in = new BufferedReader(new FileReader( NS_CFG_FILE ));
            String str;
            while ((str = in.readLine()) != null) {
                str = str.trim();
                if ( str.startsWith( NS_PARAM )) {
                    IPaddr dns = IPaddr.parse( str.substring( NS_PARAM.length() ));

                    if ( configuration.dns1().isEmpty()) {
                        configuration.dns1( dns );
                    } else {
                        configuration.dns2( dns );
                        break;
                    }
                }
            }
        } catch ( Exception ex ) {
            logger.error( "Error reading file: ", ex );
        }

        close( in );
    }

    private void getFlags()
    {
        String host = null;
        String mask = null;

        /* Open up the interfaces file */
        try {
            BufferedReader in = new BufferedReader(new FileReader( BUNNICULA_CONF + FLAGS_CFG_FILE ));
            String str;
            while ((str = in.readLine()) != null) {
                str = str.trim();
                try {
                    /* Skip comments and empty lines */
                    if (( str.startsWith( "#" )) || ( str.length() == 0 )) {
                        continue;
                    } else if ( str.startsWith( FLAG_TCP_WIN )) {
                        configuration.isTcpWindowScalingEnabled( parseBooleanFlag( str, FLAG_TCP_WIN ));
                    } else if ( str.startsWith( FLAG_HTTP_IN )) {
                        configuration.isInsideInsecureEnabled( parseBooleanFlag( str, FLAG_HTTP_IN ));
                    } else if ( str.startsWith( FLAG_HTTPS_OUT )) {
                        configuration.isOutsideAccessEnabled( parseBooleanFlag( str, FLAG_HTTPS_OUT ));
                    } else if ( str.startsWith( FLAG_HTTPS_RES )) {
                        configuration.isOutsideAccessRestricted( parseBooleanFlag( str, FLAG_HTTPS_RES ));
                    } else if ( str.startsWith( FLAG_OUT_NET )) {
                        host = str.substring( FLAG_OUT_NET.length() + 1 );
                    } else if ( str.startsWith( FLAG_OUT_MASK )) {
                        mask = str.substring( FLAG_OUT_MASK.length() + 1 );
                    } else if ( str.startsWith( FLAG_EXCEPTION )) {
                        configuration.isExceptionReportingEnabled( parseBooleanFlag( str, FLAG_EXCEPTION ));
                    } else if ( str.startsWith( FLAG_POST_FUNC )) {
                        /* Nothing to do here, this is just here to indicate that a
                         * postConfiguration function exists */
                    } else if ( str.equals( DECL_POST_CONF )) {
                        parsePostConfigurationScript( in );
                    }
                } catch ( Exception ex ) {
                    logger.warn( "Error while retrieving flags", ex );
                }
            }
            in.close();
        } catch ( FileNotFoundException ex ) {
            logger.warn( "Could not read '" + BUNNICULA_CONF + FLAGS_CFG_FILE +
                         "' because it doesn't exist" );
        } catch ( Exception ex ) {
            logger.warn( "Error reading file: ", ex );
        }

        try {
            if ( host != null ) {
                configuration.outsideNetwork( IPaddr.parse( host ));

                if ( mask != null ) configuration.outsideNetmask( IPaddr.parse( mask ));
            }
        } catch ( Exception ex ) {
            logger.error( "Error parsing outside host or netmask", ex );
        }
    }

    /* Parse the input stream until it reaches the end of the function */
    private void parsePostConfigurationScript( BufferedReader in )
        throws IOException
    {
        String command;
        StringBuilder sb = new StringBuilder();

        boolean isComplete = false;

        while (( command = in.readLine()) != null ) {
            command = command.trim();

            if ( command.equals( "}" )) {
                isComplete = true;
                break;
            }

            sb.append( command + "\n" );
        }

        if ( isComplete ) {
            configuration.setPostConfigurationScript( sb.toString().trim());
        } else {
            logger.warn( "Invalid post configuration script: " + sb.toString());
        }
    }

    private Boolean parseBooleanFlag( String nameValuePair, String name )
    {
        if ( nameValuePair.length() < name.length() + 1 )
            return null;

        nameValuePair = nameValuePair.substring( name.length() + 1 );
        return Boolean.parseBoolean( nameValuePair );
    }

    private void getSsh()
    {
        /* SSH is enabled if and only if this file exists */
        File sshd = new File( SSHD_PID_FILE );

        configuration.isSshEnabled( sshd.exists());
    }

    private void save()
    {
        saveInterfaces();
        saveNameservers();
        try {
            saveHttpsPort();
        } catch ( Exception e ) {
            logger.error( "Exception saving https port", e );
        }
        saveFlags();
        saveSsh();
    }

    private void saveInterfaces()
    {
        StringBuilder sb = new StringBuilder();

        sb.append( HEADER );
        sb.append( "# The loopback network interface\n" );
        sb.append( "auto lo\n" );
        sb.append( "auto br0\n" );
        sb.append( "iface lo inet loopback\n\n# The bridge interface\n" );

        if ( configuration.isDhcpEnabled()) {
            sb.append( "iface br0 inet dhcp\n" );
        } else {
            sb.append( "iface br0 inet static\n" );
            sb.append( "\taddress " + configuration.host()    + "\n" );
            sb.append( "\tnetmask " + configuration.netmask() + "\n" );
            sb.append( "\tgateway " + configuration.gateway() + "\n" );
        }

        sb.append( "\tbridge_ports all\n" );
        sb.append( "\tbridge_maxwait 0\n" );

        int c = 0;
        for ( InterfaceAlias alias : configuration.getAliasList()) {
            if ( !alias.isValid()) {
                logger.warn( "Ignoring an invalid alias" );
                continue;
            }
            String aliasName = "br0:" + c++;

            /* Indicate that the alias should be configured at startup */
            sb.append( "\nauto " + aliasName + "\n" );

            /* Write out the alias configuration */
            sb.append( "iface " + aliasName + " inet static\n" );
            sb.append( "\taddress " + alias.getAddress() + "\n" );
            sb.append( "\tnetmask " + alias.getNetmask() + "\n" );
            sb.append( "\n\n" );
        }

        writeFile( sb, IP_CFG_FILE );
        writeFile( sb, BUNNICULA_CONF + IP_CFG_FILE );
    }

    private void saveNameservers() {
        StringBuilder sb = new StringBuilder();

        if ( configuration.isDhcpEnabled())
            return;

        sb.append( HEADER );
        sb.append( NS_PARAM + " " + configuration.dns1() + "\n" );

        /* Set the System property for DNS */

        if ( !configuration.dns2().isEmpty())
            sb.append( NS_PARAM + " " + configuration.dns2() + "\n" );

        /* XXX write both files */
        writeFile( sb, NS_CFG_FILE );
        writeFile( sb, BUNNICULA_CONF + NS_CFG_FILE );
    }

    private void saveFlags() {
        StringBuilder sb = new StringBuilder();

        sb.append( "#!/bin/sh\n" );
        sb.append( HEADER + "\n" );
        sb.append( "## Set to true to enable\n" );
        sb.append( "## false or undefined is disabled.\n" );
        sb.append( FLAG_TCP_WIN + "=" + configuration.isTcpWindowScalingEnabled() + "\n\n" );
        sb.append( "## Allow inside HTTP true to enable\n" );
        sb.append( "## false or undefined is disabled.\n" );
        sb.append( FLAG_HTTP_IN + "=" + configuration.isInsideInsecureEnabled() + "\n\n" );
        sb.append( "## Allow outside HTTPS true to enable\n" );
        sb.append( "## false or undefined to disable.\n" );
        sb.append( FLAG_HTTPS_OUT + "=" + configuration.isOutsideAccessEnabled() + "\n\n" );
        sb.append( "## Restrict outside HTTPS access\n" );
        sb.append( "## True if restricted, undefined or false if unrestricted\n" );
        sb.append( FLAG_HTTPS_RES + "=" + configuration.isOutsideAccessRestricted() + "\n\n" );
        sb.append( "## Report exceptions\n" );
        sb.append( "## True to send out exception logs, undefined or false for not\n" );
        sb.append( FLAG_EXCEPTION + "=" + configuration.isExceptionReportingEnabled() + "\n\n" );

        if ( !configuration.outsideNetwork().isEmpty()) {
            IPaddr network = configuration.outsideNetwork();
            IPaddr netmask = configuration.outsideNetmask();

            sb.append( "## If outside access is enabled and restricted, only allow access from\n" );
            sb.append( "## this network.\n" );

            sb.append( FLAG_OUT_NET + "=" + network + "\n" );

            if ( !netmask.isEmpty()) {
                sb.append( FLAG_OUT_MASK + "=" + netmask + "\n" );
            }
            sb.append( "\n" );
        }

        if ( configuration.getPostConfigurationScript().length() > 0 ) {
            sb.append( "## Script to be executed after the bridge configuration script is executed\n" );
            sb.append( DECL_POST_CONF + "\n" );
            /* The post configuration script should be an object, allowing it to
             * be prevalidated */
            sb.append( configuration.getPostConfigurationScript().toString().trim() + "\n" );
            sb.append( "}\n" );

            sb.append( "## Flag to indicate that there is a post configuuration script\n" );
            sb.append( FLAG_POST_FUNC + "=" + POST_FUNC_NAME + "\n\n" );
        }

        writeFile( sb, BUNNICULA_CONF + FLAGS_CFG_FILE );
    }

    private void getHttpsPort()
    {
        /* Try to read in the properties for the HTTPS port */
        configuration.httpsPort( NetworkingConfigurationImpl.DEF_HTTPS_PORT );

        try {
            Properties properties = new Properties();
            File f = new File( PROPERTY_FILE );
            if ( f.exists()) {
                logger.debug( "Loading " + f );
                properties.load( new FileInputStream( f ));

                String temp = properties.getProperty( PROPERTY_HTTPS_PORT );
                if ( temp != null ) {
                    configuration.httpsPort( Integer.parseInt( temp ));
                    logger.debug( "Found HTTPS port " + configuration.httpsPort());
                }
            }
        } catch ( Exception e ) {
            logger.warn( "Unable to load properties file: " + PROPERTY_FILE, e );
            configuration.httpsPort( NetworkingConfigurationImpl.DEF_HTTPS_PORT );
        }
    }

    private void saveHttpsPort() throws Exception
    {

        /* rebind the https port */
        MvvmContextFactory.context().appServerManager().rebindExternalHttpsPort(
          configuration.httpsPort());

//        ((MvvmContextImpl)MvvmContextFactory.context()).getMain().
//            rebindExternalHttpsPort( configuration.httpsPort());

        Properties properties = new Properties();
        // if ( configuration.httpsPort() != NetworkingConfigurationImpl.DEF_HTTPS_PORT ) {
            /* Make sure to write the file anyway, this guarantees that if the property
             * is already set, it gets overwritten with an empty value */
        // }

        /* Maybe only store this value if it has been changed */
        properties.setProperty( PROPERTY_HTTPS_PORT, String.valueOf( configuration.httpsPort()));

        try {
            logger.debug( "Storing properties into: " + PROPERTY_FILE + "[" + configuration.httpsPort()
                          + "]" );
            properties.store( new FileOutputStream( new File( PROPERTY_FILE )), PROPERTY_COMMENT );
        } catch ( Exception e ) {
            logger.error( "Error saving HTTPS port" );
        }

        logger.debug( "Rebinding the HTTPS port" );
    }

    private void saveSsh()
    {
        try {
            if ( configuration.isSshEnabled()) {
                MvvmContextFactory.context().exec( SSH_ENABLE_SCRIPT );
            } else {
                MvvmContextFactory.context().exec( SSH_DISABLE_SCRIPT );
            }
        } catch ( Exception ex ) {
            logger.error( "Unable to configure ssh", ex );
        }
    }

    private void writeFile( StringBuilder sb, String fileName )
    {
        BufferedWriter out = null;

        /* Open up the interfaces file */
        try {
            String data = sb.toString();

            out = new BufferedWriter(new FileWriter( fileName ));
            out.write( data, 0, data.length());
        } catch ( Exception ex ) {
            /* XXX May need to catch this exception, restore defaults
             * then try again */
            logger.error( "Error writing file " + fileName + ":", ex );
        }

        close( out );
    }

    /* Get the external HTTPS port */
    public int getExternalHttpsPort()
    {
        /* Only refresh if the configuration is null, otherwise */
        if ( this.configuration == null ) refresh();

        /* Just in case */
        if ( this.configuration == null ) {
            logger.warn( "NULL Settings after a refresh, using defaults", new Exception());
            return 443;
        }

        /* This doesn't query the file, it just grabs the port */
        return this.configuration.httpsPort();
    }


    static NetworkingManagerImpl getInstance()
    {
        return INSTANCE;
    }

    private void close( BufferedReader buf )
    {
        try {
            if ( buf != null )
                buf.close();
        } catch ( Exception ex ) {
            logger.error( "Unable to close file", ex );
        }
    }

    private void close( BufferedWriter buf )
    {
        try {
            if ( buf != null )
                buf.close();
        } catch ( Exception ex ) {
            logger.error( "Unable to close file", ex );
        }
    }

    public NetworkingConfiguration renewDhcpLease() throws Exception {
        /* Renew the address */
        Process p = MvvmContextFactory.context().exec( "sh " + DHCP_RENEW_SCRIPT );

        if ( p.waitFor() != 0 ) {
            throw new MvvmException( "Error while Renewing DHCP Lease" );
        }

        /* Update the address and generate new rules */
        MvvmContextFactory.context().argonManager().updateAddress();

        /* Return a new copy of the Networking configuration */
        return get();
    }

    public IntfEnum getIntfEnum()
    {
        return intfEnum;
    }

    public void registerNetworkSettingsListener( NetworkSettingsListener listener )
    {
        
    }

    public void registerIntfEnumListener( IntfEnumListener listener )
    {

    }
    
    void buildIntfEnum()
    {
        IntfConverter converter = IntfConverter.getInstance();
        if ( converter == null ) { /* Running in fake mode */
            logger.info( "Running in fake mode, using internal and external" );
            intfEnum = new IntfEnum( new byte[]   { IntfConstants.EXTERNAL_INTF,
                                                    IntfConstants.INTERNAL_INTF },
                                     new String[] { IntfConstants.EXTERNAL,
                                                    IntfConstants.INTERNAL } );
            return;
        }

        byte[] argonIntfArray = converter.argonIntfArray();

        String[] intfNameArray = new String[argonIntfArray.length];

        for ( int c = 0; c < argonIntfArray.length ; c++ ) {
            String name = "unknown";
            byte intf = argonIntfArray[c];
            switch ( intf ) {
            case IntfConstants.EXTERNAL_INTF: name = IntfConstants.EXTERNAL; break;
            case IntfConstants.INTERNAL_INTF: name = IntfConstants.INTERNAL; break;
            case IntfConstants.DMZ_INTF:      name = IntfConstants.DMZ;      break;
            case IntfConstants.VPN_INTF:      name = IntfConstants.VPN;      break;
            default:
                logger.error( "Unknown interface: " + intf + " using unknown" );
            }

            intfNameArray[c] = name;
        }

        intfEnum = new IntfEnum( argonIntfArray, intfNameArray );

        IntfMatcherFactory.getInstance().updateEnumeration( intfEnum );
    }
}
