/*
 * Copyright (c) 2003, 2005 Metavize Inc.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Metavize Inc. ("Confidential Information").  You shall
 * not disclose such Confidential Information.
 *
 *  $Id$
 */

package com.metavize.mvvm.argon;

import java.io.BufferedWriter;
import java.io.FileWriter;

import java.net.InetAddress;

import org.apache.log4j.Logger;

import com.metavize.mvvm.NetworkingConfiguration;
import com.metavize.mvvm.InterfaceAlias;

/**
 * This is going to have to get more complicated down the line, which is why this functionality 
 * was broken out of the ArgonManagerImpl.
 */
class BridgeConfigurationManager
{
    private static final BridgeConfigurationManager INSTANCE  = new BridgeConfigurationManager();

    private static final String BUNNICULA_BASE    = System.getProperty( "bunnicula.home" );
    private static final String BRIDGE_CFG_SCRIPT = BUNNICULA_BASE + "/networking/bridge-configure";

    private static final String BUNNICULA_CONF    = System.getProperty( "bunnicula.conf.dir" );
    private static final String BRIDGE_CFG_FILE   = BUNNICULA_CONF + "/bridge-settings";
    
    private static final String COMMENT            = "## ";
    private static final String SCRIPT_HEADER      = "#!/bin/sh\n\n#AUTOGENERATED BY METAVIZE DO NOT MODIFY";
    private static final String NAT_NAME           = "NAT";
    private static final String BRIDGE_NAME        = "MAIN_BRIDGE";
    private static final String OUTSIDE_NAME       = "OUTSIDE";
    private static final String ALIAS_NAME         = "OUTSIDE_ALIAS";
    private static final String BRIDGE_LIST_SEP    = " ";
    private static final String INTF_LIST_SEP      = " ";
    private static final String TYPE_SUFFIX        = "type";
    private static final String TYPE_BRIDGE        = "bridge";
    // Not a very good name for a non-bridge
    private static final String TYPE_POINT         = "point";
    private static final String BRIDGE_NAME_SUFFIX = "name";
    private static final String PORT_SUFFIX        = "port";
    private static final String PORT_LIST_SUFFIX   = "ports";
    private static final String ADDRESS_SUFFIX     = "address";
    private static final String NETMASK_SUFFIX     = "netmask";
    private static final String BROADCAST_SUFFIX   = "broadcast";
    private static final String DHCP_SUFFIX        = "dhcp";
    private static final String DHCP_FLAG          = "true";
    private static final String GATEWAY_VARIABLE   = "GATEWAY";
    private static final String INTF_LIST_VARIABLE = "INTERFACE_LIST";
    
        
    private boolean     isNatEnabled     = false;
    private InetAddress natInsideAddress = null;
    private InetAddress natInsideNetmask = null;

    /* An interface that the inside if set the inside is bridged with */
    private String internalBridgeIntf = "";

    private final Logger logger = Logger.getLogger( this.getClass());

    private BridgeConfigurationManager()
    {
    }

    void reconfigureBridge( NetworkingConfiguration netConfig ) throws ArgonException
    {
        if ( isNatEnabled ) {
            /* XXX Test me */
            ArgonManagerImpl argonManager = ArgonManagerImpl.getInstance();
            InetAddress insideAddress = argonManager.getInsideAddress();
            InetAddress insideNetmask = argonManager.getInsideNetmask();

            if ( !natInsideAddress.equals( insideAddress )) {
                logger.error( "Nat inside address(" + natInsideAddress + ") does not equal current " + 
                              "inside address(" + insideAddress + ")" );
            }
            
            if ( !natInsideNetmask.equals( insideNetmask )) {
                logger.error( "Nat inside netmask(" + natInsideNetmask + ") does not equal current " + 
                              "inside netmask(" + insideNetmask + ")" );
            }
        }

        writeConfiguration( netConfig );

        /* Call the reconfiguraion script */
        reconfigure();
    }

    /* Break down the bridge, (Only useful for NAT)
     * This will automatically update the iptables rules
     */
    synchronized void destroyBridge( NetworkingConfiguration netConfig, InetAddress insideAddress, 
                                     InetAddress insideNetmask ) throws ArgonException
    {
        this.isNatEnabled = true;
        this.natInsideAddress = insideAddress;
        this.natInsideNetmask = insideNetmask;
        
        /* Write the new configuration */
        writeConfiguration( netConfig );
        
        /* Call the reconfiguraion script */
        reconfigure();
    }

    synchronized void argonRestoreBridge( NetworkingConfiguration netConfig ) throws ArgonException
    {
        /* Nothing to do, bridge was never modified */
        if ( !this.isNatEnabled && ( this.internalBridgeIntf.length() == 0 )) {
            logger.debug( "Bridge was already enabled and VPN was not inserted, ignoring" );
            return;
        }

        this.internalBridgeIntf = "";
        
        restoreBridge( netConfig );
    }

    /* Restore the bridge, (only useful for NAT)
     * This will automatically update the iptables rules
     */
    synchronized void restoreBridge( NetworkingConfiguration netConfig ) throws ArgonException
    {
        this.isNatEnabled = false;
        this.natInsideAddress = null;
        this.natInsideNetmask = null;
        
        /* Write the new configuration */
        writeConfiguration( netConfig );
        
        /* Call the reconfiguraion script */
        reconfigure();
    }

    synchronized void setInternalBridgeIntf( NetworkingConfiguration netConfig, String intf )
        throws ArgonException
    {
        /* XXX Probably should make sure that this is not one of the inside interfaces */
        this.internalBridgeIntf = intf;
        reconfigureBridge( netConfig );
    }

    synchronized void clearInternalBridgeIntf( NetworkingConfiguration netConfig )
        throws ArgonException
    {
        if ( this.internalBridgeIntf.length() == 0 ) {
            logger.debug( "Ignorning clear internal bridge interface because it doesn't exist" );
            return;
        }

        this.internalBridgeIntf = "";
        reconfigureBridge( netConfig );
    }

    
    static BridgeConfigurationManager getInstance()
    {
        return INSTANCE;
    }

    private void reconfigure()  throws ArgonException
    {
        /* Call the rule generator */
        try {
            Process p = Runtime.getRuntime().exec( "sh " + BRIDGE_CFG_SCRIPT );
            
            if ( p.waitFor() != 0 ) throw new ArgonException( "Error while configuring bridge" );
        } catch ( ArgonException e ) {
            throw e;
        } catch( Exception e ) {
            throw new ArgonException( "Error while restoring bridge", e );
        }
    }
    
    /* Write out the configuration for the bridge */
    /* XXX This really only works for two cases All bridged, and NAT on inside with outside/dmz bridged,
     *     This will work for the case where there is not a DMZ */
    private void writeConfiguration( NetworkingConfiguration netConfig ) throws ArgonException
    {
        StringBuilder sb = new StringBuilder();
        IntfConverter intfConverter = IntfConverter.getInstance();

        /* List of interfaces configured */
        String interfaceList = "";
        
        appendLine( sb, SCRIPT_HEADER + "\n\n" );

        String bridgeInterfaceList = "";
        
        /* Retrieve the interface strings for inside, outside and DMZ */
        String inside  = intfConverter.argonIntfToString( IntfConverter.INSIDE );
        String outside = intfConverter.argonIntfToString( IntfConverter.OUTSIDE );
        String dmz     = intfConverter.argonIntfToString( IntfConverter.DMZ );
        if ( dmz == null ) dmz = "";
                
        if ( this.isNatEnabled ) {
            bridgeInterfaceList = outside;
            
            /* Inside interface cannot use DHCP, this may change for more advanced 
             * routing */
            appendComment  ( sb, "Nat configuration" );
            if ( this.internalBridgeIntf.length() > 0 ) {
                appendComment  ( sb, "Nat configuration, bridged with " + this.internalBridgeIntf );
                appendParameter( sb, NAT_NAME, TYPE_SUFFIX,      TYPE_BRIDGE );
                appendParameter( sb, NAT_NAME, PORT_LIST_SUFFIX, 
                                 inside + BRIDGE_LIST_SEP + this.internalBridgeIntf );
                /* XXX Hardwired to be br1 */
                appendParameter( sb, NAT_NAME, BRIDGE_NAME_SUFFIX, "br1" );
            } else {
                appendParameter( sb, NAT_NAME, TYPE_SUFFIX,    TYPE_POINT );
                appendParameter( sb, NAT_NAME, PORT_SUFFIX,    inside );            
            }
            appendParameter( sb, NAT_NAME, ADDRESS_SUFFIX, natInsideAddress.getHostAddress());
            appendParameter( sb, NAT_NAME, NETMASK_SUFFIX, natInsideNetmask.getHostAddress() );
            interfaceList = NAT_NAME;

        } else {
            /* Join the bridge interface list */
            bridgeInterfaceList = outside + BRIDGE_LIST_SEP + inside;

            if ( this.internalBridgeIntf.length() > 0 ) {
                bridgeInterfaceList += BRIDGE_LIST_SEP + this.internalBridgeIntf;
            }
        }
                
        /* Append the DMZ to the bridge interface list */
        if ( dmz.length() > 0 ) bridgeInterfaceList += BRIDGE_LIST_SEP + dmz;
        
        sb.append( "\n\n" );
        /* Check if there is only the outside interface interface in the bridge list.
         * (no need for a bridge) */
        String name = "";
        String outsideInterfaceName = "";
        if ( bridgeInterfaceList.equals( outside )) {
            name = OUTSIDE_NAME;
            appendComment  ( sb, "Outside interface configuration" );
            appendParameter( sb, name, TYPE_SUFFIX, TYPE_POINT );
            appendParameter( sb, name, PORT_SUFFIX, outside );            
            outsideInterfaceName = outside;
        } else {
            name = BRIDGE_NAME;
            appendComment  ( sb, "Main bridge configuration" );
            appendParameter( sb, name, TYPE_SUFFIX,      TYPE_BRIDGE );
            appendParameter( sb, name, PORT_LIST_SUFFIX, bridgeInterfaceList );
            /* XXX Hardwired to be br0 */
            appendParameter( sb, name, BRIDGE_NAME_SUFFIX, "br0" );
            outsideInterfaceName = "br0";
        }

        if ( netConfig.isDhcpEnabled()) {
            appendParameter( sb, name, DHCP_SUFFIX, DHCP_FLAG );            
        } else {
            String outsideAddress = netConfig.host().getAddr().getHostAddress();
            String outsideNetmask = netConfig.netmask().getAddr().getHostAddress();
            String gateway        = netConfig.gateway().getAddr().getHostAddress();
            
            appendParameter( sb, name, ADDRESS_SUFFIX, outsideAddress );
            appendParameter( sb, name, NETMASK_SUFFIX, outsideNetmask );
            appendVariable ( sb, GATEWAY_VARIABLE, gateway );
            sb.append( "\n\n" );
        }
        
        /* Add the outside interface to the list of configured interfaces */
        interfaceList = name + INTF_LIST_SEP + interfaceList;

        int c = 0;
        for ( InterfaceAlias alias : netConfig.getAliasList()) {
            String aliasName = ALIAS_NAME + "_" + c;
            String aliasInterfaceName = outsideInterfaceName + ":" + c;

            if ( !alias.isValid()) {
                logger.info( "Ignoring invalid alias" );
                continue;
            }
            
            appendComment( sb, "Outside interface alias #" + c );
            appendParameter( sb, aliasName, TYPE_SUFFIX, TYPE_POINT );
            appendParameter( sb, aliasName, PORT_SUFFIX, aliasInterfaceName );
            appendParameter( sb, aliasName, ADDRESS_SUFFIX, alias.getAddress().toString());
            appendParameter( sb, aliasName, NETMASK_SUFFIX, alias.getNetmask().toString());
            
            // Append the alias to the list of interfaces
            interfaceList += INTF_LIST_SEP + aliasName;
            c++;
        }

        
        sb.append( "\n\n" );

        appendComment ( sb, "The list of configured interfaces" );
        appendVariable( sb, INTF_LIST_VARIABLE, interfaceList );
        
        writeFile( sb, BRIDGE_CFG_FILE );
    }        
    
    /** Kind of a silly helper functions to avoid "\n" everywhere " */
    private void appendLine( StringBuilder sb, String text )
    {
        sb.append( text + "\n" );
    }

    private void appendComment( StringBuilder sb, String text )
    {
        for ( String line : text.split( "\n" )) sb.append( COMMENT + line + "\n" );
    }

    private void appendParameter( StringBuilder sb, String prefix, String type, String value )
    {
        appendLine( sb, prefix + "_" + type + "=\"" + value + "\"" );
    }

    private void appendVariable( StringBuilder sb, String variable, String value )
    {
        appendLine( sb, variable + "=\"" + value + "\"" );
    }

    private void writeFile( StringBuilder sb, String fileName ) 
    {
        BufferedWriter out = null;
        
        /* Open up the interfaces file */
        try {
            String data = sb.toString();
            
            out = new BufferedWriter(new FileWriter( fileName ));
            out.write( data, 0, data.length());
        } catch ( Exception ex ) {
            /* XXX May need to catch this exception, restore defaults
             * then try again */
            logger.error( "Error writing file " + fileName + ":", ex );
        }
        
        try {
            if ( out != null ) out.close();
        } catch ( Exception ex ) {
            logger.error( "Unable to close file", ex );
        }
    }
}
