#!/bin/sh
#
# Copyright (c) 2003, 2004, 2005 Metavize Inc.
# All rights reserved.
#
# This software is the confidential and proprietary information of
# Metavize Inc. ("Confidential Information").  You shall
# not disclose such Confidential Information.
#
# $Id: mkg,v 1.12 2005/03/23 06:06:18 amread Exp $
#

exec 2>&1

prefix=@PREFIX@
pkglist=@FAKE_PKG_LIST@
instlist=@FAKE_INST_LIST@
APT_LOG=@PREFIX@/var/log/mvvm/apt.log

INST_OPTS=" -o DPkg::Options::=--force-confnew --yes --force-yes --fix-broken "
UPGD_OPTS=" -o DPkg::Options::=--force-confnew --yes --force-yes --fix-broken "
UPDT_OPTS=" --yes --force-yes "
REMO_OPTS=" --yes --force-yes --fix-broken --purge "
DEBUG_OPTS=" -o Debug::pkgDPkgPM=true "
RET=0

printusage()
{
    echo "usage:"
    echo "mkg installed"
    echo "mkg available"
    echo "mkg install <mackage>"
    echo "mkg update"
    echo "mkg upgrade"
    echo "mkg remove"
    exit 1
}

aptlog()
{
        echo -e "----------" >>$APT_LOG
        while [ 0 -lt $# ]; do
            echo $1 >>$APT_LOG
            shift
        done
        date >>$APT_LOG
        echo -e "----------\n" >>$APT_LOG
}

my_dpkg_query()
{
    PKGS="`dpkg --get-selections $1 | egrep 'install$' | awk '{print $1}'`"
    if [ ! -z "$PKGS" ] ; then
        echo "$PKGS" | xargs dpkg-query -W
    fi
}

while getopts k: f; do
  case $f in
      k) stamp=$OPTARG
  esac
done
shift $(expr $OPTIND - 1)

if [ $# -lt 1 ] ; then
    printusage
fi

if [ -z $prefix ] ; then
    # invoked in real environment
    if [ "$1" = "installed" ] ; then
        (my_dpkg_query '*-transform'
            my_dpkg_query '*-casing' ;
            my_dpkg_query 'metavize-client';
            my_dpkg_query 'mvvm') 2>/dev/null \
                | awk '{ if ($2) printf("%s %s\n",$1,$2) }'
        #RET=$? return code ignored
    elif [ "$1" = "available" ] ; then
        pkgs=$(apt-cache search '.-transform$|.-casing$|^mvvm$|^metavize-client$'\
            | cut -d ' ' -f 1)
        for pkg in $pkgs; do
            apt-cache show --no-all-versions $pkg
            #RET=$? return code ignored
        done
    elif [ "$1" = "install" ] ; then
        aptlog "start $stamp"

        aptlog "downloading: \"$2-transform\""
        # XXX the way i create mackage name is wrong:
        aptlist=$(mktemp)

        apt-get install $INST_OPTS --print-uris "$2-transform" \
            | awk " /^'http:\\/\\// { print \$0 } " >$aptlist

        cat $aptlist >>$APT_LOG
        echo "END PACKAGE LIST" >>$APT_LOG

        for u in $(cat $aptlist | awk '{ print $1 }' | sed "s/'//g"); do
            echo "downloading: $u" >>$APT_LOG
            dltmp=$(mktemp -d)
            wget --progress=dot -P "$dltmp" "$u" >>$APT_LOG 2>&1
            if [ $? -eq 0 ]; then
                mv $dltmp/* /var/cache/apt/archives
                echo "DOWNLOAD SUCCEEDED: $u" >>$APT_LOG
            else
                echo "DOWNLOAD FAILED: $u" >>$APT_LOG
            fi
            rm -r $dltmp
        done

        aptlog "installing: \"$2-transform\""
        # XXX the way i create mackage name is wrong:
        apt-get install $INST_OPTS "$2-transform" >>$APT_LOG 2>&1
        RET=$?

        aptlog "done $stamp"

    elif [ "$1" = "update" ] ; then
        aptlog "start $tstamp" "apt-get update $UPDT_OPTS"
        apt-get update $UPDT_OPTS >>$APT_LOG 2>&1
        #RET=$? return code ignored
        aptlog "done $stamp"
    elif [ "$1" = "upgrade" ] ; then
        aptlog "start $stamp"  "apt-get upgrade $UPGD_OPTS"

        t0=$(stat -L -c %Y /vmlinuz)
        apt-get dist-upgrade $UPGD_OPTS >>$APT_LOG 2>&1
        RET=$?
        t1=$(stat -L -c %Y /vmlinuz)

        if [ $t0 -ne $t1 ]; then
            aptlog "new kernel, rebooting"
            reboot
        fi

        aptlog "done $stamp"
    elif [ "$1" = "remove" ] ; then
        aptlog "start $stamp" "apt-get remove $REMO_OPTS \"$2-transform\""
        apt-get remove $REMO_OPTS "$2-transform" >>$APT_LOG 2>&1
        RET=$?
        aptlog "done $stamp"
    fi
else
    # invoked in development environment
    if [ "$1" = "installed" ] ; then
        cat $pkglist | awk ' /^Package: / { print $2 " 10.0" } '
    elif [ "$1" = "install" ] ; then
        aptlog "start $stamp"
        echo "END PACKAGE LIST" >>$APT_LOG
        aptlog "done $stamp"
    elif [ "$1" = "update" ] ; then
        : # XXX
    elif [ "$1" = "upgrade" ] ; then
        aptlog "start $stamp"
        echo "END PACKAGE LIST" >>$APT_LOG
        aptlog "done $stamp"
    elif [ "$1" = "remove" ] ; then
        echo "remove not supported in build environment"
    elif [ "$1" = "available" ] ; then
        cat $pkglist | sed -e 's/^XB-//' \
            | awk '{ print $0 }; /^Package: / { print "Version: 10.0" }'
    fi
fi

exit $RET