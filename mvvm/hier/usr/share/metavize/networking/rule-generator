#!/bin/sh

exec >> @MVVM_LOG@/iptables.log 2>&1

RULE_CONFIG_FILE=@MVVM_HOME@/networking/rule-config
FUNCTIONS_FILE=@MVVM_HOME@/networking/functions

if [ -r ${RULE_CONFIG_FILE}  ]; then
    . ${RULE_CONFIG_FILE}
else
    echo "Unable to load the rule configuration file ${RULE_CONFIG_FILE}"
    exit -2
fi

if [ -r ${FUNCTIONS_FILE} ]; then
    . ${FUNCTIONS_FILE}
else
    echo "Unable to load the functions file ${FUNCTIONS_FILE}"
    exit -1
fi

echo "Reconstructing all of the tables"

MARK_ANTISUB="0x01000000"
MARK_NOTRACK="0x02000000"
MARK_LOCAL="0x00001000"

## This is not the interface index (1,2,3, etc), this is the special bit that
## is set to indicate that the traffic entered on the inside interface.
## This makes all of the guard rules a little bit easier to deal with
MARK_INSIDE_INTF="0x00002000"

## These are the marks and interfaces for VPN traffic.
VPN_TUN_INTF="tun0"
VPN_TUN_MARK="0x4"

VPN_TAP_INTF="tap0"
VPN_TAP_MARK="0x5"

MARK_LOCAL_ADDRESS_BASE="0x00000010"

## This list must get longer when there are more interfaces
INTERFACE_ORDER="${MVVM_OUTSIDE_INTF} ${MVVM_INSIDE_INTF} ${MVVM_DMZ_INTF}"

## List of ICMP types to antisubscribe to.
ANTISUBSCRIBES_ICMP="parameter-problem source-quench fragmentation-needed"

FLAG_INSIDE_INTF="inside"
FLAG_OUTSIDE_INTF="outside"
FLAG_BOTH_INTF="both"

## DHCP Port range 
DHCP_SERVER_PORT="67"
DHCP_CLIENT_PORT="68"
DHCP_PORT_RANGE="${DHCP_SERVER_PORT}:${DHCP_CLIENT_PORT}"

function flush() {
    ## Always flush intercepting first to avoid a few errant packets flying in unmarked.
    ${IPTABLES} -t mangle -F ${CHAIN_INTERCEPT}
    for table in ${TABLE_LIST}; do 
        ${IPTABLES} -t ${table} -F 
    done
}

## This creates the foundation
function buildFoundation() {
    ## Flush out the prerouting table
    ${IPTABLES} -t mangle -F PREROUTING

    ## Create the sub tables and insert the rules into the PREROUTING table to link
    for chain in ${CHAINS_ORDER} ; do
        ${IPTABLES} -t mangle -N ${chain} 2> /dev/null
        ${IPTABLES} -t mangle -F ${chain}
        ${IPTABLES} -t mangle -A PREROUTING -j ${chain}
    done
}

function blockForwarding() {
    local l_outFlag
    local l_inFlag
    local l_modules

    ## Flush the forward table
    ${IPTABLES} -t filter -F FORWARD
    
    ## Block non-antisubscribed TCP traffic from being forwarded
    ${IPTABLES} -t filter -A FORWARD -m mark -p tcp --mark 0/${MARK_ANTISUB} \
        -j REJECT --reject-with tcp-reset

    if [ "${DHCP_BLOCK_FORWARDING}x" = "truex" ]; then
        if [ -z `getBridge ${MVVM_INSIDE_INTF}` ]; then
            l_modules=" "
            l_inFlag=" -i "
            l_outFlag=" -o "
        else
            l_modules=" -m physdev "
            l_inFlag=" --physdev-in "
            l_outFlag=" --physdev-out "
        fi
        
        ## Block forwarded DHCP traffic to the inside interface
        ${IPTABLES} ${l_modules} -t filter -A FORWARD -p udp --source-port ${DHCP_PORT_RANGE} \
            --destination-port ${DHCP_PORT_RANGE} ${l_outFlag} ${MVVM_INSIDE_INTF} -j DROP
        
        ## Block forwarded DHCP traffic from the inside interface
        ${IPTABLES} ${l_modules} -t filter -A FORWARD -p udp --source-port ${DHCP_PORT_RANGE} \
            --destination-port ${DHCP_PORT_RANGE} ${l_inFlag} ${MVVM_INSIDE_INTF} -j DROP
        
        ## Drop anything to the DHCP server that is not from the inside interface
        ${IPTABLES} ${l_modules} -t filter -A INPUT ! ${l_inFlag} ${MVVM_INSIDE_INTF} -p udp  \
            --destination-port ${DHCP_SERVER_PORT} -j DROP
    fi
}

function guardRules() {
    ## Flush the guard table
    ${IPTABLES} -t mangle -F ${CHAIN_GUARDS}

    ## Return for anything that is not local
    ${IPTABLES} -t mangle -A ${CHAIN_GUARDS} -m mark --mark 0/${MARK_LOCAL} -j RETURN
    
    ## Drop stuff going to the UDP divert port from outside.
    ${IPTABLES} -t mangle -A ${CHAIN_GUARDS} -p udp -m mark --mark ${MARK_LOCAL}/${MARK_LOCAL} \
        --destination-port ${UDP_DIVERT_PORT} -j DROP

    ## Drop stuff going to the TCP redirect ports from the outside
    ${IPTABLES} -t mangle -A ${CHAIN_GUARDS} -p tcp -m mark --mark ${MARK_LOCAL}/${MARK_LOCAL} \
        --destination-port ${TCP_REDIRECT_PORTS} -j DROP

    ## Insert all of the guards for outside and inside
    for ports in ${GUARD_OUTSIDE_UDP_PORTS}; do
        generateGuardRule udp $ports ${FLAG_OUTSIDE_INTF}
    done

    for ports in ${GUARD_OUTSIDE_TCP_PORTS}; do
        generateGuardRule tcp $ports ${FLAG_OUTSIDE_INTF}
    done

    for ports in ${GUARD_INSIDE_UDP_PORTS}; do
        generateGuardRule udp $ports ${FLAG_INSIDE_INTF}
    done

    for ports in ${GUARD_INSIDE_TCP_PORTS}; do
        generateGuardRule tcp $ports ${FLAG_INSIDE_INTF}
    done

    for ports in ${GUARD_BOTH_UDP_PORTS}; do
        echo "UNSUPPORTED: udp guard both ports ${ports}"
        generateGuardRule udp $ports ${FLAG_BOTH_INTF}
    done

    for ports in ${GUARD_BOTH_TCP_PORTS}; do
        echo "UNSUPPORTED: tcp guard both ports ${ports}"
        generateGuardRule tcp $ports ${FLAG_BOTH_INTF}
    done
}

## internal function to generate one guard rule
## $1: Ports (either comma separated, dash seperated (range) or no separator (one port)
## $2: Protocol
## $3: "inside","outside" or "both"
function generateGuardRule() {
    protocol=$1
    ports=$2
    intf=$3
    
    if [ "${ports}x" = "x" ]; then
        echo "Ignoring empty ports string"
    fi
        
    regulated=${ports#*_}
    
    if [ "${regulated}x" != "${ports}x" ]; then
        ports=${ports%_*}
        regulated="-s ! ${regulated}"
    else
        regulated=""
    fi
    
    ## This will have to be pushed into each guard rule when there are more than two interfaces.x
    if [ "${intf}x" == "${FLAG_INSIDE_INTF}x" ]; then
        mark=${MARK_INSIDE_INTF}
        markMask=${MARK_INSIDE_INTF}
    elif [ "${intf}x" == "${FLAG_OUTSIDE_INTF}x" ]; then
        ## This is actually anything but the inside
        mark=0
        markMask=${MARK_INSIDE_INTF}
    elif [ "${intf}x" == "${FLAG_BOTH_INTF}x" ]; then
        ## This would be anything that is local(local is guaranteed by the return rule at the top)
        mark=0
        markMask=0
    else
        echo "Unable to determine which interface to put the guard for ports $ports protocol $protocol"
        return
    fi
    
    if [ "${regulated}x" != "x" ]; then
        ${IPTABLES} -t mangle -A ${CHAIN_GUARDS} -p ${protocol} ${regulated} \
            -m mark --mark ${mark}/${markMask} \
            --destination-port ${ports} -j DROP
    elif [ "$(echo $ports | grep ',')x" != "x" ]; then
        ${IPTABLES} -t mangle -A ${CHAIN_GUARDS} -p ${protocol} -m multiport ${regulated} \
            -m mark --mark ${mark}/${markMask} \
            --destination-ports ${ports} -j DROP
    else
        ${IPTABLES} -t mangle -A ${CHAIN_GUARDS} -p ${protocol} ${regulated} \
            -m mark --mark ${mark}/${markMask} \
            --destination-port ${ports} -j DROP
    fi
}

function markIntfRules () {
    local c
    local d
    local mask
    local interface
    local addresses

    ## Flush the interface marking table
    ${IPTABLES} -t mangle -F ${CHAIN_MARKINTF}
    
    c=1
    for interface in ${INTERFACE_ORDER} ; do
        if [ -z "`getBridge $interface`" ]; then
            addresses=`getAddresses $interface`
            matchType="-i "
            #echo "${addresses}"
            #echo `getNetmasks $interface`
        else
            addresses=`getBridgeAddresses $interface`
            matchType="-m physdev --physdev-in "
            #echo "${addresses}"
            #echo `getBridgeNetmasks $interface`
        fi

        if [ "${c}x" == "2x" ]; then
            ## Set the special flag for inside traffic
            mask=$(( ${c} | ${MARK_INSIDE_INTF} ))
        else
            mask=${c}
        fi

        ${IPTABLES} -t mangle -A ${CHAIN_MARKINTF} ${matchType} ${interface} -j MARK --set-mark ${mask}
        
        d=${MARK_LOCAL_ADDRESS_BASE}
        for address in $addresses; do
            ${IPTABLES} -t mangle -A ${CHAIN_MARKINTF} ${matchType} ${interface} --destination ${address} \
                -j MARK --set-mark $(( ${mask} | $d | ${MARK_LOCAL} ))
            d="$(( $d + ${MARK_LOCAL_ADDRESS_BASE} ))"
        done
        c=$(( $c + 1 ))
    done

    ## Mark any vpn traffic if necessary
    markIntfVpn
}

function markIntfVpn() {
    local l_interface=""
    local l_matchType=""

    ## Always use the TUN mark, there isn't really a reason to have two
    local l_mark=$(( ${VPN_TUN_MARK} | ${MARK_INSIDE_INTF} ))
    local l_addresses
    local l_address
    
    ## Not really worried about local traffic to the VPN, just vector it.
    if [  -d "${SYSFS_INTERFACE_PATH}/${VPN_TUN_INTF}" ]; then
        l_interface=${VPN_TUN_INTF}
        l_matchType="-i"
        l_addresses="`getActualAddresses ${l_interface}` `getActualAddresses ${MVVM_INSIDE_INTF}`"
    fi
    
    if [ -d "${SYSFS_INTERFACE_PATH}/${VPN_TAP_INTF}" ]; then
        if [ -n "${l_interface}" ]; then
            echo "error, TUN and TAP interface are configured, using TUN"
        else 
            l_interface=${VPN_TAP_INTF}
            l_matchType="-m physdev --physdev-in "

            ## It is bridged, so you only need the local address
            l_addresses="`getActualAddresses ${l_interface}`"
        fi
    fi
    
    ## Nothing to do if neither of the interfaces are configured
    if [ -z "${l_interface}" ]; then return ; fi
    
    ## Mark all packets that come in on on the VPN interface
    ${IPTABLES} -t mangle -A ${CHAIN_MARKINTF} ${l_matchType} ${l_interface} -j MARK --set-mark ${l_mark}

    d=${MARK_LOCAL_ADDRESS_BASE}
    for l_address in ${l_addresses}; do
        ${IPTABLES} -t mangle -A ${CHAIN_MARKINTF} ${l_matchType} ${l_interface} --destination ${l_address} \
            -j MARK --set-mark $(( ${l_mark} | ${d} | ${MARK_LOCAL} ))
        d=$(( ${d} + ${MARK_LOCAL_ADDRESS_BASE} ))
    done
}


function rawRules() {
    ## Flush the raw table
    ${IPTABLES} -t raw -F

    ## Insert the no track rule
    ${IPTABLES} -t raw -A OUTPUT -m mark -j NOTRACK --mark ${MARK_NOTRACK}/${MARK_NOTRACK}
}

function antisubscribeRules() {
    ## flush the antisubscribe chain
    ${IPTABLES} -t mangle -F ${CHAIN_ANTISUB}

    ## antisubscribe to related non-tcp packets
    ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -m state -m mark -p ! tcp --mark 0/${MARK_ANTISUB} \
        --state related,established -j MARK --set-mark ${MARK_ANTISUB}

    ## Antisubscribe to localhost
    ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -m mark --mark 0/${MARK_ANTISUB} \
        --source 127.0.0.0/8 --destination 127.0.0.0/8 -j MARK --set-mark ${MARK_ANTISUB}

    ## Determine whether or not to antisubscribe to local traffic
    antisubscribeLocalTraffic ${FLAG_OUTSIDE_INTF} ${ANTISUBSCRIBE_LOCAL_OUTSIDE}
    antisubscribeLocalTraffic ${FLAG_INSIDE_INTF}  ${ANTISUBSCRIBE_LOCAL_INSIDE}

    ## Antisubscribe to the locally requested traffic
    for c_portList in ${ANTISUBSCRIBES_LOCAL_TCP_PORTS}; do
        antisubscribeLocal "tcp" ${c_portList}
    done
    
    for c_portList in ${ANTISUBSCRIBES_LOCAL_UDP_PORTS}; do
        antisubscribeLocal "udp" ${c_portList}
    done
    
    ## antisubscribe to unwanted ICMP
    for icmpType in ${ANTISUBSCRIBES_ICMP} ; do
        ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -p icmp -m mark --mark 0/${MARK_ANTISUB} \
            --icmp-type ${icmpType} -j MARK --set-mark ${MARK_ANTISUB}
    done

    ## Antisubscribe to DHCP
    ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -p udp -m mark --mark 0/${MARK_ANTISUB} \
        --source-port ${DHCP_PORT_RANGE} --destination-port ${DHCP_PORT_RANGE} \
        -j MARK --set-mark ${MARK_ANTISUB}
        
}

function antisubscribeLocal() {
    local t_protocol=$1
    local t_portList=$2
    local t_mark

    if [ -n ${t_portList} ]; then
        ## Check if antisubscribing on only one interface
        t_intf=${t_portList#*_}
        if [ "${t_intf}x" != "${t_portList}x" ]; then
            t_portList=${t_portList%_*}
            if [ "${t_intf}x" == "${FLAG_INSIDE_INTF}x" ]; then
                t_mark=2
            elif [ "${t_intf}x" == "${FLAG_OUTSIDE_INTF}x" ]; then
                t_mark=1
            else
                echo "Unable to determine which interface to antisubscribe  for ${t_protocol} ${t_portList}"
                return
            fi
            
            t_mark=$(( ${t_mark} | ${MARK_LOCAL} ))
            t_markMask=$(( ${MARK_ANTISUB} | ${MARK_LOCAL} | 0xF ))
        else
            t_mark=${MARK_LOCAL}
            t_markMask=$(( ${MARK_ANTISUB} | ${MARK_LOCAL} ))
        fi

        ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -m multiport -m mark -p ${t_protocol}  \
            --destination-ports ${t_portList} --mark ${t_mark}/${t_markMask} \
            -j MARK --set-mark ${MARK_ANTISUB}
    else
        echo "No local antisubscribes for ${protocol}"
    fi
}

## Antisubscribe to all local traffic on a particular interface
function antisubscribeLocalTraffic() {
    local t_intf=$1
    local t_flag=$2
    local t_mark

    if [  "${t_flag}x" = "truex" ]; then
        if [ "${t_intf}x" == "${FLAG_INSIDE_INTF}x" ]; then
            t_mark=2
        elif [ "${t_intf}x" == "${FLAG_OUTSIDE_INTF}x" ]; then
            t_mark=1
        else
            echo "Unable to determine which interface ${t_intf} to antisubscribe to"
            return
        fi

        t_mark=$(( ${t_mark} | ${MARK_LOCAL} ))
        t_markMask=$(( ${MARK_ANTISUB} | ${MARK_LOCAL} | 0xF ))

        ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -m mark --mark ${t_mark}/${t_markMask} \
            -j MARK --set-mark ${MARK_ANTISUB}
    fi
}

## intercept everything and then use antisubscribes to not intercept certain packets
function interceptRules() {
## Flush the intercept chain
    ${IPTABLES} -t mangle -F ${CHAIN_INTERCEPT}

## If the packet is antisubscribed, return
    ${IPTABLES} -t mangle -A ${CHAIN_INTERCEPT} -m mark --mark ${MARK_ANTISUB}/${MARK_ANTISUB} -j RETURN
    
## Queue all packets for TCP and ICMP
    ${IPTABLES} -t mangle -A ${CHAIN_INTERCEPT} -p tcp --tcp-flags SYN,ACK SYN -j QUEUE
    
    ${IPTABLES} -t mangle -A ${CHAIN_INTERCEPT} -p icmp -j QUEUE

## Divert all of the UDP traffic
    if [ "${UDP_DIVERT_PORT}x" != "x" ]; then
        ${IPTABLES} -t mangle -A ${CHAIN_INTERCEPT} -p udp -j DIVERT --to-port ${UDP_DIVERT_PORT}
    fi

## Redirect all of the TCP traffic that is not antisubscribed
    if [ "${TCP_REDIRECT_PORTS}x" != "x" ]; then
        ${IPTABLES} -t nat -A PREROUTING -m mark --mark 0/${MARK_ANTISUB} -p tcp --tcp-flags SYN,ACK SYN \
            -j REDIRECT --to-ports ${TCP_REDIRECT_PORTS/:/-}
    else
        echo "The TCP Redirect port is not set"
    fi
}

function uturnRules() {
    c=1
    for interface in ${INTERFACE_ORDER}; do
        if [ -z `getBridge $interface` ]; then
            matchType="-o "
        else
            matchType="-m physdev --physdev-out"
        fi
        
        ${IPTABLES} -t filter -A OUTPUT -m mark ${matchType} ${interface} --mark ${c}/0xF -j DROP
        c=$(( $c + 1 ))
    done
}

###############################################################
######### Start of script #####################################
###############################################################
generateConfiguration

flush

buildFoundation

blockForwarding

guardRules

markIntfRules

rawRules

antisubscribeRules

uturnRules

interceptRules

