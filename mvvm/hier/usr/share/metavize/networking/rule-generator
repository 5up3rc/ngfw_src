#!/bin/sh

exec >> @MVVM_LOG@/iptables.log 2>&1

RULE_CONFIG_FILE=@MVVM_HOME@/networking/rule-config
FUNCTIONS_FILE=@MVVM_HOME@/networking/functions

if [ -r ${RULE_CONFIG_FILE}  ]; then
    . ${RULE_CONFIG_FILE}
else
    echo "Unable to load the rule configuration file ${RULE_CONFIG_FILE}"
    exit -2
fi

if [ -r ${FUNCTIONS_FILE} ]; then
    . ${FUNCTIONS_FILE}
else
    echo "Unable to load the functions file ${FUNCTIONS_FILE}"
    exit -1
fi

echo "Reconstructing all of the tables"

MARK_ANTISUB="0x01000000"
MARK_NOTRACK="0x02000000"
MARK_INTERNAL_REDIRECT="0x04000000"
MARK_DHCP_SERVER_ANTISUB="0x08000000"
MARK_LIBERATE="0x10000000"
MARK_LOCAL="0x00001000"
MARK_INTF_MASK="0xF" ## Mask to use when testing the interface

## this is the liberate mark plus the antisubscribe mark, both bits
## must always be set together.
MARK_LIBERATE=$(( ${MARK_ANTISUB} | ${MARK_LIBERATE} ))

## This is not the interface index (1,2,3, etc), this is the special bit that
## is set to indicate that the traffic entered on the inside interface.
## This makes all of the guard rules a little bit easier to deal with
MARK_INSIDE_INTF="0x00002000"

## These are the marks and interfaces for VPN traffic.
VPN_TUN_INTF="tun0"
VPN_TUN_MARK="0x4"

VPN_TAP_INTF="tap0"
VPN_TAP_MARK="0x5"

MARK_LOCAL_ADDRESS_BASE="0x00000010"

## This list must get longer when there are more interfaces
INTERFACE_ORDER="${MVVM_EXTERNAL_INTF} ${MVVM_INTERNAL_INTF} ${MVVM_DMZ_INTF}"

## List of ICMP types to antisubscribe to.
ANTISUBSCRIBES_ICMP="parameter-problem source-quench fragmentation-needed"

FLAG_INSIDE_INTF="inside"
FLAG_OUTSIDE_INTF="outside"
FLAG_BOTH_INTF="both"

## DHCP Port range 
DHCP_SERVER_PORT="67"
DHCP_CLIENT_PORT="68"
DHCP_PORT_RANGE="${DHCP_SERVER_PORT}:${DHCP_CLIENT_PORT}"

## This creates the foundation
function buildFoundation() {
    ## Flush out the prerouting table
    ${IPTABLES} -t mangle -F PREROUTING

    ## Create the sub tables and insert the rules into the PREROUTING table to link
    for chain in ${CHAINS_ORDER} ; do
        ${IPTABLES} -t mangle -N ${chain} 2> /dev/null
        ${IPTABLES} -t mangle -F ${chain}
        ${IPTABLES} -t mangle -A PREROUTING -j ${chain}
    done
}

function blockForwarding() {
    local l_outFlag
    local l_inFlag
    local l_modules
    local l_interface

    ## Flush the tables for input and forwarding.
    ${IPTABLES} -t filter -F FORWARD
    ${IPTABLES} -t mangle -F FORWARD
    ${IPTABLES} -t filter -F INPUT
    ${IPTABLES} -t mangle -F INPUT

    ## create the liberation chain
    ${IPTABLES} -t filter -N ${CHAIN_LIBERATION} 2> /dev/null
    ${IPTABLES} -t filter -F ${CHAIN_LIBERATION}

    ## connmark all traffic that enters and exits from the same interface.
    for l_interface in ${INTERFACE_ORDER}  ; do 
        if [ -z `getBridge ${l_interface}` ]; then
            l_modules=" "
            l_inFlag=" -i "
            l_outFlag=" -o "            
        else
            l_modules=" -m physdev "
            l_inFlag=" --physdev-in "
            l_outFlag=" --physdev-out "            
        fi
        
        ${IPTABLES} -t filter -A FORWARD ${l_modules} ${l_inFlag} ${l_interface} \
            ${l_outFlag} ${l_interface} -g ${CHAIN_LIBERATION}
    done
    
    ## connmark all antisubscribed packets in the liberation chain, done this way
    ## because some packets cannot be connmarked, but shouldn't hit they shouldn't hit
    ## the rejection rules that are past these rules.
    ${IPTABLES} -t filter -A ${CHAIN_LIBERATION} -j CONNMARK --set-mark ${MARK_ANTISUB}/${MARK_ANTISUB}
    
    ## Block non-antisubscribed TCP traffic from being forwarded
    ${IPTABLES} -t filter -A FORWARD -m mark -p tcp --mark 0/${MARK_ANTISUB} \
        -j REJECT --reject-with tcp-reset

    if [ "${DHCP_BLOCK_FORWARDING}x" = "truex" ]; then
        ## Block DHCP traffic from being forwarded to interfaces in the services
        ## spaces.
        for l_interface in ${MVVM_SERVICES_INTF_LIST} ; do
            if [ -z `getBridge ${l_interface}` ]; then
                l_modules=" "
                l_inFlag=" -i "
                l_outFlag=" -o "
            else
                l_modules=" -m physdev "
                l_inFlag=" --physdev-in "
                l_outFlag=" --physdev-out "
            fi
            
            ## Block forwarded DHCP traffic to the inside interface
            ${IPTABLES} ${l_modules} -t filter -A FORWARD -p udp --source-port ${DHCP_PORT_RANGE} \
                --destination-port ${DHCP_PORT_RANGE} ${l_outFlag} ${l_interface} -j DROP
            
            ## Block forwarded DHCP traffic from the inside interface
            ${IPTABLES} ${l_modules} -t filter -A FORWARD -p udp --source-port ${DHCP_PORT_RANGE} \
                --destination-port ${DHCP_PORT_RANGE} ${l_inFlag} ${l_interface} -j DROP
            
            ## antisub anything to the DHCP server that is from one of these interfaces.
            ## The logic is, apply the DHCP antisub to the traffic that the DHCP server should see
            ## At the end, use the another rule to DROP any traffic (on the INPUT chain) 
            ## that the DHCP server should not see.
            ${IPTABLES} ${l_modules} -t mangle -A INPUT ${l_inFlag} ${l_interface} -p udp \
                --destination-port ${DHCP_SERVER_PORT} \
                -j MARK --or-mark $(( ${MARK_ANTISUB} | ${MARK_DHCP_SERVER_ANTISUB} ))
        done
        
        ## Drop any DHCP traffic that didn't get antisubscribed.
        ${IPTABLES} -t mangle -A INPUT -p udp  \
            --destination-port ${DHCP_SERVER_PORT} -m mark --mark 0/${MARK_DHCP_SERVER_ANTISUB} -j DROP
    fi
}

function guardRules() {
    ## Flush the guard table
    ${IPTABLES} -t mangle -F ${CHAIN_GUARDS}

    ## Return for anything that is not local
    ${IPTABLES} -t mangle -A ${CHAIN_GUARDS} -m mark --mark 0/${MARK_LOCAL} -j RETURN
    
    ## Drop stuff going to the UDP divert port from outside.
    ${IPTABLES} -t mangle -A ${CHAIN_GUARDS} -p udp -m mark --mark ${MARK_LOCAL}/${MARK_LOCAL} \
        --destination-port ${UDP_DIVERT_PORT} -j DROP

    ## Drop stuff going to the TCP redirect ports from the outside
    ${IPTABLES} -t mangle -A ${CHAIN_GUARDS} -p tcp -m mark --mark ${MARK_LOCAL}/${MARK_LOCAL} \
        --destination-port ${TCP_REDIRECT_PORTS} -j DROP

    ## Insert all of the guards for outside and inside
    for ports in ${GUARD_OUTSIDE_UDP_PORTS}; do
        generateGuardRule udp $ports ${FLAG_OUTSIDE_INTF}
    done

    for ports in ${GUARD_OUTSIDE_TCP_PORTS}; do
        generateGuardRule tcp $ports ${FLAG_OUTSIDE_INTF}
    done

    for ports in ${GUARD_INSIDE_UDP_PORTS}; do
        generateGuardRule udp $ports ${FLAG_INSIDE_INTF}
    done

    for ports in ${GUARD_INSIDE_TCP_PORTS}; do
        generateGuardRule tcp $ports ${FLAG_INSIDE_INTF}
    done

    for ports in ${GUARD_BOTH_UDP_PORTS}; do
        echo "UNSUPPORTED: udp guard both ports ${ports}"
        generateGuardRule udp $ports ${FLAG_BOTH_INTF}
    done

    for ports in ${GUARD_BOTH_TCP_PORTS}; do
        echo "UNSUPPORTED: tcp guard both ports ${ports}"
        generateGuardRule tcp $ports ${FLAG_BOTH_INTF}
    done
}

## internal function to generate one guard rule
## $1: Ports (either comma separated, dash seperated (range) or no separator (one port)
## $2: Protocol
## $3: "inside","outside" or "both"
function generateGuardRule() {
    protocol=$1
    ports=$2
    intf=$3
    
    if [ "${ports}x" = "x" ]; then
        echo "Ignoring empty ports string"
    fi
        
    regulated=${ports#*_}
    
    if [ "${regulated}x" != "${ports}x" ]; then
        ports=${ports%_*}
        regulated="-s ! ${regulated}"
    else
        regulated=""
    fi
    
    ## This will have to be pushed into each guard rule when there are more than two interfaces.x
    if [ "${intf}x" == "${FLAG_INSIDE_INTF}x" ]; then
        mark=${MARK_INSIDE_INTF}
        markMask=${MARK_INSIDE_INTF}
    elif [ "${intf}x" == "${FLAG_OUTSIDE_INTF}x" ]; then
        ## This is actually anything but the inside
        mark=0
        markMask=${MARK_INSIDE_INTF}
    elif [ "${intf}x" == "${FLAG_BOTH_INTF}x" ]; then
        ## This would be anything that is local(local is guaranteed by the return rule at the top)
        mark=0
        markMask=0
    else
        echo "Unable to determine which interface to put the guard for ports $ports protocol $protocol"
        return
    fi
    
    if [ "${regulated}x" != "x" ]; then
        ${IPTABLES} -t mangle -A ${CHAIN_GUARDS} -p ${protocol} ${regulated} \
            -m mark --mark ${mark}/${markMask} \
            --destination-port ${ports} -j DROP
    elif [ "$(echo $ports | grep ',')x" != "x" ]; then
        ${IPTABLES} -t mangle -A ${CHAIN_GUARDS} -p ${protocol} -m multiport ${regulated} \
            -m mark --mark ${mark}/${markMask} \
            --destination-ports ${ports} -j DROP
    else
        ${IPTABLES} -t mangle -A ${CHAIN_GUARDS} -p ${protocol} ${regulated} \
            -m mark --mark ${mark}/${markMask} \
            --destination-port ${ports} -j DROP
    fi
}

function markIntfRules () {
    local c
    local d
    local mask
    local interface
    local addresses

    ## Flush the interface marking table
    ${IPTABLES} -t mangle -F ${CHAIN_MARKINTF}

    ## Clear the lower bits of the interface mark
    ${IPTABLES} -t mangle -A ${CHAIN_MARKINTF} -j MARK --and-mark 0xFFFF0000
    
    c=1
    for interface in ${INTERFACE_ORDER} ; do
        if [ -z "`getBridge $interface`" ]; then
            addresses=`getAddresses $interface`
            matchType="-i "
            #echo "${addresses}"
            #echo `getNetmasks $interface`
        else
            addresses=`getBridgeAddresses $interface`
            matchType="-m physdev --physdev-in "
            #echo "${addresses}"
            #echo `getBridgeNetmasks $interface`
        fi
        
        mask=${c}

        ## The services list determine which interfaces get the inside_intf flag.
        if [ "${MVVM_SERVICES_INTF_LIST/${interface}/}x" != "${MVVM_SERVICES_INTF_LIST}x" ]; then
            mask=$(( ${mask} | ${MARK_INSIDE_INTF} ))
        fi

        ${IPTABLES} -t mangle -A ${CHAIN_MARKINTF} ${matchType} ${interface} -j MARK --or-mark ${mask}
        
        d=${MARK_LOCAL_ADDRESS_BASE}
        for address in $addresses; do
            ${IPTABLES} -t mangle -A ${CHAIN_MARKINTF} ${matchType} ${interface} --destination ${address} \
                -j MARK --or-mark $(( ${mask} | $d | ${MARK_LOCAL} ))
            d="$(( $d + ${MARK_LOCAL_ADDRESS_BASE} ))"
        done
        c=$(( $c + 1 ))
    done

    ## Mark any vpn traffic if necessary
    markIntfVpn
}

function markIntfVpn() {
    local l_interface=""
    local l_matchType=""

    ## Always use the TUN mark, there isn't really a reason to have a separate one for tap vs tun.
    local l_mark=$(( ${VPN_TUN_MARK} | ${MARK_INSIDE_INTF} ))
    local l_addresses
    local l_address
    
    ## Not really worried about local traffic to the VPN, just vector it.
    if [  -d "${SYSFS_INTERFACE_PATH}/${VPN_TUN_INTF}" ]; then
        l_interface=${VPN_TUN_INTF}
        l_matchType="-i"
        l_addresses="`getActualAddresses ${l_interface}` `getActualAddresses ${MVVM_INTERNAL_INTF}`"
    fi
    
    if [ -d "${SYSFS_INTERFACE_PATH}/${VPN_TAP_INTF}" ]; then
        if [ -n "${l_interface}" ]; then
            echo "error, TUN and TAP interface are configured, using TUN"
        else 
            l_interface=${VPN_TAP_INTF}
            l_matchType="-m physdev --physdev-in "

            ## It is bridged, so you only need the local address
            l_addresses="`getActualAddresses ${l_interface}`"
        fi
    fi
    
    ## Nothing to do if neither of the interfaces are configured
    if [ -z "${l_interface}" ]; then return ; fi
    
    ## Mark all packets that come in on on the VPN interface
    ${IPTABLES} -t mangle -A ${CHAIN_MARKINTF} ${l_matchType} ${l_interface} -j MARK --or-mark ${l_mark}

    d=${MARK_LOCAL_ADDRESS_BASE}
    for l_address in ${l_addresses}; do
        ${IPTABLES} -t mangle -A ${CHAIN_MARKINTF} ${l_matchType} ${l_interface} --destination ${l_address} \
            -j MARK --or-mark $(( ${l_mark} | ${d} | ${MARK_LOCAL} ))
        d=$(( ${d} + ${MARK_LOCAL_ADDRESS_BASE} ))
    done
}


function rawRules() {
    ## Flush the raw table
    ${IPTABLES} -t raw -F

    ## Insert the no track rule
    ${IPTABLES} -t raw -A OUTPUT -m mark -j NOTRACK --mark ${MARK_NOTRACK}/${MARK_NOTRACK}
}

function antisubscribeRules() {
    local t_mark
    local t_mask
    local pingList=${MVVM_PING_LIST}
    local t_httpsPorts

    ## flush the antisubscribe chain
    ${IPTABLES} -t mangle -F ${CHAIN_ANTISUB}

    ## antisubscribe to related non-tcp packets
    ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -m state -m mark -p ! tcp --mark 0/${MARK_ANTISUB} \
        --state related,established -j MARK --or-mark ${MARK_ANTISUB}

    ## antisubscribe to ping packet with a length of 37(actual 65 because 37 + 8 + 20),
    ## these are used by the GUI
    ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -p icmp --icmp-type echo-reply  -m length --length 65 \
        -m mark --mark ${MARK_LOCAL}/$(( ${MARK_LOCAL} | ${MARK_ANTISUB} )) \
        -j MARK --or-mark ${MARK_ANTISUB}

    ## Antisubscribe to localhost
    ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -m mark --mark 0/${MARK_ANTISUB} \
        --source 127.0.0.0/8 --destination 127.0.0.0/8 -j MARK --or-mark ${MARK_ANTISUB}

    ## Antisubscribe to ping where necessary, if it isn't set, 
    ## Antisubscribe on all interfaces. (default is a little janky.)

    ## If unset, then use default
    if [ "x${MVVM_PING_EN}" != "xtrue" ]; then
        pingList="1 2 3"
    fi

    antisubscribeLocalPing ${pingList}

    ## Determine whether or not to antisubscribe to local traffic
    antisubscribeLocalTraffic ${FLAG_OUTSIDE_INTF} ${ANTISUBSCRIBE_LOCAL_OUTSIDE}
    antisubscribeLocalTraffic ${FLAG_INSIDE_INTF}  ${ANTISUBSCRIBE_LOCAL_INSIDE}
    
    if [ -n "${HTTPS_INTERNAL_REDIRECT_PORT}" ]; then
    ## Redirect HTTPS packets to the special port
        t_httpsPorts=${HTTPS_PORT}
        
        if [ -n "${outsideHttpsPort}" ] && [ "${t_httpsPort}" != "${outsideHttpsPort}" ]; then
            t_httpsPorts="${t_httpsPorts},${outsideHttpsPort}"
        fi
        
        ## This is the mask for the next check
        t_mark="$(( ${MARK_ANTISUB} | ${MARK_INSIDE_INTF} | ${MARK_LOCAL} ))"
        ## This tells to antisubscribe, and mark as internal redirect any local packet
        ## going to the local HTTPS ports.  These get redirected later
        ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -p tcp \
            -m mark --mark "$(( ${MARK_INSIDE_INTF} | ${MARK_LOCAL} ))/${t_mark}" \
            -m multiport --destination-ports ${t_httpsPorts} \
            -j MARK --or-mark $(( ${MARK_ANTISUB} | ${MARK_INTERNAL_REDIRECT} ))
    fi
    
    ## This rule will often be unecessary, but it is there just in case.
    ## if the public address is ever different than the box address, these are different.    
    if [ -n "${HTTPS_PUBLIC_ADDR}" ] && [ -n "${HTTPS_PUBLIC_PORT}" ]; then
        ## The first one is for traffic on the inside interface
        ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -p tcp \
            -m mark --mark "${MARK_INSIDE_INTF}/$(( ${MARK_ANTISUB} | ${MARK_INSIDE_INTF} ))" \
            --destination ${HTTPS_PUBLIC_ADDR} \
            --destination-port ${HTTPS_PUBLIC_PORT} \
            -j MARK --or-mark $(( ${MARK_ANTISUB} | ${MARK_INTERNAL_REDIRECT} ))

        ## If outside is enabled, catch everything else
        if [ "${MVVM_ALLOW_OUT_HTTPS}x" = "truex" ]; then
            ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -p tcp -m mark --mark "0/${MARK_ANTISUB}" \
                --destination ${HTTPS_PUBLIC_ADDR} \
                --destination-port ${HTTPS_PUBLIC_PORT} \
                -j MARK --or-mark ${MARK_ANTISUB}
        fi
    fi

    ## Antisubscribe to the locally requested traffic
    for c_portList in ${ANTISUBSCRIBES_LOCAL_TCP_PORTS}; do
        antisubscribeLocal "tcp" ${c_portList}
    done
    
    for c_portList in ${ANTISUBSCRIBES_LOCAL_UDP_PORTS}; do
        antisubscribeLocal "udp" ${c_portList}
    done
    
    ## antisubscribe to unwanted ICMP
    for icmpType in ${ANTISUBSCRIBES_ICMP} ; do
        ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -p icmp -m mark --mark 0/${MARK_ANTISUB} \
            --icmp-type ${icmpType} -j MARK --or-mark ${MARK_ANTISUB}
    done

    ## Antisubscribe to broadcasts and multicasts by using the MAC addreses
    ## Broadcasts
    ${EBTABLES} -t broute -A BROUTING -d Broadcast -j mark --set-mark ${MARK_ANTISUB}

    ## Multicasts
    ${EBTABLES} -t broute -A BROUTING -d 01:00:5E:00:00:00/ff:ff:ff:00:00:00 \
        -j mark --set-mark ${MARK_ANTISUB}

    ## Antisubscribe to DHCP
    ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -p udp -m mark --mark 0/${MARK_ANTISUB} \
        --source-port ${DHCP_PORT_RANGE} --destination-port ${DHCP_PORT_RANGE} \
        -j MARK --or-mark ${MARK_ANTISUB}

    ## Antisubscribe to port 137 on the inside, this is for samba broadcasts
    t_mark=$(( ${MARK_LOCAL} | ${MARK_INSIDE_INTF} ))
    t_mask=$(( ${t_mark} | ${MARK_ANTISUB} ))
    ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -p udp --source-port 137 \
        -m mark --mark ${t_mark}/${t_mask} -j MARK --or-mark ${MARK_ANTISUB}

    ## antisubscribe to connmarked packets
    ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -m connmark --mark ${MARK_ANTISUB}/${MARK_ANTISUB} \
        -j MARK --or-mark ${MARK_ANTISUB}

    ## Antisubscribe to NIS if necessary.
    if [ "x" != "x@PREFIX@" ] ; then
        ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -m mark -p udp \
            --source-port 111 --mark 0x1000/0x1001000 -j MARK --or-mark ${MARK_ANTISUB}
    fi
}

function antisubscribeLocal() {
    local t_protocol=$1
    local t_portList=$2
    local t_mark
    local t_mask

    if [ -n ${t_portList} ]; then
        ## Check if antisubscribing on only one interface
        t_intf=${t_portList#*_}
        if [ "${t_intf}x" != "${t_portList}x" ]; then
            t_portList=${t_portList%_*}
            if [ "${t_intf}x" == "${FLAG_INSIDE_INTF}x" ]; then
                t_mark=${MARK_INSIDE_INTF}
                t_mask=${MARK_INSIDE_INTF}
            elif [ "${t_intf}x" == "${FLAG_OUTSIDE_INTF}x" ]; then
                ## This is anything but the inside
                t_mark=0
                t_mask=${MARK_INSIDE_INTF}
            else
                echo "Unable to determine which interface to antisubscribe  for ${t_protocol} ${t_portList}"
                return
            fi
            
            t_mark=$(( ${t_mark} | ${MARK_LOCAL} ))
            t_markMask=$(( ${MARK_ANTISUB} | ${MARK_LOCAL} | ${t_mask} ))
        else
            t_mark=${MARK_LOCAL}
            t_markMask=$(( ${MARK_ANTISUB} | ${MARK_LOCAL} ))
        fi

        ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -m multiport -m mark -p ${t_protocol}  \
            --destination-ports ${t_portList} --mark ${t_mark}/${t_markMask} \
            -j MARK --or-mark ${MARK_ANTISUB}
    else
        echo "No local antisubscribes for ${protocol}"
    fi
}

## Antisubscribe to all local traffic on a particular interface
function antisubscribeLocalTraffic() {
    local t_intf=$1
    local t_flag=$2
    local t_mark
    local t_mask

    if [  "${t_flag}x" = "truex" ]; then
        if [ "${t_intf}x" == "${FLAG_INSIDE_INTF}x" ]; then
            t_mark=${MARK_INSIDE_INTF}
            t_mask=${MARK_INSIDE_INTF}
        elif [ "${t_intf}x" == "${FLAG_OUTSIDE_INTF}x" ]; then
            t_mark=0
            t_mask=${MARK_INSIDE_INTF}
        else
            echo "Unable to determine which interface ${t_intf} to antisubscribe to"
            return
        fi

        t_mark=$(( ${t_mark} | ${MARK_LOCAL} ))
        t_markMask=$(( ${MARK_ANTISUB} | ${MARK_LOCAL} | ${t_mask} ))

        ## Antisubscribe to all traffic but ICMP.
        ## Ping is regulated using antisubscribeLocalPing.
        ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} ! -p icmp -m mark \
            --mark ${t_mark}/${t_markMask} -j MARK --or-mark ${MARK_ANTISUB}
    fi
}

## Antisubscribe to PING for an interface()
## params:
## t_intfArray: List of interfaces to respond to PING on, these are the argon interfaces.
function antisubscribeLocalPing() {
    local t_intfList=$*
    local t_intf
    local t_mark
    local t_mask
    
    for t_intf in ${t_intfList} ; do
        ## Validate the index
        if [ -z "`isValidIntfIndex ${t_intf}`" ]; then 
            echo "'${t_intf}' is not a valid interface, continuing"
            continue ; 
        fi
        
        ## Search for packets coming in on the interface, headed locally.
        t_mark=$(( ${t_intf} | ${MARK_LOCAL} ))
        t_markMask=$(( ${MARK_INTF_MASK} | ${MARK_ANTISUB} | ${MARK_LOCAL} ))
        
        ## Antisubscribe to all echo-requests coming in on the right interface.
        ## replies are outgoing and handled by conntrack.
        ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} -p icmp --icmp-type echo-request \
            -m mark --mark ${t_mark}/${t_markMask} -j MARK --or-mark ${MARK_ANTISUB}
    done
}

## intercept everything and then use antisubscribes to not intercept certain packets
function interceptRules() {
    local t_mark
    
## Flush the intercept chain
    ${IPTABLES} -t mangle -F ${CHAIN_INTERCEPT}

## If the packet is antisubscribed, return
    ${IPTABLES} -t mangle -A ${CHAIN_INTERCEPT} -m mark --mark ${MARK_ANTISUB}/${MARK_ANTISUB} -j RETURN
    
## Queue all packets for TCP and ICMP
    ${IPTABLES} -t mangle -A ${CHAIN_INTERCEPT} -p tcp --tcp-flags SYN,ACK SYN -j NFQUEUE
    
    ${IPTABLES} -t mangle -A ${CHAIN_INTERCEPT} -p icmp -j NFQUEUE

## Divert all of the UDP traffic
    if [ "${UDP_DIVERT_PORT}x" != "x" ]; then
        ${IPTABLES} -t mangle -A ${CHAIN_INTERCEPT} -p udp -j DIVERT --to-port ${UDP_DIVERT_PORT}
    fi

## Redirect all traffic to the public address to the mvvm
    if [ -n "${HTTPS_PUBLIC_ADDR}" ] && [ -n "${HTTPS_PUBLIC_PORT}" ] &&
        [ "${HTTPS_PUBLIC_REDIRECT_EN}x" = "truex" ]; then
        t_mark="$(( ${MARK_ANTISUB} | ${MARK_INTERNAL_REDIRECT} ))"
        ## Redirect stuff to the internal interface public address to the internal port.
        ${IPTABLES} -t nat -A PREROUTING -p tcp \
            --destination ${HTTPS_PUBLIC_ADDR} \
            --destination-port ${HTTPS_PUBLIC_PORT} \
            -m mark --mark "${t_mark}/${t_mark}" \
            -j REDIRECT --to-ports ${HTTPS_INTERNAL_REDIRECT_PORT}

        ${IPTABLES} -t nat -A PREROUTING -p tcp \
            --destination ${HTTPS_PUBLIC_ADDR} \
            --destination-port ${HTTPS_PUBLIC_PORT} \
            -j REDIRECT --to-ports ${HTTPS_PORT}
    fi
    
    ## connmark all of the traffic that was unqueued or diverted.
    ## This is for situations when the choice to antisubscribe cannot
    ## be made in iptables.  for example, traffic coming and going
    ## from the same interface.
    ${IPTABLES} -t nat -A PREROUTING -m mark --mark ${MARK_LIBERATE}/${MARK_LIBERATE} \
        -j CONNMARK --set-mark ${MARK_ANTISUB}/${MARK_ANTISUB}

    ${IPTABLES} -t nat -A OUTPUT -m mark --mark ${MARK_LIBERATE}/${MARK_LIBERATE} \
        -j CONNMARK --set-mark ${MARK_ANTISUB}/${MARK_ANTISUB}
    
## Redirect all of the TCP traffic that is not antisubscribed
    if [ "${TCP_REDIRECT_PORTS}x" != "x" ]; then
        ${IPTABLES} -t nat -A PREROUTING -m mark --mark 0/${MARK_ANTISUB} -p tcp --tcp-flags SYN,ACK SYN \
            -j REDIRECT --to-ports ${TCP_REDIRECT_PORTS/:/-}
    else
        echo "The TCP Redirect port is not set"
    fi

## Redirect all of the traffic on the internal HTTPs interface to the open port.
    if [ -n "${HTTPS_INTERNAL_REDIRECT_PORT}" ]; then
        t_mark="$(( ${MARK_ANTISUB} | ${MARK_INTERNAL_REDIRECT} ))"
        ${IPTABLES} -t nat -A PREROUTING -p tcp -m mark --mark "${t_mark}/${t_mark}" \
            -j REDIRECT --to-ports "${HTTPS_INTERNAL_REDIRECT_PORT}"
    fi
}

function uturnRules() {
    c=1
    for interface in ${INTERFACE_ORDER}; do
        if [ -z `getBridge $interface` ]; then
            matchType="-o "
        else
            matchType="-m physdev --physdev-out"
        fi
        
        ${IPTABLES} -t filter -A OUTPUT -m mark ${matchType} ${interface} --mark ${c}/0xF -j DROP
        c=$(( $c + 1 ))
    done
}

## This function is designed to ARP an address on a certain interface,
## even if the address isn't configured for one of the interfaces.
## t_intf is the physical interface that the ARP is coming in on.
function stealArpAddress() {
    local t_ip=$1
    local t_intf=$2

    ## This is the bridge interface
    local t_bridge=`getBridge ${t_intf}`

    ## This is the MAC address of the bridge
    local t_macAddress

    if [ -z "${t_bridge}" ]; then
        echo "The interface ${t_intf} is not inside of a bridge, unable to steal ARP address";
        return -1
    fi
    
    t_macAddress=`getMACAddress ${t_bridge}`

    if [ -z "${t_macAddress}" ]; then
        echo "Unable to determine the MAC address for the bridge ${t_bridge}";
        return -1
    fi
    
    ${EBTABLES} -t nat -A PREROUTING -i ${t_intf} -p ARP --arp-ip-dst ${t_ip} \
        -j arpreply --arpreply-mac ${t_macAddress}
}

function setupMode()
{
    local t_port
    local t_qualifier
    
    if [ "${IS_IN_SETUP_MODE}x" = "truex" ]; then
        ## Indicate to respond to ARP resquests on the interface where traffic is being stolen
        stealArpAddress ${STEAL_ADDRESS} ${STEAL_INTERFACE} || return 0

        ## Antisubscribe from  TCP traffic to the stolen IP here.
        if [ -n "${STEAL_TCP_PORTS}" ]; then
            t_qualifier="-p tcp --destination ${STEAL_ADDRESS} -m multiport --destination-ports ${STEAL_TCP_PORTS}"
            
            ## Redirect traffic to the stolen address to local.
            ${IPTABLES} -t nat -A PREROUTING ${t_qualifier} -j REDIRECT

            ## Antisubscribe to the stolen traffic
            ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} ${t_qualifier} -j MARK --or-mark ${MARK_ANTISUB}
        fi

        if [ -n "${STEAL_UDP_PORTS}" ]; then
            t_qualifier="-p udp  --destination ${STEAL_ADDRESS} -m multiport --destination-ports ${STEAL_UDP_PORTS}"

            ## Redirect traffic to the stolen address to local.
            ${IPTABLES} -t nat -A PREROUTING ${t_qualifier} -j REDIRECT

            ## Antisubscribe to the stolen traffic
            ${IPTABLES} -t mangle -A ${CHAIN_ANTISUB} ${t_qualifier} -j MARK --or-mark ${MARK_ANTISUB}
        fi
    fi
}

## If necessary run the user defined custom rules.
function runCustomRulesScript()
{
    ## If necessary run the custom rules script
    if [ -n "${MVVM_CUSTOM_RULES}" ]; then 
        ${MVVM_CUSTOM_RULES} ; 
    else
        ${LOG_DEBUG} "Custom rules script is disabled"
    fi
}

getLicenseKey() {
  # the wizard has not run yet, exit right away
  [[ ! -f $ACTIVATION_KEY_FILE ]] && return

  # if the activation temp file isn't there, but the activation one
  # is, it means we already have a valid key, so we don't want to
  # proceed any further.
  #
  # Copyright TeamJanky 2007: the double test is to avoid a possible
  # race condition where we pass 1), but the other backgrounded curl
  # completes before 2), and then when we reach 3) our temp file has
  # already been deleted and we're left in the cold...
  [[ -f $ACTIVATION_KEY_FILE_TMP ]] || return
  killall curl
  [[ -f $ACTIVATION_KEY_FILE_TMP ]] || return

  KEY=`cat $ACTIVATION_KEY_FILE_TMP`

  # for CD downloads, the temp key is only 0s, so we need to ask the 
  # server for a brand new one; that's done by not supplying any value
  # to the CGI variable
  [[ $KEY = $FAKE_KEY ]] && KEY="" 

  if curl -m 10 --insecure --fail -o $TMP_ARCHIVE `printf ${ACTIVATION_URL_TEMPLATE} "$KEY" $(/usr/bin/mvip)`; then
    rm -f $ACTIVATION_KEY_FILE_TMP
    tar -C / -xf $TMP_ARCHIVE
    @PREFIX@/usr/bin/mvactivate
    @PREFIX@/usr/bin/mvregister # trigger root passwd generation
  fi
}

###############################################################
######### Start of script #####################################
###############################################################
echo "[DEBUG:`date`] Generating iptables rules"

# This parameter comes from the MVVM_PARAMS_FILE
if [ -f /proc/sys/net/ipv4/tcp_window_scaling ] ; then
    ## If undefined or non-true, disable window scaling
    val=0
    
    if [ "x$TCP_WINDOW_SCALING_EN" = "xtrue" ]; then
        echo "[DEBUG:`date`] enabling TCP Window Scaling"
        val=1
    fi
    
    echo $val > /proc/sys/net/ipv4/tcp_window_scaling 
fi


generateConfiguration

flush

buildFoundation

blockForwarding

guardRules

markIntfRules

rawRules

antisubscribeRules

uturnRules

interceptRules

setupMode

runCustomRulesScript

getLicenseKey

true