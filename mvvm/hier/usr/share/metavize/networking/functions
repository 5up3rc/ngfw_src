#!/bin/sh

PUMP_FLAG="pump"

## A few constants
IPTABLES="/sbin/iptables"
#IPTABLES=iptablesDbg

TABLE_LIST="nat mangle filter raw"
CHAIN_MARKINTF="markintf"
CHAIN_GUARDS="guards"
CHAIN_ANTISUB="antisub"
CHAIN_INTERCEPT="intercept"
CHAINS_ORDER="${CHAIN_MARKINTF} ${CHAIN_GUARDS} ${CHAIN_ANTISUB} ${CHAIN_INTERCEPT}"

## Invalid address and netmask used when pump fails.
BOGUS_ADDRESS="169.254.210.51"
BOGUS_NETMASK="255.255.0.0"

## Utility functions for the mv-networking scripts, use t_ flag for temporary variables, this
## way global variables like bridge do not get overriden in functions.

function joinLines() {
    sed -e '{:start;N;s/\n/ /g;t start}'
}

## The script runs in two phases, generation is the process of creating the current configuration
## The "get" functions are used to query the configuration created in the generate phase.

function generateConfiguration() {
    generateBridges
    generateInterfaces
}

function generateBridges() {
    bridgeList=""
    for t_bridge in `brctl show | sed -e '1,1d' | grep "^br" | awk '{ print $1 }'` ; do
        generateBridge $t_bridge
        bridgeList="${bridgeList} ${t_bridge}"
    done
}

function generateBridge() {
    t_bridge=$1

    t_name="${t_bridge}"
    t_addresses=`generateAddresses ${t_bridge}`
    t_interfaces=`generateBridgeInterfaces ${t_bridge}`
    
    for t_intf in ${t_interfaces} ; do
        ## Set the bridge identifier for each interface
        eval ${t_intf}_bridge=\"$t_bridge\"
    done

    eval ${t_bridge}_name="${name}"
    eval ${t_bridge}_addresses=\"${t_addresses}\"
    eval ${t_bridge}_interfaces=\"${t_interfaces}\"
    
## DBG    echo "Generated configuration for ${t_bridge}" # XDBG
## DBG    echo "name: ${t_name}" # XDBG
## DBG    echo "addresses: ${t_addresses}" # XDBG
## DBG    echo "interfaces: ${t_interfaces}" # XDBG
}

function generateInterfaces() {
## DBG    echo "Generating interfaces" # XDBG
    interfaceList=""

    for t_intf in `ifconfig | grep -v br0 | grep -v lo | grep -v '^ ' | grep -v '^$' | awk '{ print $1 }' | grep -v :`; do
        ### Check if the interface is in a bridge
        if [ -z `getBridge ${t_intf}` ]; then
            t_name="${t_intf}"
            t_addresses=`generateAddresses ${t_intf}`

## DBG      echo "name: ${name}"  # XDBG
## DBG      echo "addresses: ${addresses}" # XDBG
            if [ -n "${t_addresses}" ]; then
                eval ${t_intf}_name="${t_name}"
                eval ${t_intf}_addresses=\"${t_addresses}\"
                interfaceList="${interfaceList} ${t_intf}"
            fi
        fi
    done
}

## print the address for a particular interface.  This will return aliases
## also, unless the input ($1) is specific.
## EG. br0=1.2.3.4/255.255.255.0, br0:0=10.0.0.1/255.0.0.0
## getAddresses br0 => "1.2.3.4/255.255.255.0 10.0.0.1/255.0.0.0"
## getAddresses br0:0 => "1.2.3.4/255.255.255.0"
function generateAddresses() {
## DBG    echo "generateAddresses $1"
    ifconfig | grep -A 4 $1 | awk '/inet/ { print $2 "/" $4 }' | sed -e 's/addr://' -e 's/Mask://' | grep -v "^$" | joinLines
}

## Returns all of the interfaces that participate in a bridge
function generateBridgeInterfaces() {
## DBG    echo "generateBridgeInterfaces $1" # XDBG
    brctl showstp $1 | grep -v '^$' | grep -v '^ ' | grep -v "can't" | grep -v $1 | awk '{ print $1 }' | joinLines
}

function getAddresses() {
    if [ -n $1 ]; then
        eval echo \$${1}_addresses | sed 's/\/.*//'
    fi
}

function getNetmasks() {
    if [ -n $1 ]; then
        eval echo \$${1}_addresses | sed 's/[^/]*\///'
    fi
}

## Return the bridge that an interface($1) participates in or the empty string if it doesn't
function getBridge() {
    eval echo \$${1}_bridge
}

function getBridgeAddresses() {    
    getAddresses `getBridge $1`
}

function isPumpRunning() {
    if [ -n $1 ]; then
        ps aux | grep pump | grep $1 | grep -v grep
    fi
}

function pumpInterface() {
    t_interface=$1
    echo "Pumping interface ${t_interface}"
    pump -i ${t_interface}
    if [ $? != 0 ]; then
        echo "Unable to pump interface ${t_interface}, going to bogus address"
        ifconfig ${t_interface} ${BOGUS_ADDRESS} netmask ${BOGUS_NETMASK}
    fi
}

function killPump() {
    echo "Killing pump"
    killall -KILL pump
}

function deleteBridge() {
    t_bridge=$1
    if [ -n ${t_bridge} ]; then
        echo "Deleting bridge ${bridge}"
        ifconfig ${t_bridge} down 
        brctl delbr ${t_bridge}
    fi
}

function iptablesDbg() {
    echo /sbin/iptables $@
    /sbin/iptables $@
}

function addGateway() {
    t_gateway=$1
    
    if [ "${t_gateway}x" != "x" ] && [ "${t_gateway}x" != "0.0.0.0x" ]; then
        route add default gw ${t_gateway}
    fi
}

function deleteGateways() {
    for t_gateway in `route -n | grep "^0.0.0.0" | awk '{ print $2}'`; do
        route del default gw ${t_gateway}
        ## No returning an error here
        echo -n
    done
}

