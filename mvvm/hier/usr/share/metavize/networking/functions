#!/bin/sh

PUMP_FLAG="pump"

## A few constants
IPTABLES="/sbin/iptables"
#IPTABLES=iptablesDbg

RT_TABLE_NAME_PREFIX="metavize-"

## All of the custom rules start in the 16,000 range.
RULE_PRIORITY_BASE=16

IP_CMD=ip

## don't print out debug messages in the production environment
LOG_DEBUG=true

if [ "x" != "x@PREFIX@" ] ; then
    ## Printout debuging info in the non-production environment
    LOG_DEBUG=logDebug
fi

# if necessary
LOG_DEBUG=logDebug

TABLE_LIST="nat mangle filter raw"
CHAIN_MARKINTF="markintf"
CHAIN_GUARDS="guards"
CHAIN_ANTISUB="antisub"
CHAIN_INTERCEPT="intercept"
CHAINS_ORDER="${CHAIN_MARKINTF} ${CHAIN_GUARDS} ${CHAIN_ANTISUB} ${CHAIN_INTERCEPT}"

## Invalid address and netmask used when pump fails.
BOGUS_ADDRESS_BASE="169.254.210.5"
BOGUS_NETMASK="255.255.0.0"

## Base SYSFS path for interfaces
SYSFS_INTERFACE_PATH="/sys/class/net"

## Utility functions for the mv-networking scripts, use t_ flag for temporary variables, this
## way global variables like bridge do not get overriden in functions.

function joinLines() {
    sed -e '{:start;N;s/\n/ /g;t start}'
}

## The script runs in two phases, generation is the process of creating the current configuration
## The "get" functions are used to query the configuration created in the generate phase.

function generateConfiguration() {
    generateBridges
    generateInterfaces
}

function generateBridges() {
    bridgeList=""
    for t_bridge in `getAllBridges` ; do
        generateBridge $t_bridge
        bridgeList="${bridgeList} ${t_bridge}"
    done
}

function generateBridge() {
    local t_bridge
    local t_name
    local t_addresses
    local t_interfaces

    t_bridge=$1

    t_name="${t_bridge}"
    t_addresses=`generateAddresses ${t_bridge}`
    t_interfaces=`bridgeInterfaceList ${t_bridge}`
    
    for t_intf in ${t_interfaces} ; do
        ## Set the bridge identifier for each interface
        eval ${t_intf}_bridge=\"$t_bridge\"
    done

    eval ${t_bridge}_name="${name}"
    eval ${t_bridge}_addresses=\"${t_addresses}\"
    eval ${t_bridge}_interfaces=\"${t_interfaces}\"
    
## DBG    echo "Generated configuration for ${t_bridge}" # XDBG
## DBG    echo "name: ${t_name}" # XDBG
## DBG    echo "addresses: ${t_addresses}" # XDBG
## DBG    echo "interfaces: ${t_interfaces}" # XDBG
}

function generateInterfaces() {
## DBG    echo "Generating interfaces" # XDBG
    interfaceList=""

    for t_intf in `ifconfig | grep -v br0 | grep -v lo | grep -v '^ ' | grep -v '^$' | awk '{ print $1 }' | grep -v :`; do
        ### Check if the interface is in a bridge
        if [ -z `getBridge ${t_intf}` ]; then
            t_name="${t_intf}"
            t_addresses=`generateAddresses ${t_intf}`

## DBG      echo "name: ${name}"  # XDBG
## DBG      echo "addresses: ${addresses}" # XDBG
            if [ -n "${t_addresses}" ]; then
                eval ${t_intf}_name="${t_name}"
                eval ${t_intf}_addresses=\"${t_addresses}\"
                interfaceList="${interfaceList} ${t_intf}"
            fi
        fi
    done
}

## print the address for a particular interface.  This will return aliases
## also, unless the input ($1) is specific.
## EG. br0=1.2.3.4/255.255.255.0, br0:0=10.0.0.1/255.0.0.0
## getAddresses br0 => "1.2.3.4/255.255.255.0 10.0.0.1/255.0.0.0"
## getAddresses br0:0 => "1.2.3.4/255.255.255.0"
function generateAddresses() {
## DBG    echo "generateAddresses $1"
    ifconfig | grep -A 4 $1 | awk '/inet/ { print $2 "/" $4 }' | sed -e 's/addr://' -e 's/Mask://' | grep -v "^$" | joinLines
}

function getAllInterfaces() {
    ls ${SYSFS_INTERFACE_PATH} | grep -v '\(lo\|dummy\|tun\)'
}

## Returns all of the interfaces that participate in a bridge
## Get a list of all of the interfaces in a bridge
function bridgeInterfaceList() {
    ls ${SYSFS_INTERFACE_PATH}/${1}/brif/ 2> /dev/null
}

function getAddresses() {
    if [ -n $1 ]; then
        eval echo \$${1}_addresses | sed 's/\/[^ ]*//g'
    fi
}

function getNetmasks() {
    if [ -n $1 ]; then
        eval echo \$${1}_addresses | sed 's/[^ /]*\///g'
    fi
}

## Return the bridge that an interface($1) participates in or the empty string if it doesn't
function getBridge() {
    eval echo \$${1}_bridge
}

function getBridgeAddresses() {    
    getAddresses `getBridge $1`
}

## Returns the "actual" address, this means the address of the bridge the interface is in(if it in
## in one) or the address of the interface itself if it is not.
function getActualAddresses() {
    local l_interface=$1

    if [ -z "`getBridge ${l_interface}`" ]; then
        getAddresses ${l_interface}
    else
        getBridgeAddresses ${l_interface}
    fi
}

function getBridgeNetmasks() {
    getNetmasks `getBridge $1`
}

function isPumpRunning() {
    if [ -n $1 ]; then
        ps aux | grep pump | grep $1 | grep -v grep
    fi
}

function pumpInterface() {
    local t_interface=$1
    local t_intfIndex=$2
    local t_fakeAddress="${BOGUS_ADDRESS_BASE}${t_intfIndex}"

    ${LOG_DEBUG} "Pumping interface ${t_interface}, index ${t_intfIndex}"

    if [ -z "${t_interface}" ] || [ -z "${t_intfIndex}" ]; then
        echo "Interface or interface index is empty"
        return
    fi

    pump -i ${t_interface}

    if [ $? != 0 ]; then
        echo "Unable to pump interface ${t_interface}, going to fake address: ${t_fakeAddress}"
        ifconfig ${t_interface} ${t_fakeAddress} netmask ${BOGUS_NETMASK}
    fi
}

function killPump() {
    echo "Killing pump"
    killall -KILL pump
}

function bridgeContainsInterface() {
    local l_bridge=$1
    local l_interface=$2

    if [ -h "${SYSFS_INTERFACE_PATH}/${l_bridge}/brif/${l_interface}" ]; then
        echo "true"
    fi
}

function getAllBridges() {
    find  ${SYSFS_INTERFACE_PATH} -name 'bridge_id' | sed -e 's/\/sys\/class\/net\///' \
        -e 's/\.\///' -e 's/\/.*//'
}

function deleteAllBridges() {
    local t_bridge
    local l_bridgeList=`getAllBridges`
    echo "Deleting all bridges: ${l_bridgeList}"
    for t_bridge in ${l_bridgeList}; do 
        deleteBridge ${t_bridge}
    done
}

function deconfigureAllInterfaces() {
    killPump
    local l_interface
    local l_interfaceList=`getAllInterfaces`
    echo "Deconfiguring all interfaces: ${l_interfaceList}"
    for l_interface in ${l_interfaceList}; do
        ifconfig ${l_interface} 0.0.0.0 -promisc down
    done

    l_interfaceList=`ifconfig -a | \grep '^[^ ]' | awk '{ print $1 }' | \grep  '\(br\|eth\)'`
    echo "Deconfiguring all interfaces, second pass: ${l_interfaceList}"
    ## This is a safety measure to delete aliases.
    for l_interface in ${l_interfaceList} ; do 
        ifconfig ${l_interface} 0.0.0.0 -promisc down
    done
    

    ## Just in case
    ifconfig lo 127.0.0.1 netmask 255.0.0.0
}

## Thisjust removes all of the interfaces from the bridge, 
## Removing and adding a bridge creates a new index
function deleteBridge() {
    local l_bridge=$1
    local l_port
    if [ -n "${l_bridge}" ]; then
        echo "Deleting all interfaces in bridge '${l_bridge}'"
        ifconfig ${l_bridge} down
        for l_port in `bridgeInterfaceList ${l_bridge}`; do
            brctl delif ${l_bridge} ${l_port}
            ifconfig ${l_port} 0.0.0.0
            ifconfig ${l_port} down
        done
        brctl delbr ${l_bridge}
    fi
}

## Use this function to echo the iptables command to standard out for logging and execute it
## at the same time
function iptablesDbg() {
    echo /sbin/iptables $@
    /sbin/iptables $@
}

function addGateway() {
    local t_gateway=$1
    
    if [ "${t_gateway}x" != "x" ] && [ "${t_gateway}x" != "0.0.0.0x" ]; then
        route add default gw ${t_gateway}
    fi
}

function deleteGateways() {
    ${LOG_DEBUG} "Deleting all of the default route(s)"
    ${IP_CMD} route show | grep '^default' | sed  -e '/^default/d' -e 's| dev.*$||g' \
        -e 's|\(.*\)|ip route del \1|' | sh
}

function logDebug() {
    echo $@
}

