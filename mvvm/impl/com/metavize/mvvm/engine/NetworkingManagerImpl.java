/*
 * Copyright (c) 2003, 2004, 2005, 2006 Metavize Inc.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Metavize Inc. ("Confidential Information").  You shall
 * not disclose such Confidential Information.
 *
 * $Id$
 */

package com.metavize.mvvm.engine;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.util.Arrays;

import com.metavize.mvvm.IntfConstants;
import com.metavize.mvvm.IntfEnum;
import com.metavize.mvvm.MvvmContextFactory;
import com.metavize.mvvm.NetworkManager;
import com.metavize.mvvm.NetworkingConfiguration;
import com.metavize.mvvm.NetworkingManager;
import com.metavize.mvvm.argon.IntfConverter;
import com.metavize.mvvm.networking.NetworkException;
import com.metavize.mvvm.tran.ValidateException;
import com.metavize.mvvm.tran.firewall.intf.IntfMatcherFactory;
import org.apache.log4j.Logger;

class NetworkingManagerImpl implements NetworkingManager
{
    // These are the predefined ones.  There can be others.
    private static final String HEADER         = "##AUTOGENERATED BY METAVIZE DO NOT MODIFY MANUALLY\n\n";
    private static final String BUNNICULA_BASE = System.getProperty( "bunnicula.home" );
    private static final String BUNNICULA_CONF = System.getProperty( "bunnicula.conf.dir" );

    private static final String IP_CFG_FILE    = "/etc/network/interfaces";
    private static final String NS_CFG_FILE    = "/etc/resolv.conf";
    private static final String FLAGS_CFG_FILE = "/networking.sh";
    private static final String SSHD_PID_FILE  = "/var/run/sshd.pid";

    private static final String NS_PARAM       = "nameserver";

    private static final String FLAG_TCP_WIN   = "TCP_WINDOW_SCALING_EN";
    private static final String FLAG_HTTP_IN   = "MVVM_ALLOW_IN_HTTP";
    private static final String FLAG_HTTPS_OUT = "MVVM_ALLOW_OUT_HTTPS";
    private static final String FLAG_HTTPS_RES = "MVVM_ALLOW_OUT_RES";
    private static final String FLAG_OUT_NET   = "MVVM_ALLOW_OUT_NET";
    private static final String FLAG_OUT_MASK  = "MVVM_ALLOW_OUT_MASK";
    private static final String FLAG_EXCEPTION = "MVVM_IS_EXCEPTION_REPORTING_EN";
    private static final String FLAG_POST_FUNC = "MVVM_POST_CONF";
    private static final String POST_FUNC_NAME =  "postConfigurationScript";
    /* Functionm declaration for the post configuration function */
    private static final String DECL_POST_CONF = "function " + POST_FUNC_NAME + "() {";


    private final Logger logger = Logger.getLogger(getClass());

    private static NetworkingManagerImpl INSTANCE = new NetworkingManagerImpl();

    /* A cache of the current configuration */
    NetworkingConfiguration configuration = null;

    private IntfEnum intfEnum;

    private NetworkingManagerImpl()
    {
    }

    /**
     * Retrieve the current network configuration
     */
    public synchronized NetworkingConfiguration get()
    {
        return getNetworkManager().getNetworkingConfiguration();
    }

    /**
     * Set a network configuration.
     * @param configuration - Configuration to save
     */
    public synchronized void set( NetworkingConfiguration netConfig ) throws ValidateException
    {
        try {
            getNetworkManager().setNetworkingConfiguration( netConfig );
        } catch ( NetworkException e ) {
            logger.error( "Network exception while setting the network configuration.", e );
            /* !!! This is kind of dangerous */
            throw new ValidateException( "Unable to save the network configuration" );
        }
    }

    /* Get the external HTTPS port */
    public int getExternalHttpsPort()
    {
        return getNetworkManager().getPublicHttpsPort();
    }

    public IntfEnum getIntfEnum()
    {
        return this.intfEnum;
    }

    public NetworkingConfiguration renewDhcpLease() throws Exception
    {
        return getNetworkManager().renewDhcpLease();
    }

    private NetworkManager getNetworkManager()
    {
        return MvvmContextFactory.context().networkManager();
    }

    private void writeFile( StringBuilder sb, String fileName )
    {
        BufferedWriter out = null;

        /* Open up the interfaces file */
        try {
            String data = sb.toString();

            out = new BufferedWriter(new FileWriter( fileName ));
            out.write( data, 0, data.length());
        } catch ( Exception ex ) {
            /* XXX May need to catch this exception, restore defaults
             * then try again */
            logger.error( "Error writing file " + fileName + ":", ex );
        }

        close( out );
    }

    static NetworkingManagerImpl getInstance()
    {
        return INSTANCE;
    }

    private void close( BufferedReader buf )
    {
        try {
            if ( buf != null )
                buf.close();
        } catch ( Exception ex ) {
            logger.error( "Unable to close file", ex );
        }
    }

    private void close( BufferedWriter buf )
    {
        try {
            if ( buf != null )
                buf.close();
        } catch ( Exception ex ) {
            logger.error( "Unable to close file", ex );
        }
    }

    void buildIntfEnum()
    {
        IntfConverter converter = IntfConverter.getInstance();
        if ( converter == null ) { /* Running in fake mode */
            logger.info( "Running in fake mode, using internal and external" );
            this.intfEnum =
                new IntfEnum( new byte[]   { IntfConstants.EXTERNAL_INTF, IntfConstants.INTERNAL_INTF },
                              new String[] { IntfConstants.EXTERNAL,      IntfConstants.INTERNAL } );
            return;
        }

        byte[] argonIntfArray = MvvmContextFactory.context().argonManager().getArgonIntfArray();
        Arrays.sort( argonIntfArray );

        String[] intfNameArray = new String[argonIntfArray.length];

        for ( int c = 0; c < argonIntfArray.length ; c++ ) {
            String name = "unknown";
            byte intf = argonIntfArray[c];
            switch ( intf ) {
            case IntfConstants.EXTERNAL_INTF: name = IntfConstants.EXTERNAL; break;
            case IntfConstants.INTERNAL_INTF: name = IntfConstants.INTERNAL; break;
            case IntfConstants.DMZ_INTF:      name = IntfConstants.DMZ;      break;
            case IntfConstants.VPN_INTF:      name = IntfConstants.VPN;      break;
            default:
                logger.error( "Unknown interface: " + intf + " using unknown" );
                continue;
            }

            intfNameArray[c] = name;
        }

        this.intfEnum = new IntfEnum( argonIntfArray, intfNameArray );

        IntfMatcherFactory.getInstance().updateEnumeration( intfEnum );
    }
}
