/*
 * Copyright (c) 2003, 2004, 2005 Metavize Inc.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Metavize Inc. ("Confidential Information").  You shall
 * not disclose such Confidential Information.
 *
 * $Id$
 */
package com.metavize.tran.nat;

import java.util.List;
import java.util.LinkedList;
import java.util.Iterator;
import java.util.Date;
import java.util.Map;
import java.util.HashMap;

import java.io.FileWriter;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.BufferedWriter;

import org.apache.log4j.Logger;

import com.metavize.mvvm.NetworkingConfiguration;
import com.metavize.mvvm.MvvmContextFactory;

import com.metavize.mvvm.tran.IPaddr;
import com.metavize.mvvm.tran.IPNullAddr;
import com.metavize.mvvm.tran.firewall.MACAddress;

import com.metavize.mvvm.tran.TransformStartException;
import com.metavize.mvvm.tran.TransformException;

class DhcpManager
{
    private static final DhcpManager INSTANCE = new DhcpManager();

    private static final String COMMENT = "#";
    private static final String HEADER  = COMMENT + " AUTOGENERATED BY METAVIZE DO NOT MODIFY MANUALLY\n\n";

    private static final String FLAG_DHCP_RANGE       = "dhcp-range";
    private static final String FLAG_DHCP_HOST        = "dhcp-host";
    private static final String FLAG_DHCP_OPTION      = "dhcp-option";
    private static final String FLAG_DHCP_GATEWAY     = "3";
    private static final String FLAG_DHCP_NETMASK     = "1";
    private static final String FLAG_DHCP_NAMESERVERS = "6";
    private static final String FLAG_DNS_LISTEN       = "listen-address";

    private static final int DHCP_LEASE_ENTRY_LENGTH  = 5;
    private static final String DHCP_LEASE_DELIM      = " ";

    private static final String DHCP_LEASES_FILE      = "/var/lib/misc/dnsmasq.leases";
    private static final int DHCP_LEASE_ENTRY_EOL     = 0;
    private static final int DHCP_LEASE_ENTRY_MAC     = 1;
    private static final int DHCP_LEASE_ENTRY_IP      = 2;
    private static final int DHCP_LEASE_ENTRY_HOST    = 3;
    
    private static final String DNS_MASQ_FILE         = "/etc/dnsmasq.conf";
    private static final String DNS_MASQ_CMD          = "/etc/init.d/dnsmasq ";
    private static final String DNS_MASQ_CMD_RESTART  = DNS_MASQ_CMD + " restart";
    private static final String DNS_MASQ_CMD_STOP     = DNS_MASQ_CMD + " stop";

    private final Logger logger = Logger.getLogger( DhcpManager.class );
    
    private DhcpManager()
    {
    }

    void configure( NatSettings settings, NetworkingConfiguration netConfig ) throws TransformStartException
    {
        int code;

        try { 
            writeConfiguration( settings, netConfig );
            
            logger.debug( "Reloading DNS Masq server" );
            
            /* restart dnsmasq */
            Process p = Runtime.getRuntime().exec( DNS_MASQ_CMD_RESTART );
            code = p.waitFor();
        } catch ( Exception e ) {
            throw new TransformStartException( "Unable to reload DNS masq configuration", e );
        }

        if ( code != 0 ) {
            throw new TransformStartException( "Error starting DNS masq server" + code );
        }

        /* Enable/Disable DHCP forwarding  */
        try {
            if ( settings.getDhcpEnabled()) {
                MvvmContextFactory.context().argonManager().disableDhcpForwarding();
            } else {
                MvvmContextFactory.context().argonManager().enableDhcpForwarding();
            }
        } catch ( Exception e ) {
            throw new TransformStartException( "Error updating DHCP forwarding settings" + code );
        }
    }
    
    void deconfigure()
    {
        int code;

        try {
            writeDisabledConfiguration();
            
            Process p = Runtime.getRuntime().exec( DNS_MASQ_CMD_RESTART );
            code = p.waitFor();
            
            if ( code != 0 ) {
                logger.error( "Error stopping DNS masq server, returned code: " + code );
            }
        } catch ( Exception e ) {
            logger.error( "Error while disabling the DNS masq server", e );
        }

        /* Re-enable DHCP forwarding */
        try {
            logger.info( "Reenabling DHCP forwarding" );
            MvvmContextFactory.context().argonManager().enableDhcpForwarding();
        } catch ( Exception e ) {
            logger.error( "Error enabling DHCP forwarding", e );
        }
    }

    void loadLeases( NatSettings settings )
    {
        BufferedReader in = null;

        /* Insert the rules from the leases file, than layover the rules from the settings */
        List<DhcpLeaseRule> leaseList  = new LinkedList<DhcpLeaseRule>();
        Map<MACAddress,Integer> macMap = new HashMap<MACAddress,Integer>();

        /* The time right now to determine if leases have been expired */
        Date now = new Date();
        
        
        /* Open up the interfaces file */
        try {
            in = new BufferedReader(new FileReader( DHCP_LEASES_FILE ));
            String str;
            while (( str = in.readLine()) != null ) {
                parseLease( str, leaseList, now, macMap );
            }
        } catch ( Exception ex ) {
            logger.error( "Error reading file: " + DHCP_LEASES_FILE, ex );
        }
        
        try {
            if ( in != null )  in.close();
        } catch ( Exception ex ) {
            logger.error( "Unable to close file: " + DHCP_LEASES_FILE, ex );
        }

        /* Lay over the settings from NAT */
        List <DhcpLeaseRule> staticList = settings.getDhcpLeaseList();
        
        overlayStaticLeases( staticList, leaseList, macMap );
        
        /* Set the list */
        settings.setDhcpLeaseList( leaseList );
    }
    
    void parseLease( String str, List<DhcpLeaseRule> leaseList, Date now, Map<MACAddress,Integer> macMap )
    {
        str = str.trim();
        String strArray[] = str.split( DHCP_LEASE_DELIM );
        String tmp, host;
        Date eol;
        MACAddress mac;
        IPNullAddr ip;
        
        if ( strArray.length != DHCP_LEASE_ENTRY_LENGTH ) {
            logger.error( "Invalid DHCP lease: " + str );
            return;
        }
        
        tmp  = strArray[DHCP_LEASE_ENTRY_EOL];
        try {
            eol = new Date( Long.parseLong( tmp ) * 1000 );
        } catch ( Exception e ) {
            logger.error( "Invalid DHCP date: " + tmp );
            return;
        }
        
        if ( eol.before( now )) {
            logger.debug( "Lease already expired: " + str );
            return;
        }

        tmp  = strArray[DHCP_LEASE_ENTRY_MAC];
        try {
            mac = MACAddress.parse( tmp );
        } catch ( Exception e ) {
            logger.error( "Invalid MAC address: " + tmp );
            return;
        }
        
        tmp  = strArray[DHCP_LEASE_ENTRY_IP];
        try {
            ip = IPNullAddr.parse( tmp );
        } catch ( Exception e ) {
            logger.error( "Invalid MAC address: " + tmp );
            return;
        }
        
        host  = strArray[DHCP_LEASE_ENTRY_HOST];
    
        /* Insert the lease */
        DhcpLeaseRule rule  = new DhcpLeaseRule( mac, host, ip, IPNullAddr.getNullAddr(), eol, true );
        
        /* Determine if the rule already exists */
        Integer index = macMap.get( mac );

        if ( index == null ) {
            leaseList.add( rule );
            macMap.put( mac, leaseList.size() - 1 );
        } else {
            /* XXX Right now resolve by MAC is always true */
            leaseList.set( index, rule );
        }
    }

    private void overlayStaticLeases( List<DhcpLeaseRule> staticList, List<DhcpLeaseRule> leaseList, 
                                      Map<MACAddress,Integer> macMap )
    {
        if ( staticList == null ) {
            return;
        }
        
        for ( Iterator<DhcpLeaseRule> iter = staticList.iterator() ; iter.hasNext() ; ) {
            DhcpLeaseRule rule = iter.next();
            
            MACAddress mac = rule.getMacAddress();
            Integer index = macMap.get( mac );
            if ( index == null ) {
                /* Insert a new rule */
                leaseList.add( new DhcpLeaseRule( mac, "", IPNullAddr.getNullAddr(), 
                                                  rule.getStaticAddress(), null, true ));
                macMap.put( mac, leaseList.size() - 1 );
            } else {
                DhcpLeaseRule currentRule = leaseList.get( index );
                currentRule.setStaticAddress( rule.getStaticAddress());
                currentRule.setResolvedByMac( rule.getResolvedByMac());
            }
        }
    }

    /* This removes all of the non-static leases */
    void fleeceLeases( NatSettings settings ) 
    {
        /* Lay over the settings from NAT */
        List <DhcpLeaseRule> staticList = settings.getDhcpLeaseList();

        for ( Iterator<DhcpLeaseRule> iter = staticList.iterator() ; iter.hasNext() ; ) {
            DhcpLeaseRule rule = iter.next();
            
            IPNullAddr staticAddress = rule.getStaticAddress();
            
            if ( staticAddress == null || staticAddress.isEmpty()) {
                iter.remove();
            }
        }
    }

    private void writeConfiguration( NatSettings settings, NetworkingConfiguration netConfig )
    {
        StringBuilder sb = new StringBuilder();
        
        IPaddr externalAddress = netConfig.host();

        sb.append( HEADER );

        if ( settings.getDhcpEnabled()) {
            /* XXX Presently always defaulting leases to a fixed value */
            comment( sb, "DHCP Range:" );
            sb.append( FLAG_DHCP_RANGE + "=" + settings.getDhcpStartAddress().toString());
            sb.append( "," + settings.getDhcpEndAddress().toString() + ",4h\n\n\n" );
            
            /* Configure all of the hosts */
            List<DhcpLeaseRule> list = (List<DhcpLeaseRule>)settings.getDhcpLeaseList();
            
            if ( list != null ) {
                for ( Iterator<DhcpLeaseRule> iter = list.iterator() ; iter.hasNext() ; ) {
                    DhcpLeaseRule rule = iter.next();
                    
                    if ( !rule.getStaticAddress().isEmpty()) {
                        comment( sb, "Static DHCP Host" );
                        if ( rule.getResolvedByMac()) {
                            sb.append( FLAG_DHCP_HOST + "=" + rule.getMacAddress().toString());
                            sb.append( "," + rule.getStaticAddress().toString() + ",24h\n\n" );
                        } else {
                            sb.append( FLAG_DHCP_HOST + "=" + rule.getHostname());
                            sb.append( "," + rule.getStaticAddress().toString() + ",24h\n\n" );
                        }
                    }
                }
            }
            
            IPaddr gateway;
            IPaddr netmask;
            
            /* If Nat is turned on, use the settings from nat, otherwise use
             * the settings from networking configuration */
            if ( settings.getNatEnabled()) {
                gateway = settings.getNatInternalAddress();
                netmask = settings.getNatInternalSubnet();
            } else {
                gateway = netConfig.gateway();
                netmask  = netConfig.netmask();
            }
            
            comment( sb, "Setting the gateway" );
            sb.append( FLAG_DHCP_OPTION + "=" + FLAG_DHCP_GATEWAY );
            sb.append( "," + gateway.toString() + "\n\n" );
            
            comment( sb, "Setting the subnet" );
            sb.append( FLAG_DHCP_OPTION + "=" + FLAG_DHCP_NETMASK );
            sb.append( "," + netmask.toString() + "\n\n" );
            
            
            appendNameServers( sb, settings, netConfig );
        } else {
            comment( sb, "DHCP is disabled, not using a range or any host rules\n" );
        }
        
        if ( !settings.getDnsEnabled()) {
            comment( sb, "DNS is disabled, binding DNS to local host" );
            sb.append( FLAG_DNS_LISTEN + "=" + "127.0.0.1\n\n" );
        }

        /* XXX localdomain, no settings for local domain */

        writeFile( sb, DNS_MASQ_FILE );
    }

    static DhcpManager getInstance()
    {
        return INSTANCE;
    }

    /* XXX This should go into a global util class */
    private void writeFile( StringBuilder sb, String fileName ) 
    {
        BufferedWriter out = null;
        
        /* Open up the interfaces file */
        try {
            String data = sb.toString();
            
            out = new BufferedWriter(new FileWriter( fileName ));
            out.write( data, 0, data.length());
        } catch ( Exception ex ) {
            /* XXX May need to catch this exception, restore defaults
             * then try again */
            logger.error( "Error writing file " + fileName + ":", ex );
        }
        
        try {
            if ( out != null ) 
                out.close();
        } catch ( Exception ex ) {
            logger.error( "Unable to close file: " + fileName , ex );
        }
    }

    private void appendNameServers( StringBuilder sb, NatSettings settings, NetworkingConfiguration netConfig )
    {
        String nameservers = "";
        IPaddr tmp;
        
        if ( settings.getDnsEnabled()) {
            if ( settings.getNatEnabled()) {
                nameservers += settings.getNatInternalAddress().toString();
            } else {
                nameservers += netConfig.host().toString();
            }
        }
        
        tmp = netConfig.dns1();

        if ( tmp != null && !tmp.isEmpty()) {
            nameservers += ( nameservers.length() == 0 ) ? "" : ",";
            nameservers += tmp.toString();
        }

        tmp = netConfig.dns2();

        if ( tmp != null && !tmp.isEmpty()) {
            nameservers += ( nameservers.length() == 0 ) ? "" : ",";
            nameservers += tmp.toString();
        }

        if ( nameservers.length() == 0 ) {
            comment( sb, "No nameservers specified\n" );
        } else {
            comment( sb, "Nameservers:" );
            sb.append( FLAG_DHCP_OPTION + "=" + FLAG_DHCP_NAMESERVERS );
            sb.append( "," + nameservers + "\n\n" );
        }
    }

    /* This guarantees the comment appears with a newline at the end */
    private void comment( StringBuilder sb, String comment )
    {
        sb.append( COMMENT + " " + comment + "\n" );
    }

    private void writeDisabledConfiguration()
    {
        StringBuilder sb = new StringBuilder();

        sb.append( HEADER );
        comment( sb, "DNS is disabled, binding DNS to local host" );
        sb.append( FLAG_DNS_LISTEN + "=" + "127.0.0.1\n\n" );
        
        writeFile( sb, DNS_MASQ_FILE );
    }

}
