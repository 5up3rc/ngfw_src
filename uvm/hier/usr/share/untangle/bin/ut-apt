#!/usr/bin/ruby
#
# $HeadURL: $
# Copyright (c) 2003-2008 Untangle, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2,
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or
# NONINFRINGEMENT.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#

require 'fileutils'
require 'getoptlong'
require 'tempfile'
require 'gettext'
require 'syslog'

include GetText
bindtextdomain('untangle-vm')

ENV['DEBIAN_FRONTEND'] = 'noninteractive'

INST_OPTS = " -o DPkg::Options::=--force-confnew --yes --force-yes --fix-broken --purge "
UPGD_OPTS = " -o DPkg::Options::=--force-confnew --yes --force-yes --fix-broken --purge "
UPDT_OPTS = " --yes --force-yes --purge "
REMO_OPTS = " --yes --force-yes --fix-broken --purge "

PREFIX = "@PREFIX@"
$ERROR = ""

Syslog.open('ut-apt', Syslog::LOG_PID | Syslog::LOG_NDELAY, Syslog::LOG_LOCAL2)
Syslog.info(Time.new.strftime("%Y/%m/%d %H:%M:%S"))

def printusage()
  puts _('usage:')
puts <<STR
  ut-apt installed
  ut-apt available
  ut-apt install <mackage>
  ut-apt remove
  ut-apt predictInstall
  ut-apt update
  ut-apt upgrade
STR
  return 1
end

def log(str)
  Syslog.info(str)
end

class DevApt
  def initialize(stamp)
    @pkg_list_dir = "#{PREFIX}/tmp"
    @stamp = stamp
  end

  def installed()
    devs = []
    each_pkg_list_line { |l|
      if /^Package: / =~ l
        pack = l.split[1]
        devs << pack
        puts "#{pack} 10.0"
      end
    }
    STDOUT.flush
    IO.popen("dpkg --get-selections 'untangle*'", 'r') do |input|
      IO.popen("xargs dpkg-query -W", 'w') do |output|
        input.each_line do |l|
          s = l.split
          output.puts(s[0]) if 'install' == s[1] and !devs.include?(s[0])
        end
      end
    end
    0
  end

  def available()
    each_pkg_list_line do |l|
      puts l.gsub(/^XB-/, '')
      puts "Version: 10.0" if /^Package: / =~ l
    end
    0
  end

  def install(name)
    log "start $stamp"
    log "END PACKAGE LIST"
    log "done $stamp"
    0
  end

  def update()
    0
  end

  def upgrade()
    log "start $stamp"
    log "END PACKAGE LIST"
    log "done $stamp"
    0
  end

  def remove(pkg)
    0
  end

  def predictInstall(pkg)
    0
  end

  private

  def each_pkg_list_line()
    Dir.new(@pkg_list_dir).select { |d| /^pkg-list/ =~ d }.each do |p|
      File.open("#{@pkg_list_dir}/#{p}", 'r') do |io|
        io.each_line { |l| yield l }
      end
    end
  end
end

class RealApt
  def initialize(stamp)
    @stamp = stamp
  end

  def installed()
    IO.popen("dpkg --get-selections 'untangle*'", 'r') do |input|
      IO.popen("xargs dpkg-query -W", 'w') do |output|
        input.each_line do |l|
          s = l.split
          output.puts(s[0]) if 'install' == s[1]
        end
      end
    end
    0
  end

  def available()
    IO.popen("apt-cache search '^untangle-'") do |input|
      IO.popen("xargs apt-cache show --no-all-versions", 'w') do |output|
        input.each_line do |l|
          output.puts(l.split[0])
        end
      end
    end
    0
  end

  def install(pkg)
    log "start #{@stamp}"
    log "downloading: \"#{pkg}\""

    recs = get_recommends(pkg).join(' ')
    log "RECS: #{recs}"

    pkg_list = get_pkg_list("apt-get install #{INST_OPTS} --print-uris #{pkg} #{recs}")
    r = download(pkg_list)
    if (r != 0)
      return r
    end

    log "installing: \"#{pkg}\""

    IO.popen("apt-get install #{INST_OPTS} #{pkg} #{recs}", 'r') do |input|
      input.each_line { |l| log l }
      input.close
      r = $?
    end

    log "done #{@stamp}"

    (r == 0) ? 0 : 1
  end

  def update()
    log "start #{@stamp}"
    log "apt-get update #{UPDT_OPTS}"
    IO.popen("apt-get update #{UPDT_OPTS}") do |io|
      io.each_line { |l|
        log l unless l =~ /W: (Conflicting distribution|You may want to run apt-get update to correct these problems)/ }
      io.close
      r = $?
    end

    log "done #{@stamp}"

    # Update doesn't need to show errors.
    #(r == 0) ? 0 : 1
    0
  end

  def upgrade()
    log "start #{@stamp}"
    log "apt-get upgrade #{UPGD_OPTS}"

    pkg_list = get_pkg_list("apt-get dist-upgrade #{UPGD_OPTS} --print-uris")
    r = download(pkg_list)
    if (r != 0)
      return r
    end
    cmd_to_stderr("monit -c /etc/untangle/monit.conf unmonitor all")
    r = cmd_to_stderr("apt-get dist-upgrade #{UPGD_OPTS}")
    log "done #{@stamp}"
    cmd_to_stderr("monit -c /etc/untangle/monit.conf monitor all")

    r
  end

  def remove(pkg)
    log "start #{@stamp}"
    log "apt-get remove #{REMO_OPTS} #{pkg}"
    r = cmd_to_stderr("apt-get remove #{REMO_OPTS} #{pkg}")
#   cmd_to_stderr("apt-get clean")
    log "done #{@stamp}"

    0
  end

  def predictInstall(pkg)
    ret = 0

    IO.popen("apt-get install -s #{pkg}") do |io|
      io.each_line do |l|
        if /^Inst ([^ ]+) / =~ l
          puts $1
        end
      end
      io.close
      ret = $?
    end

    (ret == 0) ? 0 : 1
  end

  private

  def get_recommends(pkg)
    in_recommends = false

    recs = ''

    IO.popen("apt-cache show #{pkg}") do |io|
      io.each_line do |l|
        if in_recommends
          if /^\s+(.*)$/ =~ l
            l += $1
          else
            in_recommends = false
          end
        elsif /^Recommends:(.*)$/ =~ l
          in_recommends = true
          recs += $1
        end
      end
    end

    recs.split(',').map do |e|
      r = e.split('|').first
      r.nil? ? nil : r.strip
    end.compact
  end

  def cmd_to_stderr(cmd)
    IO.popen(cmd) do |io|
      io.each_line { |l| log l }
      io.close
    end
    ($? == 0) ? 0 : 1
  end

  def get_tempdir()
    tmp = Tempfile.new('ut-apt')
    path = tmp.path
    tmp.delete
    Dir.mkdir(path)
    path
  end

  def get_pkg_list(apt_cmd)
    pkg_list = []

    IO.popen(apt_cmd, 'r') do |io|
      io.each_line do |l|
        if /^'(http:\/\/.*)' / =~ l
          log l
          pkg_list << $1
        end
        if /^'(.*ERROR.*)' / =~ l
          $ERROR = l
        end
      end
    end

    pkg_list
  end

  def download(pkg_list)
    log "END PACKAGE LIST"

    tmp = get_tempdir()
    begin
      pkg_list.each do |p|
        log "downloading: #{p}"

        if cmd_to_stderr("wget --progress=dot -P #{tmp} #{p} 2>&1")
          Dir.new(tmp).select { |f| /\.deb$/ =~ f }.each do |f|
            FileUtils.mv("#{tmp}/#{f}", "/var/cache/apt/archives")
          end
          log "DOWNLOAD SUCCEEDED: #{p}"
        else
          log "DOWNLOAD FAILED: #{$ERROR}"
          return -1
        end

      end
    ensure
      FileUtils.rm_rf(tmp)
    end

    0
  end

end

stamp = nil

opts = GetoptLong.new([ '-k', GetoptLong::REQUIRED_ARGUMENT ])
opts.each do |opt, arg|
  if '-k' == opt
    stamp = arg
  end
end

if ARGV.length < 1
  printusage()
  exit(1)
end

ret = 0

apt = PREFIX.empty? ? RealApt.new(stamp) : DevApt.new(stamp)

rc = case ARGV.shift
     when 'installed'
       apt.installed()
     when 'available'
       apt.available()
     when 'install'
       if ARGV.empty?
         printusage()
       else
         apt.install(ARGV.shift)
       end
     when 'update'
       apt.update()
     when 'upgrade'
       apt.upgrade()
     when 'remove'
       if ARGV.empty?
         printusage()
       else
         apt.remove(ARGV.shift)
       end
     when 'predictInstall'
       apt.predictInstall(ARGV.shift)
     else
         printusage()
     end

Syslog.close

exit(rc)
