#!/usr/bin/python -u
# $Id: ut-apt,v 1.00 2013/05/27 17:02:52 dmorris Exp $#!/usr/bin/python

import getopt
import sys
import os
import signal
import re
import subprocess
import tempfile
import time
import logging

# set noninteractive mode for all apt-get calls
os.environ['DEBIAN_FRONTEND'] = 'noninteractive'

# apt-get options for various commands
INSTALL_OPTS = " -o DPkg::Options::=--force-confnew --yes --force-yes --fix-broken --purge "
UPGRADE_OPTS = " -o DPkg::Options::=--force-confnew --yes --force-yes --fix-broken --purge "
UPDATE_OPTS = " --yes --force-yes --purge "
REMOVE_OPTS = " --yes --force-yes --fix-broken --purge "

# The prefix, substituted by the build. If non-blank its development environment
PREFIX = "@PREFIX@"

# The command specified
COMMAND = None
COMMAND_ARG = None
ERROR = None

# Ignore SIGHUP from parent (this is in case we get launched by the UVM, and then it exits)
# This isn't enough because this doesn't modify sigprocmask so children of this process still get it
signal.signal( signal.SIGHUP, signal.SIG_IGN )
# Detach from parent (so it won't send us signals like SIGHUP)
# This should shield us and children from SIGHUPs
os.setpgrp()

apt_log = open("/var/log/uvm/apt.log", "a")

def log(str):
    # wrap all attempts in try/except
    # if the parent dies, stdout might product a sigpipe
    # see we need to be careful with "print"
    try: 
        apt_log.write(str + "\n")
        apt_log.flush()
    except:
        pass
    try:
        print str
    except: 
        pass

def log_date( cmd ):
    p = subprocess.Popen(["date","+%Y-%m-%d:%H:%m"], stdout=subprocess.PIPE )
    for line in iter(p.stdout.readline, ''):
        log( line.strip() + " " + cmd)
    p.wait()

def usage():
    log( """\
usage: %s command [options]
Commands:
    installed
    available
    install <mackage>
    predictInstall
    update
    upgrade
""" % sys.argv[0] )
    sys.exit(0)

def parse_args():
    try:
        opts, args = getopt.getopt(sys.argv[1:], '', [])
    except getopt.GetoptError, err:
        log( str(err) )
        usage()
        sys.exit(2)

    for opt in opts:
        # currently no options
        usage()
    
    if len(args) > 2 or len(args) < 1:
        usage()
    if args[0] not in ['installed', 'available', 'install', 'predictInstall', 'update', 'upgrade']:
        usage()
    else:
        global COMMAND_ARG, COMMAND
        COMMAND = args[0]
        if len(args) > 1:
            COMMAND_ARG = args[1]

parse_args()

class DevApt:
    @staticmethod
    def each_pkg_list_line():
        lines = []
        for filename in os.listdir(PREFIX + '/var/run/'):
            if "pkg-list" in filename:
                f = open(PREFIX + '/var/run/' + filename)
                for line in f:
                    lines.append(line)
        return lines

    @staticmethod
    def installed():
        packages = []
        for line in DevApt.each_pkg_list_line():
            if re.search("^Package: ", line):
                package = line.split()[1]
                packages.append( package )
                print( "%s 20.0" % package ) # print don't log
        p = subprocess.Popen(["sh","-c","dpkg --get-selections 'untangle*' | awk '{print $1}' | xargs dpkg-query -W"],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        for line in iter(p.stdout.readline, ''):
            if line.split()[0] not in packages:
                print( line.strip() ) # print don't log
        return 0
    
    @staticmethod
    def available():
        for line in DevApt.each_pkg_list_line():
            line = re.sub( '^XB-', '', line)
            print( line.rstrip() ) # print don't log
            if re.search("^Package: ", line):
                print( "Version: 20.0" ) # print don't log
        return 0
   
    @staticmethod
    def install(name):
        log("start")
        log("END PACKAGE LIST")
        log("done")
        return 0
        
    @staticmethod
    def update():
        log("start")
        log("apt-get update %s" % UPDATE_OPTS)
        log("done")
        return 0

    @staticmethod
    def upgrade():
        log("start")
        log("END PACKAGE LIST")
        log("done")
        return 0

    @staticmethod
    def predictInstall(pkg):
        return 0

class RealApt:
    @staticmethod
    def installed():
        p = subprocess.Popen(["sh","-c","dpkg --get-selections 'untangle*' | awk '{ if ($2 == \"install\") print $1}' | xargs dpkg-query -W"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        for line in iter(p.stdout.readline, ''):
            print( line.strip() ) # print don't log
    
    @staticmethod
    def available():
        p = subprocess.Popen(["sh","-c","apt-cache search '^untangle-' | awk '{ print $1 }' | xargs apt-cache show --no-all-versions"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        for line in iter(p.stdout.readline, ''):
            print( line.rstrip() ) # print don't log
   
    @staticmethod
    def install(pkg):
        log("start")
        log("downloading: \"%s\"" % pkg)

        recs = RealApt.get_recommends(pkg)
        log("RECS: %s" % recs)

        pkg_list = RealApt.get_pkg_list("apt-get install %s --print-uris %s %s" % (INSTALL_OPTS, pkg, recs))
        r = RealApt.download(pkg_list)
        if (r != 0):
            return r
        log("installing: \"%s\"" % pkg)
        
        p = subprocess.Popen(["sh","-c","apt-get install %s %s %s 2>&1" % (INSTALL_OPTS, pkg, recs)], stdout=subprocess.PIPE)
        for line in iter(p.stdout.readline, ''):
            log( line.strip() )
        p.wait()
        log("done")

        if p.returncode == 0:
            return 0
        else:
            return 1
        
    @staticmethod
    def update():
        log("start")
        log("apt-get update %s" % UPDATE_OPTS)

        p = subprocess.Popen(["sh","-c","apt-get update %s 2>&1" % UPDATE_OPTS], stdout=subprocess.PIPE)
        for line in iter(p.stdout.readline, ''):
            if not re.search('^W: (Conflicting distribution|You may want to run apt-get update to correct these problems)', line):
                log( line.strip() )
        p.wait()
        log("done")
        return 0

    @staticmethod
    def upgrade():
        log("start")
        log("apt-get dist-upgrade %s" % UPGRADE_OPTS)

        pkg_list = RealApt.get_pkg_list("apt-get dist-upgrade %s --print-uris" % UPGRADE_OPTS)
        r = RealApt.download(pkg_list)
        if (r != 0):
            return r

        RealApt.cmd_to_stderr("monit -c /etc/untangle/monit.conf unmonitor all")
        r = RealApt.cmd_to_stderr("apt-get dist-upgrade %s" % UPGRADE_OPTS)
        RealApt.cmd_to_stderr("monit -c /etc/untangle/monit.conf monitor all")

        log("done")
        return 0

    @staticmethod
    def predictInstall(pkg):
        ret = 0

        p = subprocess.Popen(["sh","-c","apt-get install -s %s 2>&1" % pkg], stdout=subprocess.PIPE)
        for line in iter(p.stdout.readline, ''):
            matcher = re.search('^Inst ([^ ]+)', line)
            if matcher:
                log( matcher.group(1) )
        
        p.wait()
        if p.returncode == 0:
            return 0
        else:
            return 1
    
    @staticmethod
    def get_recommends(pkg):
        p = subprocess.Popen(["sh","-c","apt-cache show %s" % pkg], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        for line in iter(p.stdout.readline, ''):
            matcher = re.search(r'^Recommends:(.*)$', line)
            if matcher:
                recs = matcher.group(1)
                pkgs = []
                for pkg_name in recs.split(","):
                    if "|" in pkg_name:
                        pkg_name = pkg_name.split("|")[0]
                    pkgs.append( pkg_name.strip() )
                return ' '.join(pkgs)
        return ""

    @staticmethod
    def get_pkg_list(apt_cmd):
        pkg_list = []

        p = subprocess.Popen(["sh","-c",apt_cmd], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        for line in iter(p.stdout.readline, ''):
            matcher = re.search(r'^\'(http://.*)\' ', line)
            if matcher:
                log(line)
                pkg_list.append( matcher.group(1) )
            matcher = re.search(r'.*ERROR.*', line)
            if matcher:
                global ERROR
                ERROR = line
        return pkg_list

    @staticmethod
    def cmd_to_stderr(cmd):
        p = subprocess.Popen(["sh","-c","%s 2>&1" % (cmd)], stdout=subprocess.PIPE )
        for line in iter(p.stdout.readline, ''):
            log( line.strip() )
        p.wait()
        if p.returncode == 0:
            return 0
        else:
            return 1
            
    @staticmethod
    def download(pkg_list):
        log("END PACKAGE LIST")
        retcode = 0

        tmpdir = tempfile.mkdtemp()
        for pkg in pkg_list:
            log("downloading: %s" % pkg)

            log( "wget --progress=dot -P %s %s" % (tmpdir, pkg) )
            exitcode = RealApt.cmd_to_stderr("wget --progress=dot -P %s %s" % (tmpdir, pkg))
            if exitcode == 0:
                log("DOWNLOAD SUCCEEDED: %s" % pkg)
            else:
                log("DOWNLOAD FAILED: %s" % str(ERROR))
                retcode = 1

            p = subprocess.Popen(["sh", "-c", "mv -f %s/*.deb /var/cache/apt/archives" % tmpdir])
            p.wait()

        p = subprocess.Popen(["rm","-rf","%s" % tmpdir])
        p.wait()
        return retcode

if PREFIX != "":
    apt = DevApt()
else:
    apt = RealApt()

log_date( os.path.basename(sys.argv[0]) + " " + COMMAND )

if COMMAND == "installed":
    rc = apt.installed()
elif COMMAND == "available":
    rc = apt.available()
elif COMMAND == "install":
    rc = apt.install(COMMAND_ARG)
elif COMMAND == "predictInstall":
    rc = apt.predictInstall(COMMAND_ARG)
elif COMMAND == "update":
    rc = apt.update()
elif COMMAND == "upgrade":
    rc = apt.upgrade()
else:
    usage()

log_date( os.path.basename(sys.argv[0]) + " " + COMMAND + " done." )

sys.exit(rc)
    
