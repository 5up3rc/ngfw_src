#!/usr/bin/ruby

require 'logger'
require 'dbi'
require 'set'
require 'syslog'
require 'socket'

PORT = 2345

class SqlHelper
  def SqlHelper.log_sql_error(msg, e)
    Syslog.warn <<MSG
#{msg}
Error code: #{e.err}
Error message: #{e.errstr}
Error SQLSTATE: #{e.state}
MSG
  end

  def initialize(dbh)
    @dbh = dbh
  end

  def next_id()
    @dbh.select_one(<<SQL).first
SELECT nextval('hibernate_sequence')
SQL
  end

  def add_column(table, column, type, options)
    @dbh.do(<<SQL)
ALTER TABLE #{table} ADD COLUMN #{column} #{type}
SQL
    yield

    if options[:not_null]
      @dbh.do(<<SQL)
ALTER TABLE #{table} ALTER COLUMN #{column} SET NOT NULL
SQL
    end
  end

  def remove_columns(table, columns, cascade = true)
    [columns].flatten.each do |c|
      begin
      @dbh.do(<<SQL)
ALTER TABLE #{table} DROP COLUMN #{c}#{' CASCADE' if cascade}
SQL
      rescue DBI::DatabaseError => e
        SqlHelper.log_sql_error("Could not remove column #{c}", e)
      end
    end
  end

  def rename_column(table, old_name, new_name)
    @dbh.do(<<SQL)
ALTER TABLE #{table} RENAME COLUMN #{old_name} TO #{new_name}
SQL
  end

  def drop_tables(tables, cascade = true)
    begin
      @dbh.do(<<SQL)
DROP TABLE #{[tables].flatten.join(', ')}#{' CASCADE' if cascade}
SQL
    rescue DBI::DatabaseError => e
      SqlHelper.log_sql_error("Could not remove tables #{[tables].flatten.join(', ')}", e)
    end
  end

  def synchronize_table(table_name, primary_key, list)
    keys = get_keys(primary_key, list)
    bad_keys = [ ]
    update_row_keys = Set.new

    @dbh.execute("SELECT #{primary_key.to_s} FROM #{table_name}") do |r|
      r.fetch do |e|
        k = e.first
        if keys.member?(k)
          update_row_keys << k
        else
          bad_keys << k
        end
      end
    end

    new_row_keys = keys - update_row_keys.to_a
    new_rows = list.select { |e| new_row_keys.member?(e[primary_key]) }
    insert_rows(table_name, new_rows)

    update_rows = list.select { |e| update_row_keys.member?(e[primary_key]) }
    update_rows(table_name, primary_key, update_rows)

    @dbh.prepare("DELETE FROM #{table_name} WHERE #{primary_key} = ?") do |ps|
      bad_keys.each do |e|
        ps.execute(e)
      end
    end
  end

  private

  def get_keys(primary_key, list)
     list.inject(Set.new) { |m, o| m << o[primary_key] }.to_a
  end

  def get_all_columns(rows)
    rows.inject(Set.new) do |m, o|
      m += o.instance_of?(Hash) ? o.keys : o.field_names
    end.to_a
  end

  def bind_values(columns, row)
    columns.map { |c| row[c] }
  end

  def get_insert_statement(table, columns)
    <<SQL
INSERT INTO #{table} (#{columns.join(', ')})
VALUES (#{columns.map {|e| '?'}.join(', ') })
SQL
  end

  def get_update_statement(table, primary_key, columns)
    <<SQL
UPDATE #{table}
SET #{columns.map { |c| "#{c} = ?"}.join(', ')}
WHERE #{primary_key} = ?
SQL
  end

  def insert_rows(table, rows)
    columns = get_all_columns(rows)
    @dbh.prepare(get_insert_statement(table, columns)) do |ps|
      rows.each do |r|
        ps.execute(*bind_values(columns, r))
      end
    end
  end

  def update_rows(table, primary_key, rows)
    columns = get_all_columns(rows).reject { |c| primary_key == c }
    @dbh.prepare(get_update_statement(table, primary_key, columns)) do |ps|
      rows.each do |r|
        ps.execute(*bind_values(columns + [primary_key], r))
      end
    end
  end
end

class SchemaUpdater
  def update_schema(dbh)
    Syslog.warn('update_schema() not implemented')
  end

  def initialize(dbh)
    @dbh = dbh
    @log = LOG
  end
end

def bad_args(argv)
  Syslog.err "usage: update-schema [ settings | events ] [ uvm | node ]"
  Syslog.err "(we were called with ARGV='#{argv.join(', ')}')"
end

def get_column(type)
  case type
  when 'settings'
    'settings_version'
  when 'events'
    'events_version'
  else
    Syslog.err "Wrong type: '#{type}'"
  end
end

def get_latest_version(schema_dir, type)
  begin

    Dir.entries(schema_dir).map do |f|
      if /#{type}-convert-([0-9]+)\.(sql|rb)$/ =~ f
        $1.to_i
      else
        nil
      end
    end.reject { |e| e.nil? }.max

  rescue Errno::ENOENT 

  rescue
    raise $!

  end
end

def get_inst_version(dbh, component, type)
  column = get_column(type)

  ps = dbh.prepare(<<SQL)
SELECT #{column} FROM split_schema_ver
WHERE component = ? AND #{column} IS NOT NULL
SQL
  ps.bind_param(1, component)
  ps.execute
  e = ps.entries.first
  e.nil? ? nil : e.first.to_i
end

def update_schema_ver(dbh, component, type, version)
  ps = dbh.prepare(<<SQL)
select * from split_schema_ver where component = ?
SQL
  ps.bind_param(1, component)
  ps.execute

  unless ps.any?
    ps = dbh.prepare(<<SQL)
INSERT INTO split_schema_ver (component, settings_version, events_version)
    VALUES (?, null, null);
SQL
    ps.bind_param(1, component)
    ps.execute()
  end

  ps = dbh.prepare(<<SQL)
UPDATE split_schema_ver SET #{get_column(type)} = ?
    WHERE component = ?
SQL
  ps.bind_param(1, version)
  ps.bind_param(2, component)
  ps.execute()
end

def run_sql_file(file)
  Syslog.info "Running SQL file: #{file}"
  Kernel.system "/usr/bin/psql -X -U postgres uvm -f #{file} 2>&1| grep -v 'ERROR:.*already exists' | logger -i -t ut-update-schema -p local3.info"
end

def run_rb_file(dbh, file)
  Syslog.info "Running RB file: #{file}"
  updater = SchemaUpdater.new(dbh)
  updater.instance_eval(File.readlines(file).join("\n"))
  updater.update_schema()
end

def run_file(dbh, file)
  if /\.sql$/ =~ file
    run_sql_file(file)
  elsif /\.rb$/ =~ file
    run_rb_file(dbh, file)
  else
    Syslog.error("Don't know how to handle: #{file}")
    raise BadFileType
  end
end

def run_schema_init(dbh, dir, type)
  f = ['rb', 'sql'].map { |e| "#{dir}/#{type}-schema.#{e}" }.find { |f| File.exist? f }
  unless f.nil?
    run_file(dbh, f)
  end
end

def run_schema_convert(dbh, dir, type, n)
  f = ['rb', 'sql'].map { |e| "#{dir}/#{type}-convert-#{n}.#{e}" }.find { |f| File.exist? f }
  run_file(dbh, f)
end

def setup_schema(dbh)
  begin
    dbh.do('CREATE SCHEMA settings')
  rescue
  end

  unless dbh.tables.any? { |t| 'split_schema_ver' == t }
    dbh.do(<<SQL)
CREATE TABLE settings.split_schema_ver(component text,
                                       settings_version int4,
                                       events_version int4)
SQL
    dbh.do(<<SQL)
ALTER TABLE settings.split_schema_ver
ADD CONSTRAINT schema_ver_pkey PRIMARY KEY (component)
SQL

    dbh.do(<<SQL)
ALTER TABLE split_schema_ver ALTER COLUMN component SET NOT NULL
SQL
  end
end

Syslog.open('ut-update-schema', Syslog::LOG_PID | Syslog::LOG_NDELAY, Syslog::LOG_LOCAL3)
SCHEMA_HOME='@UVM_SCHEMA@'

server = TCPServer.open(PORT)
Syslog.info("Server started on port #{PORT}")
client = server.accept

loop {
  begin
    Syslog.open('ut-update-schema', Syslog::LOG_PID | Syslog::LOG_NDELAY, Syslog::LOG_LOCAL3)
  rescue
  end

  str = client.gets
  next if str.nil? or str.empty?
  str.chop!
  array = str.split(/\s+/)
  if array.length == 1 then
    if array[0].downcase == 'quit' then
      exit 0
    else
      client.puts "error"
      next
    end
  elsif array.length == 2 then
    type, component = array
    if not (type == 'settings' or type == 'events') then
      bad_args(array)
      client.puts "error"
      next
    end
  end
  
  schema_dir="#{SCHEMA_HOME}/#{component}"

  Syslog.info "*** BEGIN update-schema for type: #{type} component: #{component}"

  begin
    dbh = DBI.connect('DBI:Pg:uvm', 'postgres')

    setup_schema(dbh)

    latest_version = get_latest_version(schema_dir, type)
    inst_version = get_inst_version(dbh, component, type)

    Syslog.info "Component #{component} Type: #{type} Installed schema: #{inst_version} Latest schema version: #{latest_version}"

    if inst_version.nil?
      Syslog.info 'Initializing schema'
      run_schema_init(dbh, schema_dir, type)
      update_schema_ver(dbh, component, type, latest_version)
    elsif latest_version.nil?
      Syslog.info 'No schema for this component.'
    elsif inst_version > latest_version
      Syslog.error 'Installed version greater than latest version'
    elsif inst_version < latest_version
      Syslog.info "Converting schema from #{inst_version} to #{latest_version}"
      (inst_version + 1).upto(latest_version) do |n|
        run_schema_convert(dbh, schema_dir, type, n)
        update_schema_ver(dbh, component, type, n)
      end
    else
      Syslog.info 'Schema is up-to-date, initializing schema just in case'
      run_schema_init(dbh, schema_dir, type)
    end

  ensure
    dbh.disconnect if dbh
    client.puts "done"
    Syslog.info "*** END update-schema for type: #{type} component: #{component}"
    Syslog.close
  end
}
