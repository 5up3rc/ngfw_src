#!/usr/bin/env python

import sys
sys.path.insert(0,'@PREFIX@/usr/lib/python2.5/')
import subprocess
import shlex
import time
import socket
import os
import getopt
import datetime
import random
import signal
import base64
import re

#import ssl # We must use stunnel to do the SSL until python 2.6 or greater
from uvm import Manager
from uvm import Uvm

# TODO:
# FIXME add fall back to IP if DNS doesn't resolve for cmd.untangle.com and supportssh.untangle.com
# 

UNTANGLE_CMD_PORTS = [443,80,4443,587,993,995,8080,53,25]
RETRY_TIME_LONG = 60
RETRY_TIME_SHORT = 10
STUNNEL_LOCAL_PORT = 808
CERTS_FILE = '/tmp/pyconnector/certs.pem'

uvm = None
cmd_server = "cmd.untangle.com"
command_socket = None
command_socket_file = None
debug_level = 1

def usage():
     print """\
usage: %s [options]
Options:
  -h | --help                   help - print this message
  -l <log>       | --log=<log>          output to specified log instead of stdout/stderr
  -d <debug_lvl> | --debug-level=<0-2>  debug verbosite level
  -s <server>    | --server=<server>    specify a cmd server (default: cmd.untangle.com)
""" % sys.argv[0]

def system(cmd_str):
     args = shlex.split(cmd_str)
     proc = subprocess.Popen(args, stdin=None, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
     (stdout, stderr) = proc.communicate()
     return stdout + stderr

def debug(str, level=1):
     global debug_level
     if level <= debug_level:
          print "%s: %s" % (datetime.datetime.now().strftime("%Y-%m-%d %H:%M"), str)
          sys.stdout.flush()

def write_cert_file():
     global CERTS_FILE
     f = open(CERTS_FILE, 'w')
     f.write('-----BEGIN CERTIFICATE-----\n')
     f.write('MIIDGjCCAoOgAwIBAgIJAJWdC06wNHyNMA0GCSqGSIb3DQEBBQUAMIGlMQswCQYD\n')
     f.write('VQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTESMBAGA1UEBwwJU3Vubnl2YWxl\n')
     f.write('MRQwEgYDVQQKDAtVbnRhbmdsZSBDQTEYMBYGA1UECwwPY2EudW50YW5nbGUuY29t\n')
     f.write('MRgwFgYDVQQDDA9jYS51bnRhbmdsZS5jb20xIzAhBgkqhkiG9w0BCQEWFGRtb3Jy\n')
     f.write('aXNAdW50YW5nbGUuY29tMB4XDTEyMDgwOTIxMzU0NVoXDTIyMDgwNzIxMzU0NVow\n')
     f.write('gaUxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRIwEAYDVQQHDAlT\n')
     f.write('dW5ueXZhbGUxFDASBgNVBAoMC1VudGFuZ2xlIENBMRgwFgYDVQQLDA9jYS51bnRh\n')
     f.write('bmdsZS5jb20xGDAWBgNVBAMMD2NhLnVudGFuZ2xlLmNvbTEjMCEGCSqGSIb3DQEJ\n')
     f.write('ARYUZG1vcnJpc0B1bnRhbmdsZS5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ\n')
     f.write('AoGBALYepW5elyeiDDHAYC7UMD+3VMj3Wp+X69r+APllVTJBlaNI+rmdmR0IUuRu\n')
     f.write('0P3wpcZm1OooaoUU7q2F2zYbhyqtPB9ULPzNyQ0ys2KvXmauSkmx9He6ysDiWHmD\n')
     f.write('F7MTxhR/I7WI1n6E+7EIpP+CGbDYd2w5nWFzWhhx28936RwPAgMBAAGjUDBOMB0G\n')
     f.write('A1UdDgQWBBQRNxGoQB+2uSfjfxvJp7Uq3zHGADAfBgNVHSMEGDAWgBQRNxGoQB+2\n')
     f.write('uSfjfxvJp7Uq3zHGADAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GBAJOy\n')
     f.write('tlQvH4BGnrvCalM+8v/UEL/UYDziJmrv6kKW2OVrdp83a2iLLwhkAwBIEAvmgJpD\n')
     f.write('iIYjmzyqkwC3tJOREcN5XKo83AKKxgIB0UWwH6Vo4k6XlxwE8CGfXwl++6/RAmAu\n')
     f.write('KZFJgDBndnYz9thw4TuIjrQriZDPRVcpCz9T/tX3\n')
     f.write('-----END CERTIFICATE-----\n')
     f.write('-----BEGIN CERTIFICATE-----\n')
     f.write('MIICujCCAiMCAQEwDQYJKoZIhvcNAQEFBQAwgaUxCzAJBgNVBAYTAlVTMRMwEQYD\n')
     f.write('VQQIDApDYWxpZm9ybmlhMRIwEAYDVQQHDAlTdW5ueXZhbGUxFDASBgNVBAoMC1Vu\n')
     f.write('dGFuZ2xlIENBMRgwFgYDVQQLDA9jYS51bnRhbmdsZS5jb20xGDAWBgNVBAMMD2Nh\n')
     f.write('LnVudGFuZ2xlLmNvbTEjMCEGCSqGSIb3DQEJARYUZG1vcnJpc0B1bnRhbmdsZS5j\n')
     f.write('b20wHhcNMTIwODA5MjEzNjM5WhcNMjIwODA3MjEzNjM5WjCBpDELMAkGA1UEBhMC\n')
     f.write('VVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEjAQBgNVBAcMCVN1bm55dmFsZTERMA8G\n')
     f.write('A1UECgwIVW50YW5nbGUxGTAXBgNVBAsMEGNtZC51bnRhbmdsZS5jb20xGTAXBgNV\n')
     f.write('BAMMEGNtZC51bnRhbmdsZS5jb20xIzAhBgkqhkiG9w0BCQEWFGRtb3JyaXNAdW50\n')
     f.write('YW5nbGUuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDUeVn2SrWChvlb\n')
     f.write('RjtymxCyH+1QUaS2x34K+7oYxoa5NPs7u85bHpWM7HeFiN3gdZ1Qf+B6wkwa2spG\n')
     f.write('coir2wqp7udrEX5PipnHXVPqtOLExE5yNcwJ5kEmcd0l/LUh1I4Y7mXebqrrSvCE\n')
     f.write('j3P1xQF0mZ/gkFI0xjaFTKr6wYSxwwIDAQABMA0GCSqGSIb3DQEBBQUAA4GBAFne\n')
     f.write('oaoFbMan9WBqnPkCbTdDmMdOMesIBRfr3YIzzbfHtemfX0v+nMdsL8XdFc2dBlhl\n')
     f.write('UP6dCmvX3ZJtF/6O45lq+8tjVbN0PIECSDDNHuppheKoI6STWaD2WCklwLVqItw0\n')
     f.write('0oHL7BzL8/3QuL3xEWsMwAHhF7Mjvs683F9JhZ81\n')
     f.write('-----END CERTIFICATE-----\n')
     f.close()

def connect():
     global command_socket
     global command_socket_file
     global cmd_server
     global UNTANGLE_CMD_PORTS
     if command_socket != None:
          return

     debug("Connecting to %s:%i..." % (cmd_server,UNTANGLE_CMD_PORTS[0]))

     # start stunnel (python2.6 will not need this)
     write_cert_file()
     cmd_str = "sudo killall -9 stunnel4 >/dev/null 2>&1 ; sudo stunnel -c -d localhost:%i -r %s:%i -A %s -v 3 -D 6" % (STUNNEL_LOCAL_PORT, cmd_server, UNTANGLE_CMD_PORTS[0], CERTS_FILE)
     #debug(cmd_str)
     os.system(cmd_str)
   
     # rotatet the port list so it tries a different port next time
     UNTANGLE_CMD_PORTS = UNTANGLE_CMD_PORTS[1:] + UNTANGLE_CMD_PORTS[:1]

     try:
          command_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
          # in python 2.6 or later connect directly
          # command_socket = ssl.wrap_socket( command_socket, keyfile="xxx", certfile="xxx", xxx)
          # command_socket.connect( ( cmd_server, UNTANGLE_CMD_PORTS[0] ) )
          # in python 2.5 connect to stunnel
          command_socket.connect( ( "127.0.0.1", STUNNEL_LOCAL_PORT ) )
     except Exception,e:
          sys.stderr.write("Failed to connect: (%s)\n" % e )
          command_socket = None
          return

     command_socket_file = command_socket.makefile("rb")

def run_cmd(cmd_str):
     debug("Command Received.")
     debug("Received: %s" % cmd_str.strip(), 2)
     global uvm
     if uvm == None:
          uvm = Uvm().getUvmContext( hostname="127.0.0.1", username=None, password=None, timeout=30 )
     try:
          result = eval(cmd_str.strip())
          return str(result)
     except Exception,e:
          uvm = None
          debug("Exception: %s" % e)
          return "Error (%s)" % type(e)

def read_from_cmd():
     global command_socket, command_socket_file
     global RETRY_TIME_SHORT, RETRY_TIME_LONG

     # connect to center (if necessary)
     if command_socket == None:
          connect()
     if command_socket == None:
          debug("Failed to connect. Retrying in %i seconds..." % RETRY_TIME_LONG)
          time.sleep(RETRY_TIME_LONG); return;

     # read from center
     try:
          cmd = command_socket_file.readline()
          if cmd == "":
               sys.stderr.write("Disconnected. Retrying in %i seconds...\n" % RETRY_TIME_SHORT)
               command_socket = None
               time.sleep(RETRY_TIME_SHORT); return;
     except Exception,e:
          # this can happen frequently using stunnel 
          # because it connects to stunnel even when the server is unreachable
          # as such, sleep for LONG time
          sys.stderr.write("Failed to read: (%s)\n" % e )
          command_socket = None
          time.sleep(RETRY_TIME_LONG); return;

   # run command
     output = run_cmd(cmd)
     debug("Result: %s" % output.strip())
     try:
          output_len = len(output)
          command_socket.send(str(output_len) + "\n")
          command_socket.send(str(output))
     except Exception,e:
          sys.stderr.write("Failed to write: (%s)\n" % e )
          command_socket = None

def check_pid_file():
     pid_filename = "/var/run/ut-pyconnector.pid"
     old_pid = None
     if os.access(pid_filename, os.F_OK):
          pid_file = open(pid_filename, "r")
          pid_file.seek(0)
          old_pid = pid_file.readline().strip()

     # if theres already a pid file and its not me, exit
     if (os.path.exists("/proc/%s" % old_pid)):
          if (str(os.getpid()) != old_pid):
               print "ut-pyconnector already running! pid: %s" % old_pid
               sys.exit(1)
          else:
               debug("removing stale pid file: %s" % old_pid)
               os.remove(pid_filename)

     pid_file = open(pid_filename, "w")
     pid_file.write("%s" % os.getpid())
     pid_file.close()

def parse_args():
     try:
          opts, args = getopt.getopt(sys.argv[1:], "hl:s:d:", ['help', 'log=', 'server=', 'debug-level=' ])
     except getopt.GetoptError, err:
          print str(err)
          usage()
          sys.exit(2)

     for opt in opts:
          k, v = opt
          if k == '-h' or k == '--help':
               usage()
               sys.exit(0)
          elif k == '-l' or k == '--log':
               logfile = open(v,"w")
               sys.stdout = logfile
               sys.stderr = logfile
          elif k == '-s' or k == '--server':
               global cmd_server
               cmd_server = v
          elif k == '-d' or k == '--debug-level':
               global debug_level
               debug_level = int(v)

#
# Main
#
if __name__ == "__main__":
     try: os.makedirs("/tmp/pyconnector") 
     except: pass
     parse_args()
     check_pid_file()

     while True: 
          debug("")
          read_from_cmd()


