#!/bin/dash

exec 2> /dev/null

DNS_MASQ_CONF="/etc/dnsmasq.conf"

PROPERTY_NET_CONF="com.untangle.networking.net-conf"
PROPERTY_BRIDGE_CONF="com.untangle.networking.bridge-conf"
PROPERTY_DNS_1="com.untangle.networking.dns-1"
PROPERTY_DNS_2="com.untangle.networking.dns-2"
PROPERTY_DEFAULT_GW="com.untangle.networking.default-gateway"
PROPERTY_DDNS_EN="com.untangle.networking.ddns-en"
PROPERTY_HOSTNAME="com.untangle.networking.hostname"
PROPERTY_DHCP_EN="com.untangle.networking.dhcp-enabled"
PROPERTY_DHCP_START="com.untangle.networking.dhcp-start"
PROPERTY_DHCP_END="com.untangle.networking.dhcp-end"
PROPERTY_DHCP_DEFAULT_GW="com.untangle.networking.dhcp-default-gateway"
PROPERTY_DNS_EN="com.untangle.networking.dns-enabled"
PROPERTY_DNS_LOCAL_DOMAIN="com.untangle.networking.dns-local-domain"
PROPERTY_DHCP_DNS_SERVERS="com.untangle.networking.dhcp-dns-servers"

# This is the interface that has all of the aliases on it for PPPoE.
# In the bridge case, this is the name of the bridge for the external
# interface.  In the non-bridge case, this is the name of the
# interface that is being used to connect over PPPoE.
pppoe_interface()
{
    test -f /etc/network/interfaces || return
    
    ## Grab the provider.
    local t_provider=`awk '/ppp0/ { is_ppp = true }; /^[\t ]*provider/ { sub( /^[\t ]*provider[\t ]*/, "" ) ; if ( is_ppp == true ) print }' /etc/network/interfaces`

    ## check if there is actually a provider
    test -z "${t_provider}" && return
    
    ## Now grab the interface that is linked to this provider.
    t_provider="/etc/ppp/peers/${t_provider}"
    test -f ${t_provider} || return

    ## Now print out the name of the interface that is used
    awk --assign print_interface=true  --assign interface="" \
        '/^[ \t]*plugin rp-pppoe.so/ { interface=$0 ; sub( /[ \t]*plugin rp-pppoe.so[ \t]*/, "", interface ) } ; /^\# bridge_configuration:/ { print $3 ; print_interface = false ; exit } ; END { if ( print_interface && interface != "" ) print interface }' ${t_provider}
}

pppoe_awk_script()
{
    ## ppp_aliases is broken out so that those always come second.
    cat <<'EOF'
/^[0-9]/ { interface = $2 ; sub( ":$", "", interface ) ; if ( interface != "ppp0" && interface != pppoe  ) { printf ":::%s", interface }} ;
/^ *inet.*brd.*scope global/ { if ( interface == pppoe ) { aliases = aliases ";" $2  } else { printf ";%s", $2 }} ;
/^ *inet.*peer.*scope global/ { ppp_aliases= ppp_aliases ";" $2 "/31" } ;
END { printf ":::%s%s%s", pppoe_name, aliases, ppp_aliases ; printf "\n"  }
EOF
}

## This returns a string of the form:
## [:::<interface-name>[;<ip-address>/<netmask-cidr>]*]*
network_configuration()
{                   
    ## Determine if this needs to glob together the configuration for another interface.
    local t_pppoe
    

    ## Not sure why, but 'local t_pppoe=`pppoe_interface`' doesn't work here.
    t_pppoe=$1
    
    if [ -z "${t_pppoe}" ]; then
        ip addr show | awk '/^[0-9]/ { interface = $2 ; sub( ":$", "", interface ) ; printf ":::%s", interface } ; /^ *inet.*brd.*scope global/ { printf ";%s", $2 } ;  END { printf "\n"  }' 
    else
        ## This is the name to tell netcap.
        local t_pppoe_name="ppp0"

        ## If using a bridge, then the addresses should all be on the bridge.
        test -d "/sys/class/net/${t_pppoe}/bridge" && t_pppoe_name="${t_pppoe}"
        
        ## Dump the list of interfaces the same way, but this time (script is just too long
        ## to put in on the command line, and it is too annoying to create a separate file.
        ip addr show | awk --assign pppoe="${t_pppoe}" --assign pppoe_name="${t_pppoe_name}" "`pppoe_awk_script`"
    fi
}

## This returns a string of the form:
## [:::<bridge-name>[;<bridge-interface]*]*
bridge_configuration()
{
    ## Determine if this needs to glob together the configuration for another interface.
    local t_pppoe
    t_pppoe=$1

    if [ -z "${t_pppoe}" ]; then
        find /sys/class/net/ -path '*/brif/*' \
            | sort \
            | awk '{ split( $0, path, "/" ) ; if ( path[5] != bridge ) { bridge = path[5] ; printf ":::%s", bridge } ; printf ";%s", path[7] } END { printf "\n" }'
    else
        ## Append ppp0 to whatever the ppp0 interface is.
        find /sys/class/net/ -path '*/brif/*' \
            | sort \
            | awk --assign pppoe_interface=${t_pppoe} '{ split( $0, path, "/" ) ; if ( path[5] != bridge ) { bridge = path[5] ; printf ":::%s", bridge; if ( bridge == pppoe_interface ) printf ";ppp0" } ; printf ";%s", path[7] } END { printf "\n" }'
    fi
}

get_default_gateway()
{
    ip route show | awk '/default/ { print $3 }'
}

## Here goes nothing, several calls to awk to accomplish what could be done in one.
get_dns_1()
{
    if [ -f ${DNS_MASQ_CONF} ] ; then
        awk 'BEGIN { server = "yes" } /server/ { gsub( "server=", "" ) ; if ( server == "yes" ) { print ; server = "no" }}' ${DNS_MASQ_CONF}
    fi
}

get_dns_2()
{
    if [ -f ${DNS_MASQ_CONF} ] ; then
        awk 'BEGIN { server = "no" } /server/ { gsub( "server=", "" ) ; if ( server == "no" ) { server = "yes" } else if ( server == "yes" ) { print ; server = "done" }}' ${DNS_MASQ_CONF}
    fi
}

get_dhcp_enabled()
{
    if [ -f ${DNS_MASQ_CONF} ] ; then
        grep -q "dhcp-range" ${DNS_MASQ_CONF} && echo "true"
    fi
}

get_dhcp_start()
{
    if [ -f ${DNS_MASQ_CONF} ] ; then
        awk '/^dhcp-range=/ { sub( "dhcp-range=", "" ) ; split( $0, v, "," )  ; print v[1] } ' ${DNS_MASQ_CONF}
    fi
}

get_dhcp_end()
{
    if [ -f ${DNS_MASQ_CONF} ] ; then
        awk '/^dhcp-range=/ { sub( "dhcp-range=", "" ) ; split( $0, v, "," )  ; print v[2] } ' ${DNS_MASQ_CONF}
    fi
}

## This is the gateway the dhcp server would recommend in its leases.
get_dhcp_default_gateway()
{
    if [ -f ${DNS_MASQ_CONF} ] ; then
        awk '/^dhcp-option=3,/ { sub( "dhcp-option=3,", "" ) ; print } ' ${DNS_MASQ_CONF}
    fi
}

## This is the gateway the DNS Servers the DHCP server will recommend in its leases.
get_dhcp_dns_servers()
{
    if [ -f ${DNS_MASQ_CONF} ]; then
        awk '/^dhcp-option=6,/ { sub( "dhcp-option=6,", "" ) ; print } ' ${DNS_MASQ_CONF}
    fi
}

get_dns_enabled()
{
    if [ -f ${DNS_MASQ_CONF} ]; then
        grep -q '# DNS Server disabled, not saving hosts.' ${DNS_MASQ_CONF} || echo "true"
    fi
}

get_dns_local_domain()
{
    if [ -f ${DNS_MASQ_CONF} ]; then
        awk '/^domain-suffix=/ { sub( "domain-suffix=", "" ) ; print } ' ${DNS_MASQ_CONF}
    fi
}

get_is_ddns_running()
{
    # Either of these processes are running means dynamic dns is running.
    pgrep '(ddclient|no-ip)' > /dev/null 2>&1 && echo "true"
}

get_properties()
{
    local t_pppoe_interface
    ## Not sure why, but 'local t_pppoe_interface=`pppoe_interface`' doesn't work here.
    t_pppoe_interface=`pppoe_interface`

    echo "${PROPERTY_NET_CONF}=`network_configuration ${t_pppoe_interface}`"
    echo "${PROPERTY_BRIDGE_CONF}=`bridge_configuration ${t_pppoe_interface}`"
    echo "${PROPERTY_DNS_1}=`get_dns_1`"
    echo "${PROPERTY_DNS_2}=`get_dns_2`"
    echo "${PROPERTY_DEFAULT_GW}=`get_default_gateway`"
    echo "${PROPERTY_HOSTNAME}=`hostname`"
    echo "${PROPERTY_DHCP_EN}=`get_dhcp_enabled`"
    echo "${PROPERTY_DHCP_START}=`get_dhcp_start`"
    echo "${PROPERTY_DHCP_END}=`get_dhcp_end`"
    echo "${PROPERTY_DHCP_DEFAULT_GW}=`get_dhcp_default_gateway`"
    echo "${PROPERTY_DHCP_DNS_SERVERS}=`get_dhcp_dns_servers`"
    echo "${PROPERTY_DNS_EN}=`get_dns_enabled`"
    echo "${PROPERTY_DNS_LOCAL_DOMAIN}=`get_dns_local_domain`"
    echo "${PROPERTY_DDNS_EN}=`get_is_ddns_running`"
}
 
get_properties   

exit 0

