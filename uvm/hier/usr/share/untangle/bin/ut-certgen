#!/bin/dash

OPENSSL_CONF="@PREFIX@/usr/share/untangle/conf/ut-openssl.cnf"
OPENSSL_TOOL="/usr/bin/openssl"
CERT_PATH="/var/cache/untangle-https"
TEMP="/dev/shm"

UT_ROOT_PATH="/usr/share/untangle/settings/untangle-certificates"

# Since we call this script to generate mitm certificates on the fly we must
# use a random source that will not block.  All the security articles I found
# indicate /dev/urandom has plenty of entropy given what we're doing here.
RANDFILE="/dev/urandom"

show_usage()
{
echo " "
echo "  USAGE: https-certgen certfile subject [ alternates ]"
echo " "
echo "  certfile = www.domain.com"
echo "  subject = /C=US/ST=California/L=Sunnyvale/O=Untangle/OU=Security/CN=www.domain.com"
echo "  alternates = DNS:ftp.domain.com,DNS:mail.domain.com"
echo " "
}

# First argument should be the destination filename for the new cert.  Since
# the origin cert CN might include a wildcard, the Java code will first
# convert the filename to all lower case and the replace any *'s with X's
if [ -z "$1" ]; then
    show_usage
    exit 1
fi

# Second argument should be the subject field for the generated certificate
if [ -z "$2" ]; then
    show_usage
    exit 2
fi

# Third argument is the optional string to be placed in the certificate
# subjectAlternativeName field.  When provided, we use a special CA section
# in the openssl.conf file that will include the list in the generated
# certificate.  When absent, we use a different CA section without the
# extension.  We have to define something in both cases since openssl will
# throw an error trying to read an empty environment variable even for
# config sections that aren't actually used.
if [ ! -z "$3" -a "$3" != "" ]; then
    UT_ROOT_MODE="CA_sanlist"
    UT_SAN_LIST="$3"
else
    UT_ROOT_MODE="CA_onehost"
    UT_SAN_LIST="empty"
fi

# export all environment variables referenced in our openssl config file
export UT_ROOT_PATH
export UT_ROOT_MODE
export UT_SAN_LIST
export RANDFILE

# if either of the root certificate files are missing we bail
if [ ! -r $UT_ROOT_PATH/untangle.key -o ! -r $UT_ROOT_PATH/untangle.crt ]; then
    echo "Unable to locate the root certificate authority files"
    exit 3
fi

# make sure the destination path for certificates exists
if [ ! -r $CERT_PATH ]; then
    mkdir -p $CERT_PATH
fi

SERIAL=`cat $UT_ROOT_PATH/serial.txt`

if [ "$1" = "REQUEST" ]; then
    # for a server CSR request we generate a new CSR with the existing key
    $OPENSSL_TOOL req -batch -nodes -config $OPENSSL_CONF -new -key $UT_ROOT_PATH/apache.key -out $TEMP/server.csr -subj "$2"
else
    # not a server CSR request so generate a new CSR and sign with our CA cert
    $OPENSSL_TOOL req -batch -nodes -config $OPENSSL_CONF -newkey rsa:2048 -keyout $TEMP/server.key -out $TEMP/server.csr -subj "$2"
    $OPENSSL_TOOL ca -batch -config $OPENSSL_CONF -policy policy_anything -startdate 100102030405Z -enddate 380102030405Z -out $TEMP/server.crt -outdir $TEMP -infiles $TEMP/server.csr
fi

if [ "$1" = "APACHE" ]; then
    # when generating the Apache server certificate we keep a copy
    # of the CRT and KEY files and then dump then into a PEM file
    cp $TEMP/server.key $UT_ROOT_PATH/apache.key
    grep -A 1000 BEGIN $TEMP/server.crt > $UT_ROOT_PATH/apache.crt
    cat $UT_ROOT_PATH/apache.key $UT_ROOT_PATH/apache.crt > $UT_ROOT_PATH/apache.pem
elif [ "$1" = "REQUEST" ]; then
    # when generating a server CSR we just copy the file already created
    cp $TEMP/server.csr $UT_ROOT_PATH/apache.csr
else
    # for all other put the signed server key and cert into a PKCS12 file
    $OPENSSL_TOOL pkcs12 -passout pass:password -export -name default -in $TEMP/server.crt -inkey $TEMP/server.key -out "$CERT_PATH/$1"
fi

# Cleanup the working files we created
rm -f $TEMP/server.key
rm -f $TEMP/server.csr
rm -f $TEMP/server.crt
rm -f $TEMP/$SERIAL.pem

