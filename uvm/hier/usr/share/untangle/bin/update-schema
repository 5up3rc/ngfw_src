#!/usr/bin/ruby

require 'logger'
require 'dbi'
require 'set'

LOG_FILE = '@UVM_LOG@/schema.log'
LOG = Logger.new(LOG_FILE, 10, 1048576)
STDOUT.reopen(LOG_FILE, 'a')
STDERR.reopen(LOG_FILE, 'a')

class SqlHelper
  def SqlHelper.log_sql_error(msg, e)
    LOG.warn <<MSG
#{msg}
Error code: #{e.err}
Error message: #{e.errstr}
Error SQLSTATE: #{e.state}
MSG
  end

  def initialize(dbh)
    @dbh = dbh
  end

  def next_id()
    @dbh.select_one(<<SQL).first
SELECT nextval('hibernate_sequence')
SQL
  end

  def add_column(table, column, type, options)
    @dbh.do(<<SQL)
ALTER TABLE #{table} ADD COLUMN #{column} #{type}
SQL
    yield

    if options[:not_null]
      @dbh.do(<<SQL)
ALTER TABLE #{table} ALTER COLUMN #{column} SET NOT NULL
SQL
    end
  end

  def remove_columns(table, columns, cascade = true)
    [columns].flatten.each do |c|
      begin
      @dbh.do(<<SQL)
ALTER TABLE #{table} DROP COLUMN #{c}#{' CASCADE' if cascade}
SQL
      rescue DBI::DatabaseError => e
        SqlHelper.log_sql_error("Could not remove column #{c}", e)
      end
    end
  end

  def rename_column(table, old_name, new_name)
    @dbh.do(<<SQL)
ALTER TABLE #{table} RENAME COLUMN #{old_name} TO #{new_name}
SQL
  end

  def drop_tables(tables, cascade = true)
    begin
      @dbh.do(<<SQL)
DROP TABLE #{[tables].flatten.join(', ')}#{' CASCADE' if cascade}
SQL
    rescue DBI::DatabaseError => e
      SqlHelper.log_sql_error("Could not remove tables #{[tables].flatten.join(', ')}", e)
    end
  end

  def synchronize_table(table_name, primary_key, list)
    keys = get_keys(primary_key, list)
    bad_keys = [ ]
    update_row_keys = Set.new

    @dbh.execute("SELECT #{primary_key.to_s} FROM #{table_name}") do |r|
      r.fetch do |e|
        k = e.first
        if keys.member?(k)
          update_row_keys << k
        else
          bad_keys << k
        end
      end
    end

    new_row_keys = keys - update_row_keys.to_a
    new_rows = list.select { |e| new_row_keys.member?(e[primary_key]) }
    insert_rows(table_name, new_rows)

    update_rows = list.select { |e| update_row_keys.member?(e[primary_key]) }
    update_rows(table_name, primary_key, update_rows)

    @dbh.prepare("DELETE FROM #{table_name} WHERE #{primary_key} = ?") do |ps|
      bad_keys.each do |e|
        ps.execute(e)
      end
    end
  end

  private

  def get_keys(primary_key, list)
     list.inject(Set.new) { |m, o| m << o[primary_key] }.to_a
  end

  def get_all_columns(rows)
    rows.inject(Set.new) do |m, o|
      m += o.instance_of?(Hash) ? o.keys : o.field_names
    end.to_a
  end

  def bind_values(columns, row)
    columns.map { |c| row[c] }
  end

  def get_insert_statement(table, columns)
    <<SQL
INSERT INTO #{table} (#{columns.join(', ')})
VALUES (#{columns.map {|e| '?'}.join(', ') })
SQL
  end

  def get_update_statement(table, primary_key, columns)
    <<SQL
UPDATE #{table}
SET #{columns.map { |c| "#{c} = ?"}.join(', ')}
WHERE #{primary_key} = ?
SQL
  end

  def insert_rows(table, rows)
    columns = get_all_columns(rows)
    @dbh.prepare(get_insert_statement(table, columns)) do |ps|
      rows.each do |r|
        ps.execute(*bind_values(columns, r))
      end
    end
  end

  def update_rows(table, primary_key, rows)
    columns = get_all_columns(rows).reject { |c| primary_key == c }
    @dbh.prepare(get_update_statement(table, primary_key, columns)) do |ps|
      rows.each do |r|
        ps.execute(*bind_values(columns + [primary_key], r))
      end
    end
  end
end

class SchemaUpdater
  def update_schema(dbh)
    LOG.warn('update_schema() not implemented')
  end

  def initialize(dbh)
    @dbh = dbh
    @log = LOG
  end
end

def bad_args()
  LOG.error "usage: update-schema [ settings | events ] [ uvm | node ]"
  Kernel.exit 1
end

def get_column(type)
  case type
  when 'settings'
    'settings_version'
  when 'events'
    'events_version'
  else
    raise UnsupportedFileType
  end
end

def get_latest_version(schema_dir, type)
  Dir.new(schema_dir).map do |f|
    if /#{type}-convert-([0-9]+)\.(sql|rb)$/ =~ f
      $1.to_i
    else
      nil
    end
  end.reject { |e| e.nil? }.max
end

def get_inst_version(dbh, component, type)
  column = get_column(type)

  ps = dbh.prepare(<<SQL)
SELECT #{column} FROM split_schema_ver
WHERE component = ? AND #{column} IS NOT NULL
SQL
  ps.bind_param(1, component)
  ps.execute
  e = ps.entries.first
  e.nil? ? nil : e.first.to_i
end

def update_schema_ver(dbh, component, type, version)
  ps = dbh.prepare(<<SQL)
select * from split_schema_ver where component = ?
SQL
  ps.bind_param(1, component)
  ps.execute

  unless ps.any?
    ps = dbh.prepare(<<SQL)
INSERT INTO split_schema_ver (component, settings_version, events_version)
    VALUES (?, null, null);
SQL
    ps.bind_param(1, component)
    ps.execute()
  end

  ps = dbh.prepare(<<SQL)
UPDATE split_schema_ver SET #{get_column(type)} = ?
    WHERE component = ?
SQL
  ps.bind_param(1, version)
  ps.bind_param(2, component)
  ps.execute()
end

def run_sql_file(file)
  LOG.info "Running SQL file: #{file}"
  Kernel.system "psql -X -U postgres -e uvm -f #{file}"
end

def run_rb_file(dbh, file)
  LOG.info "Running RB file: #{file}"
  updater = SchemaUpdater.new(dbh)
  updater.instance_eval(File.readlines(file).join("\n"))
  updater.update_schema()
end

def run_file(dbh, file)
  if /\.sql$/ =~ file
    run_sql_file(file)
  elsif /\.rb$/ =~ file
    run_rb_file(dbh, file)
  else
    LOG.error("Don't know how to handle: #{file}")
    raise BadFileType
  end
end

def run_schema_init(dbh, dir, type)
  f = ['rb', 'sql'].map { |e| "#{dir}/#{type}-schema.#{e}" }.find { |f| File.exist? f }
  unless f.nil?
    run_file(dbh, f)
  end
end

def run_schema_convert(dbh, dir, type, n)
  f = ['rb', 'sql'].map { |e| "#{dir}/#{type}-convert-#{n}.#{e}" }.find { |f| File.exist? f }
  run_file(dbh, f)
end

def pre50_hacks(dbh)
  ps = dbh.prepare(<<SQL)
UPDATE settings.split_schema_ver SET component = ?
WHERE component = ?
SQL

  { 'uvm' => 'mvvm',
    'untangle-node-webfilter' => 'untangle-base-webfilter',
    'untangle-node-openvpn' => 'openvpn-transform',
    'untangle-node-ips' => 'ids-transform',
    'untangle-node-sigma' => 'sigma-transform',
    'untangle-node-spamassassin' => 'spamassassin-transform',
    'untangle-node-reporting' => 'reporting-transform',
    'untangle-node-protofilter' => 'protofilter-transform',
    'untangle-node-clam' => 'clam-transform',
    'untangle-node-test' => 'test-transform',
    'untangle-node-router' => 'nat-transform',
    'untangle-node-spyware' => 'spyware-transform',
    'untangle-node-firewall' => 'firewall-transform',
    'untangle-node-shield' => 'airgap-transform',
    'untangle-node-phish' => 'clamphish-transform',
    'untangle-node-portal' => 'portal-transform',
    'untangle-node-hauri' => 'hauri-transform',
    'untangle-node-kav' => 'kav-transform',
    'untangle-node-boxbackup' => 'boxbackup-transform',
    'untangle-casing-ftp' => 'ftp-casing',
    'untangle-casing-http' => 'http-casing',
    'untangle-casing-mail' => 'mail-casing',
    'untangle-base-virus' => 'virus-base',
    'untangle-base-spam' => 'spam-base'
  }.each_pair do |k, v|
    ps.bind_param(1, k)
    ps.bind_param(2, v)
    ps.execute()
  end
end

def pre52_hacks(dbh)
  ps = dbh.execute(<<SQL)
DELETE FROM settings.split_schema_ver WHERE component = 'rupuvm';
SQL
end

def setup_schema(dbh)
  unless dbh.select_one('select schema_name from information_schema.schemata where schema_name = \'settings\'')
    dbh.do('CREATE SCHEMA settings')
  end

  unless dbh.tables.any? { |t| 'split_schema_ver' == t }
    dbh.do(<<SQL)
CREATE TABLE settings.split_schema_ver(component text,
                                       settings_version int4,
                                       events_version int4)
SQL
    dbh.do(<<SQL)
ALTER TABLE settings.split_schema_ver
ADD CONSTRAINT schema_ver_pkey PRIMARY KEY (component)
SQL

    dbh.do(<<SQL)
ALTER TABLE split_schema_ver ALTER COLUMN component SET NOT NULL
SQL
  end
end

bad_args() unless 2 == ARGV.length

TYPE=ARGV[0]
bad_args() unless 'settings' == TYPE || 'events' == TYPE

COMPONENT=ARGV[1]

SCHEMA_HOME='@UVM_SCHEMA@'
SCHEMA_DIR="#{SCHEMA_HOME}/#{COMPONENT}"

LOG.info "*** BEGIN update-schema for type: #{TYPE} component: #{COMPONENT}"

begin
  dbh = DBI.connect('DBI:Pg:uvm', 'postgres')

  setup_schema(dbh)
  pre50_hacks(dbh)
  pre52_hacks(dbh)

  latest_version = get_latest_version(SCHEMA_DIR, TYPE)
  inst_version = get_inst_version(dbh, COMPONENT, TYPE)

  LOG.info <<EOF
Component #{COMPONENT}
Type: #{TYPE}
Installed schema: #{inst_version}
Latest schema version: #{latest_version}
EOF

  if inst_version.nil?
    LOG.info 'Initializing schema'
    run_schema_init(dbh, SCHEMA_DIR, TYPE)
    update_schema_ver(dbh, COMPONENT, TYPE, latest_version)
  elsif latest_version.nil?
    LOG.info 'No schema for this component.'
  elsif inst_version > latest_version
    LOG.error 'Installed version greater than latest version'
  elsif inst_version < latest_version
    LOG.info "Converting schema from #{inst_version} to #{latest_version}"
    (inst_version + 1).upto(latest_version) do |n|
      run_schema_convert(dbh, SCHEMA_DIR, TYPE, n)
      update_schema_ver(dbh, COMPONENT, TYPE, n)
    end
  else
    LOG.info 'Schema is up-to-date, initializing schema just in case'
    run_schema_init(dbh, SCHEMA_DIR, TYPE)
  end

ensure
  dbh.disconnect if dbh
  LOG.info "*** END update-schema for type: #{TYPE} component: #{COMPONENT}"
end
