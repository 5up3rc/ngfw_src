#! /bin/bash

if [ $# -gt 1 ]; then
    echo "Usage: update-reports [ yyyy-mm-dd ]"
    echo "  If date specified, assume generating for midnight on that day (ie: 2006-04-09)"
    exit 1
fi
#

PSQL="/usr/bin/psql -U postgres -X"

REPORT_TYPE_MARK="REPORT_TYPE_MARK"
IS_DETAILED_MARK="IS_DETAILED_MARK"
EMAIL_BASE_NAME="${REPORT_TYPE_MARK}_${IS_DETAILED_MARK}"

midnight=$(date +%F)
if [ $# -eq 1 ]; then
    midnight=$1
fi

## Parameters:
## <type> : daily, weekly or monthly
## <isDetailed> : true | false (whether or not this is a detailed)
## <extension> : desired file extension
function getFileName()
{
    local t_type=$1
    local t_isDetailed=$2
    local t_extension=$3
    local t_fileName=${EMAIL_BASE_NAME/${REPORT_TYPE_MARK}/${t_type}}

    if [ "${t_isDetailed}x" == "truex" ]; then
        t_isDetailed="detailed"
    else
        t_isDetailed="briefing"
    fi

    t_fileName=${t_fileName/${IS_DETAILED_MARK}/${t_isDetailed}}

    echo "${t_fileName}.${t_extension}"
}

## Parameters:
## <type> : daily, weekly or monthly
function generateEmail()
{
    local t_reportType=$1
    local t_isDetailed

    ## Run detailed reports
    for t_isDetailed in "true" "false" ; do
        ## Actually generate the PDF, email and index
        REPORT_TYPE=${t_reportType} \
            REPORT_BASE=$REPORT_DIR/current \
            SHOW_DETAILED_REPORTS=${t_isDetailed} \
            sh @UVM_HOME@/reports/generate-pdf `getFileName ${t_reportType} ${t_isDetailed} pdf`
    done
}

function mailReports()
{
    local t_reportType=$1
    local t_isDetailed=${MV_EG_EMAIL_DETAIL/y/true}
    t_isDetailed=${t_isDetailed/n/false}
    local t_arguments=`getFileName ${t_reportType} ${t_isDetailed} txt`

    cat "@PREFIX@/tmp/${t_arguments}" | xargs @UVM_HOME@/reports/mail-reports
}

## Parameters:
## <estat> : exit status
## <src> : source of error
function exitOnUvmError()
{
    local t_estat=$1
    local t_src=$2
    if [ $t_estat != 0 ]; then
        echo $t_src "error, exit status:" $t_estat
        exit $t_estat
    fi
}

## Parameters:
## <tablename>: name of table to test for
function doesEventTableExist()
{
    local t_tname=$1
    local t_num=`$PSQL -qt -c "select count(*) from pg_tables where schemaname='events' and tablename='$1';" uvm`
    if [ -n "$t_num" -a "$t_num" -gt 0 ]; then
        # exists
        return 0
    else
        # does not exist
        return 1
    fi
}


REPORT_DIR=@UVM_WEB@/reports

# New for 4.2 -- if we're still reporting from yesterday, just keep going.
isrunning=$(@USR_BIN@/mcli -t 3600 isReportingRunning)
if [ "${isrunning}x" = "truex" ]; then
    echo "reports still running from yesterday, waiting for those to finish"
    exit 1
fi

################################################################################
# CLEANUP SECTION

# We keep more than 30 days so that we'll have all the session starts, dhcp
# starts, etc for the 30 day period.
NUMDAYSTOKEEP=${MV_EG_DAYS_TO_KEEP:-33}

# Build list of event & report days for which generation is needed.
$PSQL -v midnight="'$midnight'" -v daystosave="$NUMDAYSTOKEEP" -v intable="events.event_data_days" -v outtable="events.daystoadd" -f @UVM_SCHEMA@/uvm/getdaystoadd.sql uvm
$PSQL -v midnight="'$midnight'" -v daystosave="$NUMDAYSTOKEEP" -v intable="reports.report_data_days" -v outtable="reports.daystoadd" -f @UVM_SCHEMA@/uvm/getdaystoadd.sql uvm

# roll up logs, deleting any more than $NUMDAYSTOKEEP days old (and thus unreportable  on)
@UVM_HOME@/reports/rollup-logs $midnight $NUMDAYSTOKEEP

# Build event partitions
# For 4.2, disabled.
#
# daystoadd=`mktemp`
# $PSQL -qt uvm > $daystoadd <<EOF
#   select day_name, day_begin from events.daystoadd order by day_begin ;
# EOF
# while read dayname ignore daybegin; do
#     # Skip blank lines
#     if [ x"$dayname" = x ]; then
#         continue
#     fi
#     dayend="'$daybegin' + interval '1 days'"
#     for basetablename in `cat @UVM_SCHEMA@/*/partitioned-tables`; do
#         doesEventTableExist $basetablename || continue
#         tablename=${basetablename}_$dayname
#         $PSQL -v tablename="$tablename" -v basetablename="$basetablename" -v daybegin="'$daybegin'" -v dayend="$dayend" -f @UVM_SCHEMA@/uvm/buildpartition.sql uvm
#         rowcount=`$PSQL -qt uvm -c "select count(*) from $tablename;"`
#         if [ -n "$rowcount" ]; then
#             if [ -a "$rowcount" -eq 0 ]; then
#                 $PSQL uvm -c "DROP TABLE $tablename;"
#             else
#                 indicestoadd=`mktemp`
#                 $PSQL -qt uvm -c "select indexdef from pg_indexes where tablename = '$basetablename';" > $indicestoadd
#                 sed -i $indicestoadd -e "s/$basetablename/$tablename/g" -e "s/\$/;/"
#                 $PSQL -f $indicestoadd uvm
#                 rm $indicestoadd
#             fi
#         fi
#     done
#     $PSQL -v dayname="'$dayname'" -v daybegin="'$daybegin'" uvm <<EOF
#       insert into events.event_data_days values (:dayname, DATE :daybegin);
# EOF
# done < $daystoadd
# rm $daystoadd

echo "VACUUM ANALYZE;" | $PSQL uvm

# END CLEANUP SECTION
################################################################################

rm -rf $REPORT_DIR/current
# Just in case left over (we use a jsp now)
rm -f $REPORT_DIR/index.html

# can't use shell to assign default value for unset parameter because
# when an exception occurs in mcli,
# parameter becomes set with non-null value
is_reporting_enabled=$(@USR_BIN@/mcli isReportingEnabled)
exitOnUvmError $? uvm

# Only generate today's reports if the reporting node is running
if [ $is_reporting_enabled == 'true' ]; then

    # Build the DHCP Merged Address Map (needed for running start-reports scripts)
    @USR_BIN@/mcli -t 3600 prepareReports -o $REPORT_DIR -d 60 -n $midnight
    exitOnUvmError $? reporter
    # note that Reporter has just created settings.env and daystoadd

    if [ -h $REPORT_DIR/current -a -f $REPORT_DIR/current/settings.env ]; then
        source $REPORT_DIR/current/settings.env

        # Build pre-joined reports tables
        daystoadd=`mktemp -t update-reports.XXXXXXXXXX`
        $PSQL -qt uvm > $daystoadd <<EOF
          select day_name, day_begin from reports.daystoadd order by day_begin;
EOF
        while read dayname ignore daybegin; do
            # Skip blank lines
            if [ x"$dayname" = x ]; then
                continue
            fi
            dayend="'$daybegin' + interval '1 days'"
            for c in @UVM_SCHEMA@/*/report-add-day.sql; do
                $PSQL -v dayname="$dayname" -v daybegin="'$daybegin'" -v dayend="$dayend" -f $c uvm
            done
            $PSQL -v dayname="'$dayname'" -v daybegin="'$daybegin'" uvm <<EOF
insert into reports.report_data_days values (:dayname, DATE :daybegin);
EOF
        done < $daystoadd
        rm $daystoadd

        echo "ANALYZE;" | $PSQL uvm

        # create files w/ username and hostname lists for usersummary-reports
        $PSQL -qt uvm -c "SELECT DISTINCT username FROM events.u_lookup_evt;" -o $REPORT_DIR/current/uname.tmp2
        grep -v "^$" $REPORT_DIR/current/uname.tmp2 > $REPORT_DIR/current/uname.tmp
        $PSQL -qt uvm -c "SELECT DISTINCT hname FROM reports.sessions WHERE client_intf=1;" -o $REPORT_DIR/current/hname.tmp2
        grep -v "^$" $REPORT_DIR/current/hname.tmp2 > $REPORT_DIR/current/hname.tmp
        rm -f $REPORT_DIR/current/uname.tmp2
        rm -f $REPORT_DIR/current/hname.tmp2

        rm -f $REPORT_DIR/current/uname.lst
        rm -f $REPORT_DIR/current/hname.lst
        # strip all dir seps and spaces from name
        # because this name is used to generate a filename
        while read line
        do
            echo ${line//[\/| ]/} ${line} >> $REPORT_DIR/current/uname.lst
        done < $REPORT_DIR/current/uname.tmp
        touch $REPORT_DIR/current/uname.lst
        while read line
        do
            echo ${line//[\/| ]/} ${line} >> $REPORT_DIR/current/hname.lst
        done < $REPORT_DIR/current/hname.tmp
        touch $REPORT_DIR/current/hname.lst
        rm -f $REPORT_DIR/current/uname.tmp
        rm -f $REPORT_DIR/current/hname.tmp

        @USR_BIN@/mcli -t 3600 startReports
        exitOnUvmError $? reporter

        is_running=$(@USR_BIN@/mcli isReportingRunning)
        while [ $is_running != 'false' ]; do
            sleep 5
            is_running=$(@USR_BIN@/mcli isReportingRunning)
        done

        cp -pr $REPORT_DIR/css $REPORT_DIR/current
        cp -pr $REPORT_DIR/images $REPORT_DIR/current
        cp -pr @UVM_WEB@/ROOT/images/BrandingLogo.gif $REPORT_DIR/current/images

# generate the web viewable page
        if [ $MV_EG_DAILY_REPORT == 'y' ]; then
            @UVM_HOME@/reports/index-reports index.html daily false $midnight
        fi
        if [ $MV_EG_WEEKLY_REPORT == 'y' ]; then
            @UVM_HOME@/reports/index-reports index_online_weekly.html weekly false $midnight
        fi
        if [ $MV_EG_MONTHLY_REPORT == 'y' ]; then
            @UVM_HOME@/reports/index-reports index_online_monthly.html monthly false $midnight
        fi

# convert all non-index html pages to have MV look-n-feel
# (convert-reports doesn't look for daily, weekly, or monthly html pages
#  so if any set is missing, it is okay)
        @UVM_HOME@/reports/convert-reports

# generate the emailable page
        cd /
        if [ $MV_EG_DAILY_REPORT == 'y' ]; then
            generateEmail "daily"
        fi
        if [ $MV_EG_WEEKLY_REPORT == 'y' ]; then
            generateEmail "weekly"
        fi
        if [ $MV_EG_MONTHLY_REPORT == 'y' ]; then
            generateEmail "monthly"
        fi

# email the reports to all recipients
        cd $REPORT_DIR/current
        if [ $MV_EG_DAILY_REPORT == 'y' ]; then
            mailReports "daily"
        fi
        if [ $MV_EG_WEEKLY_REPORT == 'y' ]; then
            mailReports "weekly"
        fi
        if [ $MV_EG_MONTHLY_REPORT == 'y' ]; then
            mailReports "monthly"
        fi

# ensure that a base index file is present
        cd $REPORT_DIR/current
        if [ $MV_EG_DAILY_REPORT == 'n' ]; then
            rm -f index.html
            if [ $MV_EG_WEEKLY_REPORT == 'y' ]; then
                ln -s index_online_weekly.html index.html
            elif [ $MV_EG_MONTHLY_REPORT == 'y' ]; then
                ln -s index_online_monthly.html index.html
            fi
        fi
    fi

# No need for this at the end anymore.
#    echo "VACUUM ANALYZE;" | $PSQL uvm
else
    echo "reporting is disabled"
fi
