#! /bin/bash
# $Id$

NAME=$0

# get a bunch of default values
source @PREFIX@/etc/default/untangle-vm

UVM_CONSOLE_LOG=${UVM_CONSOLE_LOG:-"@PREFIX@/var/log/uvm/console.log"}
UVM_UVM_LOG=${UVM_UVM_LOG:-"@PREFIX@/var/log/uvm/uvm.log"}
UVM_GC_LOG=${UVM_GC_LOG:-"@PREFIX@/var/log/uvm/gc.log"}
UVM_WRAPPER_LOG=${UVM_WRAPPER_LOG:-"@PREFIX@/var/log/uvm/wrapper.log"}
UVM_LAUNCH=${UVM_LAUNCH:-"@PREFIX@/usr/share/untangle/bin/bunnicula"}

# Short enough to restart services and uvm promptly
SLEEP_TIME=15

# Used to kill a child with extreme prejudice
nukeIt() {
    echo "$NAME: Killing -9 all bunnicula \"$pid\" (`date`)" >> $UVM_WRAPPER_LOG
    kill -3 $pid
    kill -9 $pid
    kill -9 `ps awwx | grep java | grep bunnicula | awk '{print $1}'` 2>/dev/null
}

reapChildHardest() {
    nukeIt
    flushIptables ; exit
}

reapChildHarder() {
    echo "$NAME: Killing -15 all bunnicula \"$pid\" (`date`)" >> $UVM_WRAPPER_LOG
    kill $pid
    sleep 1
    if [ ! -z "`ps awwx | grep java | grep bunnicula | awk '{print $1}'`" ] ; then
        echo "$NAME: Killing -15 all bunnicula \"$pid\" (`date`)" >> $UVM_WRAPPER_LOG
        for i in `seq 1 5` ; do
            if [ -z "`ps awwx | grep java | grep bunnicula | awk '{print $1}'`" ] ; then
                flushIptables ; exit
            fi
            sleep 1
        done
        if [ ! -z "`ps awwx | grep java | grep bunnicula | awk '{print $1}'`" ] ; then
            reapChildHardest
        fi
    fi
    flushIptables ; exit
}

getVirtualMemUsage() {
  cat /proc/$1/status | awk '/VmSize/ {print $2}'
}

reapChild() {
    echo "$NAME: shutting down bunnicula " >> $UVM_WRAPPER_LOG
    kill -3 $pid
    @PREFIX@/usr/bin/mcli -t 20000 shutdown &> /dev/null
    sleep 1
    kill -INT $pid
    if [ ! -z "`ps awwx | grep java | grep bunnicula | awk '{print $1}'`" ] ; then
        echo "$NAME: Killing -INT all bunnicula \"$pid\" (`date`)" >> $UVM_WRAPPER_LOG
        for i in `seq 1 5` ; do
            if [ -z "`ps awwx | grep java | grep bunnicula | awk '{print $1}'`" ] ; then
                flushIptables ; exit
            fi
            sleep 1
        done
        if [ ! -z "`ps awwx | grep java | grep bunnicula | awk '{print $1}'`" ] ; then
            reapChildHarder
        fi
    fi
    flushIptables ; exit
}


flushIptables() {
    if [ ! -f /etc/untangle-net-alpaca/nonce ] ; then
        echo "the nonce doesn't exist, unable to regenerate rules."
        return
    fi

    local t_nonce=`head -n 1 /etc/untangle-net-alpaca/nonce`

    ## Tell the alpaca to reload the rules
    curl "http://localhost:3000/alpaca/uvm/generate_rules?argyle=${t_nonce}"
}

# In 5.3, this code is only used to handle the upgrade and factory-defaults cases.
getPopId() {
  # for new installs from iso, do nothing
  [[ -f $ACTIVATION_KEY_FILE ]] || return

  # for package installs, do nothing
  [[ -f $POPID_FILE ]] && return

  # ensure we have a popid
  @UVM_HOME@/bin/utactivate
}

# Return true (0) when we need to reap and restart the uvm.
needToRestart() {
    cheaphigh=`head -3 /proc/$pid/maps | tail -1 | awk '{ high=split($1, arr, "-"); print arr[2]; }'`
    if [ -z $cheaphigh ]; then
        # not fatal, process has probably just died, which we'll catch soon.
        echo "*** no heap size ($cheaphigh) on `date` in `pwd` ***" >> $UVM_WRAPPER_LOG
    else
        bignibble=${cheaphigh:0:1}
        case $bignibble in
            0 | 1)
                # less than 384Meg native heap
                ;;
            2 | 3 | 4 | 5  |6 | 7 | 8 | 9)
	       for testNibble in $HEAP_SOFT_LIMIT ; do
		 if [ $bignibble = $testNibble ] ; then
                   if [ $MEM -lt 1000000 ] || [ `date +%H` -eq 1 ] ; then
                     echo "*** bunnicula heap soft limit on `date` in `pwd` ***" >> $UVM_WRAPPER_LOG
                     return 0;
                   fi
		 fi
	       done

	       for testNibble in $HEAP_HARD_LIMIT ; do
		 if [ $bignibble = $testNibble ] ; then
                   echo "*** bunnicula heap hard limit ($bignibble) on `date` in `pwd` ***" >> $UVM_WRAPPER_LOG
                   return 0;
		 fi
	       done
               ;;
            *)
                echo "*** unexpected heap size ($bignibble) on `date` in `pwd` ***" >> $UVM_WRAPPER_LOG
                ;;
        esac
    fi

    return 1;
}

update_monit()
{
    monit -c /etc/untangle/monit.conf status | grep -q 'monitoring status\s*not monitored' && {
        echo "`date` telling monit to monitor all services." >> $UVM_WRAPPER_LOG
        monit -c /etc/untangle/monit.conf monitor all
    }
}


UVM_PRE_UVM_SCRIPT=${UVM_PRE_UVM_SCRIPT:-@PREFIX@/var/lib/untangle-windows-installer/pre_uvm.rb}
UVM_AUTO_CONFIG=${UVM_AUTO_CONFIG:-@PREFIX@/mnt/hgfs/untangle/config.js}

# auto configuration script
[ -x ${UVM_PRE_UVM_SCRIPT} ]  && [ -f ${UVM_AUTO_CONFIG} ] && {
    UVM_STATUS_FILE=${UVM_STATUS_FILE:-@PREFIX@/mnt/hgfs/untangle/status}
    if [ -d `dirname ${UVM_STATUS_FILE}` ] ; then echo "Installing" > $UVM_STATUS_FILE ; fi

    mkdir -p /var/log/uvm/
    ${UVM_PRE_UVM_SCRIPT} ${UVM_AUTO_CONFIG} >> /var/log/uvm/auto_config.log 2>&1
}

trap reapChildHardest 6
trap reapChildHarder 15
trap reapChild 2

monit -c /etc/untangle/monit.conf unmonitor postgres
@PREFIX@/usr/share/untangle/bin/migrate-postgres.sh >> $UVM_WRAPPER_LOG
monit -c /etc/untangle/monit.conf monitor postgres

while true; do
    echo > $UVM_CONSOLE_LOG
    echo "============================" >> $UVM_CONSOLE_LOG
    echo $UVM_LAUNCH >> $UVM_CONSOLE_LOG
    echo "============================" >> $UVM_CONSOLE_LOG

    echo >> $UVM_WRAPPER_LOG
    echo "============================" >> $UVM_WRAPPER_LOG
    echo $UVM_LAUNCH >> $UVM_WRAPPER_LOG
    echo "============================" >> $UVM_WRAPPER_LOG

    flushIptables

    getPopId

    $UVM_LAUNCH $* >>$UVM_CONSOLE_LOG 2>&1 &

    pid=$!
    echo "Bunnicula launched. (pid:$pid) (`date`)" >> $UVM_WRAPPER_LOG

    # Instead of waiting, we now monitor.
    while true; do
        sleep $SLEEP_TIME
        
        if [ "x" = "x@PREFIX@" ] ; then
             ## if necessary tell monit to keep monitoring everything.
            update_monit

            if [ ! -d /proc/$pid ] ; then
                echo "*** restarting missing bunnicula $? on `date` ***" >> $UVM_WRAPPER_LOG
                break
            fi
            if needToRestart; then
                echo "*** need to restart bunnicula $? on `date` ***" >> $UVM_WRAPPER_LOG
                nukeIt
                break
            fi
        fi

    done

# Clean up the zombie.  Risky? XXX
#    wait $pid

# Crash/Kill
    flushIptables
    echo "*** bunnicula exited on `date` in `pwd` ***" >> $UVM_WRAPPER_LOG
    echo "*** copied $UVM_CONSOLE_LOG to $UVM_CONSOLE_LOG.crash ***" >> $UVM_WRAPPER_LOG
    echo "*** copied $UVM_UVM_LOG to $UVM_UVM_LOG.crash ***" >> $UVM_WRAPPER_LOG
    echo "*** copied $UVM_GC_LOG to $UVM_GC_LOG.crash ***" >> $UVM_WRAPPER_LOG
    cp -fa $UVM_CONSOLE_LOG.crash.1 $UVM_CONSOLE_LOG.crash.2
    cp -fa $UVM_CONSOLE_LOG.crash $UVM_CONSOLE_LOG.crash.1
    cp -fa $UVM_CONSOLE_LOG $UVM_CONSOLE_LOG.crash
    cp -fa $UVM_UVM_LOG.crash.1 $UVM_UVM_LOG.crash.2
    cp -fa $UVM_UVM_LOG.crash $UVM_UVM_LOG.crash.1
    cp -fa $UVM_UVM_LOG $UVM_UVM_LOG.crash
    cp -fa $UVM_GC_LOG.crash.1 $UVM_GC_LOG.crash.2
    cp -fa $UVM_GC_LOG.crash $UVM_GC_LOG.crash.1
    cp -fa $UVM_GC_LOG $UVM_GC_LOG.crash
    cp -fa $MONIT_LOG.crash.1 $MONIT_LOG.crash.2
    cp -fa $MONIT_LOG.crash $MONIT_LOG.crash.1
    cp -fa $MONIT_LOG $MONIT_LOG.crash
    cp -fa $PACKAGES_LOG.crash.1 $PACKAGES_LOG.crash.2
    cp -fa $PACKAGES_LOG.crash $PACKAGES_LOG.crash.1
    dpkg -l "untangle*" >| $PACKAGES_LOG.crash

    sleep 2
    echo "*** restarting on `date` ***" >> $UVM_WRAPPER_LOG
done
