/**
 * $Id$
 */
package com.untangle.uvm.node;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.InputStreamReader;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import org.apache.log4j.Logger;

import com.untangle.uvm.UvmContextFactory;

/* XXX This should probably be abstracted, up to a script writer and then have a
 * class that is a shell script writer
 */
public class ScriptWriter
{
    private final Logger logger = Logger.getLogger(getClass());

    public static final String COMMENT         = "#";

    /* Split so that other script writers can use the constant */
    public static final String UNTANGLE_HEADER = "AUTOGENERATED BY UNTANGLE DO NOT MODIFY\n\n";
    private static final String SCRIPT_HEADER   = "#!/bin/bash\n\n" + COMMENT + " " + UNTANGLE_HEADER;

    private static final String EXPORT_FLAG     = "export";

    private static final String EMPTY_HEADER[]  = new String[0];

    private static final Pattern ESCAPE_PATTERN;
    private static final String ESCAPE_STRING = "'";
    /* For shell, single ticks even escaped single ticks are not
     * allowed in a string of single ticks.  The only option is to
     * close the single tick, add one in double ticks and then reopen it */
    private static final String ESCAPE_REPLACEMENT = "'\"'\"'";

    private final StringBuilder sb;

    public ScriptWriter()
    {
        this( EMPTY_HEADER );
    }

    public ScriptWriter( String header[] )
    {
        this.sb = new StringBuilder();
        this.sb.append( header());

        appendLines( header );
    }

    public void appendLine()
    {
        this.sb.append( "\n" );
    }

    /** Kind of a silly helper functions to avoid "\n" everywhere " */
    public void appendLine( String text )
    {
        this.sb.append( text + "\n" );
    }

    public void appendLines( String ... text )
    {
        for ( String line : text ) appendLine( line );
    }

    public void appendComment( String text )
    {
        for ( String line : text.split( "\n" )) this.sb.append( comment() + " " + line + "\n" );
    }
    
    // Really only for shell scripts
    public void appendVariable( String variable, boolean value )
    {
        appendVariable( variable, String.valueOf( value ));
    }

    public void appendVariable( String variable, boolean value, boolean isGlobal )
    {
        appendVariable( variable, String.valueOf( value ), isGlobal );
    }

    public void appendVariable( String variable, int value )
    {
        appendVariable( variable, String.valueOf( value ));
    }

    public void appendVariable( String variable, int value, boolean isGlobal )
    {
        appendVariable( variable, String.valueOf( value ), isGlobal );
    }
    
    // This should be rewritten so all of these methods are final, and then
    // the method that takes four arguments is protected.
    public void appendVariable( String variable, String value, boolean isGlobal )
    {
        appendVariable( variable, value, isGlobal, false );
    }

    public void appendVariable( String variable, String value )
    {
        appendVariable( variable, value, false, false );
    }

    /** Append a variable that is escaped, and global (exported) */
    public void appendGlobalEscapedVariable( String variable, String value )
    {
        appendVariable( variable, value, true, true );
    }

    /** Append a variable that is escaped, not global (exported) */
    public void appendEscapedVariable( String variable, String value )
    {
        appendVariable( variable, value, false, true );
    }

    private void appendVariable( String variable, String value, boolean isGlobal, boolean isEscaped )
    {
        if (( variable == null ) || ( value == null )) {
            logger.warn( "NULL variable[" + variable +"] or value[" + value + "], ignoring" );
            return;
        }

        variable = variable.trim();
        value    = value.trim();

        if ( variable.length() == 0 ) {
            /* This is a jenky way to get a stack trace */
            logger.warn( "Empty variable name, ignoring", new Exception());
            return;
        }

        String quotes = "\"";

        if ( isEscaped ) {
            /* Just in case it wasn't able to be compiled at startup, that should never
             * happpen, but just in case */
            if ( ESCAPE_PATTERN != null ) {
                value = ESCAPE_PATTERN.matcher( value ).replaceAll( ESCAPE_REPLACEMENT );
            }
            quotes = "'";
        }

        appendLine((( isGlobal ) ? EXPORT_FLAG + " " : "" ) + variable + "=" + quotes + value + quotes );
    }


    /* Structured this way so different script writers can use different comment indicators */
    protected String comment()
    {
        return COMMENT;
    }

    protected String header()
    {
        return SCRIPT_HEADER;
    }

    public String getContents()
    {
        return sb.toString();
    }

    /**
     * Write out the file to filename
     */
    public void writeFile( String fileName )
    {
        BufferedWriter out = null;

        /* Open up the interfaces file */
        try {
            String data = sb.toString();

            out = new BufferedWriter(new FileWriter( fileName ));
            out.write( data, 0, data.length());
        } catch ( Exception ex ) {
            /* XXX May need to catch this exception, restore defaults
             * then try again */
            logger.error( "Error writing file " + fileName + ":", ex );
        }

        try {
            if ( out != null ) out.close();
        } catch ( Exception ex ) {
            logger.error( "Unable to close file", ex );
        }

    }

    static {
        Pattern pattern = null;

        try {
            pattern = Pattern.compile( ESCAPE_STRING );
        } catch ( PatternSyntaxException e ) {
            System.err.println( "Unable to compile pattern, using null" );
            pattern = null;
        }

        ESCAPE_PATTERN = pattern;
    }
}
